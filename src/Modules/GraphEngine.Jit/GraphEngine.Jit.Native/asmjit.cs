// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace GraphEngine.Jit.Native
{
    namespace Asmjit
    {
        /// <summary>Architecture-dependent</summary>
        public unsafe partial class X86Compiler : global::GraphEngine.Jit.Native.Asmjit.CodeCompiler, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 472)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_CodeEmitter;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(24)]
                internal global::System.IntPtr _code;

                [FieldOffset(32)]
                internal global::System.IntPtr _nextEmitter;

                [FieldOffset(40)]
                internal byte _type;

                [FieldOffset(41)]
                internal byte _destroyed;

                [FieldOffset(42)]
                internal byte _finalized;

                [FieldOffset(43)]
                internal byte _reserved;

                [FieldOffset(44)]
                internal uint _lastError;

                [FieldOffset(48)]
                internal uint _privateData;

                [FieldOffset(52)]
                internal uint _globalHints;

                [FieldOffset(56)]
                internal uint _globalOptions;

                [FieldOffset(60)]
                internal uint _options;

                [FieldOffset(64)]
                internal global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal _extraReg;

                [FieldOffset(72)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(80)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal _none;

                [FieldOffset(96)]
                internal global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal _nativeGpReg;

                [FieldOffset(112)]
                internal global::System.IntPtr _nativeGpArray;

                [FieldOffset(120)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _cbBaseZone;

                [FieldOffset(152)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _cbDataZone;

                [FieldOffset(184)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _cbPassZone;

                [FieldOffset(216)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal _cbHeap;

                [FieldOffset(312)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _cbPasses;

                [FieldOffset(336)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _cbLabels;

                [FieldOffset(360)]
                internal global::System.IntPtr _firstNode;

                [FieldOffset(368)]
                internal global::System.IntPtr _lastNode;

                [FieldOffset(376)]
                internal global::System.IntPtr _cursor;

                [FieldOffset(384)]
                internal uint _position;

                [FieldOffset(388)]
                internal uint _nodeFlags;

                [FieldOffset(392)]
                internal global::System.IntPtr _func;

                [FieldOffset(400)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _vRegZone;

                [FieldOffset(432)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _vRegArray;

                [FieldOffset(456)]
                internal global::System.IntPtr _localConstPool;

                [FieldOffset(464)]
                internal global::System.IntPtr _globalConstPool;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Compiler@asmjit@@QEAA@PEAVCodeHolder@1@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr code);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??BX86Compiler@asmjit@@QEAAAEAVX86Emitter@1@XZ")]
                internal static extern global::System.IntPtr OperatorConversion(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newReg@X86Compiler@asmjit@@QEAA?AVX86Reg@2@I@Z")]
                internal static extern void NewReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newReg@X86Compiler@asmjit@@QEAA?AVX86Reg@2@IPEBDZZ")]
                internal static extern void NewReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpReg@X86Compiler@asmjit@@QEAA?AVX86Gp@2@I@Z")]
                internal static extern void NewGpReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpReg@X86Compiler@asmjit@@QEAA?AVX86Gp@2@IPEBDZZ")]
                internal static extern void NewGpReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newMmReg@X86Compiler@asmjit@@QEAA?AVX86Mm@2@I@Z")]
                internal static extern void NewMmReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newMmReg@X86Compiler@asmjit@@QEAA?AVX86Mm@2@IPEBDZZ")]
                internal static extern void NewMmReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKReg@X86Compiler@asmjit@@QEAA?AVX86KReg@2@I@Z")]
                internal static extern void NewKReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKReg@X86Compiler@asmjit@@QEAA?AVX86KReg@2@IPEBDZZ")]
                internal static extern void NewKReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmReg@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@I@Z")]
                internal static extern void NewXmmReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmReg@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@IPEBDZZ")]
                internal static extern void NewXmmReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newYmmReg@X86Compiler@asmjit@@QEAA?AVX86Ymm@2@I@Z")]
                internal static extern void NewYmmReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newYmmReg@X86Compiler@asmjit@@QEAA?AVX86Ymm@2@IPEBDZZ")]
                internal static extern void NewYmmReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newZmmReg@X86Compiler@asmjit@@QEAA?AVX86Zmm@2@I@Z")]
                internal static extern void NewZmmReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newZmmReg@X86Compiler@asmjit@@QEAA?AVX86Zmm@2@IPEBDZZ")]
                internal static extern void NewZmmReg(global::System.IntPtr instance, global::System.IntPtr @return, uint typeId, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newI8@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewI8(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newI8@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewI8(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newU8@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewU8(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newU8@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewU8(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newI16@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewI16(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newI16@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewI16(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newU16@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewU16(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newU16@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewU16(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newI32@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewI32(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newI32@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewI32(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newU32@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewU32(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newU32@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewU32(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newI64@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewI64(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newI64@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewI64(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newU64@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewU64(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newU64@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewU64(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt8@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewInt8(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt8@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewInt8(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt8@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewUInt8(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt8@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewUInt8(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt16@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewInt16(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt16@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewInt16(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt16@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewUInt16(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt16@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewUInt16(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt32@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewInt32(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt32@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewInt32(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt32@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewUInt32(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt32@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewUInt32(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt64@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewInt64(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt64@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewInt64(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt64@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewUInt64(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt64@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewUInt64(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newIntPtr@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewIntPtr(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newIntPtr@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewIntPtr(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUIntPtr@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewUIntPtr(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUIntPtr@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewUIntPtr(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpb@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewGpb(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpb@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewGpb(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpw@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewGpw(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpw@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewGpw(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpd@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewGpd(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpd@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewGpd(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpq@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewGpq(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpq@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewGpq(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpz@X86Compiler@asmjit@@QEAA?AVX86Gp@2@XZ")]
                internal static extern void NewGpz(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newGpz@X86Compiler@asmjit@@QEAA?AVX86Gp@2@PEBDZZ")]
                internal static extern void NewGpz(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKb@X86Compiler@asmjit@@QEAA?AVX86KReg@2@XZ")]
                internal static extern void NewKb(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKb@X86Compiler@asmjit@@QEAA?AVX86KReg@2@PEBDZZ")]
                internal static extern void NewKb(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKw@X86Compiler@asmjit@@QEAA?AVX86KReg@2@XZ")]
                internal static extern void NewKw(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKw@X86Compiler@asmjit@@QEAA?AVX86KReg@2@PEBDZZ")]
                internal static extern void NewKw(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKd@X86Compiler@asmjit@@QEAA?AVX86KReg@2@XZ")]
                internal static extern void NewKd(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKd@X86Compiler@asmjit@@QEAA?AVX86KReg@2@PEBDZZ")]
                internal static extern void NewKd(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKq@X86Compiler@asmjit@@QEAA?AVX86KReg@2@XZ")]
                internal static extern void NewKq(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newKq@X86Compiler@asmjit@@QEAA?AVX86KReg@2@PEBDZZ")]
                internal static extern void NewKq(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newMm@X86Compiler@asmjit@@QEAA?AVX86Mm@2@XZ")]
                internal static extern void NewMm(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newMm@X86Compiler@asmjit@@QEAA?AVX86Mm@2@PEBDZZ")]
                internal static extern void NewMm(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmm@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@XZ")]
                internal static extern void NewXmm(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmm@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@PEBDZZ")]
                internal static extern void NewXmm(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmSs@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@XZ")]
                internal static extern void NewXmmSs(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmSs@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@PEBDZZ")]
                internal static extern void NewXmmSs(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmSd@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@XZ")]
                internal static extern void NewXmmSd(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmSd@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@PEBDZZ")]
                internal static extern void NewXmmSd(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmPs@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@XZ")]
                internal static extern void NewXmmPs(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmPs@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@PEBDZZ")]
                internal static extern void NewXmmPs(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmPd@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@XZ")]
                internal static extern void NewXmmPd(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmPd@X86Compiler@asmjit@@QEAA?AVX86Xmm@2@PEBDZZ")]
                internal static extern void NewXmmPd(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newYmm@X86Compiler@asmjit@@QEAA?AVX86Ymm@2@XZ")]
                internal static extern void NewYmm(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newYmm@X86Compiler@asmjit@@QEAA?AVX86Ymm@2@PEBDZZ")]
                internal static extern void NewYmm(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newYmmPs@X86Compiler@asmjit@@QEAA?AVX86Ymm@2@XZ")]
                internal static extern void NewYmmPs(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newYmmPs@X86Compiler@asmjit@@QEAA?AVX86Ymm@2@PEBDZZ")]
                internal static extern void NewYmmPs(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newYmmPd@X86Compiler@asmjit@@QEAA?AVX86Ymm@2@XZ")]
                internal static extern void NewYmmPd(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newYmmPd@X86Compiler@asmjit@@QEAA?AVX86Ymm@2@PEBDZZ")]
                internal static extern void NewYmmPd(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newZmm@X86Compiler@asmjit@@QEAA?AVX86Zmm@2@XZ")]
                internal static extern void NewZmm(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newZmm@X86Compiler@asmjit@@QEAA?AVX86Zmm@2@PEBDZZ")]
                internal static extern void NewZmm(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newZmmPs@X86Compiler@asmjit@@QEAA?AVX86Zmm@2@XZ")]
                internal static extern void NewZmmPs(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newZmmPs@X86Compiler@asmjit@@QEAA?AVX86Zmm@2@PEBDZZ")]
                internal static extern void NewZmmPs(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newZmmPd@X86Compiler@asmjit@@QEAA?AVX86Zmm@2@XZ")]
                internal static extern void NewZmmPd(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newZmmPd@X86Compiler@asmjit@@QEAA?AVX86Zmm@2@PEBDZZ")]
                internal static extern void NewZmmPd(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string nameFmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newStack@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IIPEBD@Z")]
                internal static extern void NewStack(global::System.IntPtr instance, global::System.IntPtr @return, uint size, uint alignment, [MarshalAs(UnmanagedType.LPStr)] string name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IPEBX_K@Z")]
                internal static extern void NewConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, global::System.IntPtr data, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newByteConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IE@Z")]
                internal static extern void NewByteConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, byte val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newWordConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IG@Z")]
                internal static extern void NewWordConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, ushort val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newDWordConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@II@Z")]
                internal static extern void NewDWordConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, uint val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newQWordConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@I_K@Z")]
                internal static extern void NewQWordConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt16Const@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IF@Z")]
                internal static extern void NewInt16Const(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, short val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt16Const@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IG@Z")]
                internal static extern void NewUInt16Const(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, ushort val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt32Const@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IH@Z")]
                internal static extern void NewInt32Const(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, int val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt32Const@X86Compiler@asmjit@@QEAA?AVX86Mem@2@II@Z")]
                internal static extern void NewUInt32Const(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, uint val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newInt64Const@X86Compiler@asmjit@@QEAA?AVX86Mem@2@I_J@Z")]
                internal static extern void NewInt64Const(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, long val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newUInt64Const@X86Compiler@asmjit@@QEAA?AVX86Mem@2@I_K@Z")]
                internal static extern void NewUInt64Const(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newFloatConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IM@Z")]
                internal static extern void NewFloatConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, float val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newDoubleConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IN@Z")]
                internal static extern void NewDoubleConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, double val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newMmConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IAEBTData64@2@@Z")]
                internal static extern void NewMmConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newXmmConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IAEBTData128@2@@Z")]
                internal static extern void NewXmmConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newYmmConst@X86Compiler@asmjit@@QEAA?AVX86Mem@2@IAEBTData256@2@@Z")]
                internal static extern void NewYmmConst(global::System.IntPtr instance, global::System.IntPtr @return, uint scope, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?overwrite@X86Compiler@asmjit@@QEAAAEAV12@XZ")]
                internal static extern global::System.IntPtr Overwrite(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?call@X86Compiler@asmjit@@QEAAPEAVCCFuncCall@2@AEBVX86Gp@2@AEBUFuncSignature@2@@Z")]
                internal static extern global::System.IntPtr Call(global::System.IntPtr instance, global::System.IntPtr dst, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?call@X86Compiler@asmjit@@QEAAPEAVCCFuncCall@2@AEBVX86Mem@2@AEBUFuncSignature@2@@Z")]
                internal static extern global::System.IntPtr Call_1(global::System.IntPtr instance, global::System.IntPtr dst, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?call@X86Compiler@asmjit@@QEAAPEAVCCFuncCall@2@AEBVLabel@2@AEBUFuncSignature@2@@Z")]
                internal static extern global::System.IntPtr Call_2(global::System.IntPtr instance, global::System.IntPtr label, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?call@X86Compiler@asmjit@@QEAAPEAVCCFuncCall@2@AEBVImm@2@AEBUFuncSignature@2@@Z")]
                internal static extern global::System.IntPtr Call_3(global::System.IntPtr instance, global::System.IntPtr dst, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?call@X86Compiler@asmjit@@QEAAPEAVCCFuncCall@2@_KAEBUFuncSignature@2@@Z")]
                internal static extern global::System.IntPtr Call(global::System.IntPtr instance, ulong dst, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ret@X86Compiler@asmjit@@QEAAPEAVCCFuncRet@2@XZ")]
                internal static extern global::System.IntPtr Ret(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ret@X86Compiler@asmjit@@QEAAPEAVCCFuncRet@2@AEBVX86Gp@2@@Z")]
                internal static extern global::System.IntPtr Ret(global::System.IntPtr instance, global::System.IntPtr o0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ret@X86Compiler@asmjit@@QEAAPEAVCCFuncRet@2@AEBVX86Gp@2@0@Z")]
                internal static extern global::System.IntPtr Ret(global::System.IntPtr instance, global::System.IntPtr o0, global::System.IntPtr o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ret@X86Compiler@asmjit@@QEAAPEAVCCFuncRet@2@AEBVX86Xmm@2@@Z")]
                internal static extern global::System.IntPtr Ret_1(global::System.IntPtr instance, global::System.IntPtr o0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ret@X86Compiler@asmjit@@QEAAPEAVCCFuncRet@2@AEBVX86Xmm@2@0@Z")]
                internal static extern global::System.IntPtr Ret_1(global::System.IntPtr instance, global::System.IntPtr o0, global::System.IntPtr o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?asEmitter@X86Compiler@asmjit@@QEAAPEAVX86Emitter@2@XZ")]
                internal static extern global::System.IntPtr AsEmitter(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?unfollow@X86Compiler@asmjit@@QEAAAEAV12@XZ")]
                internal static extern global::System.IntPtr Unfollow(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Compiler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Compiler(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Compiler __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Compiler.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Compiler(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Compiler.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Compiler.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.X86Compiler.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private X86Compiler(global::GraphEngine.Jit.Native.Asmjit.X86Compiler.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Compiler(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a `X86Compiler` instance.</summary>
            public X86Compiler(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Compiler.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.X86Compiler");
            }

            /// <summary>Implicit cast to `X86Emitter`.</summary>
            public static implicit operator global::GraphEngine.Jit.Native.Asmjit.X86Emitter(global::GraphEngine.Jit.Native.Asmjit.X86Compiler __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var __ret = __Internal.OperatorConversion(__arg0);
                global::GraphEngine.Jit.Native.Asmjit.X86Emitter __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.X86Emitter.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) global::GraphEngine.Jit.Native.Asmjit.X86Emitter.NativeToManagedMap[__ret];
                else global::GraphEngine.Jit.Native.Asmjit.X86Emitter.NativeToManagedMap[__ret] = __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) global::GraphEngine.Jit.Native.Asmjit.X86Emitter.__CreateInstance(__ret);
                return __result0;
            }

            public override uint OnAttach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                return base.OnAttach(code);
            }

            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___EmitDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = ___EmitDelegate((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4);
                return __ret;
            }

            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, global::GraphEngine.Jit.Native.Asmjit.Operand_ o5)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___Emit_1Delegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                if (ReferenceEquals(o5, null))
                    throw new global::System.ArgumentNullException("o5", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = o5.__Instance;
                var __ret = ___Emit_1Delegate((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                return __ret;
            }

            public override uint Finalize()
            {
                return base.Finalize();
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Reg NewReg(uint typeId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal();
                __Internal.NewReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Reg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Reg NewReg(uint typeId, string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal();
                __Internal.NewReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId, nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Reg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpReg(uint typeId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpReg(uint typeId, string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId, nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Mm NewMmReg(uint typeId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal();
                __Internal.NewMmReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Mm NewMmReg(uint typeId, string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal();
                __Internal.NewMmReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId, nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKReg(uint typeId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId);
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKReg(uint typeId, string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId, nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmReg(uint typeId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmReg(uint typeId, string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId, nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm NewYmmReg(uint typeId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.NewYmmReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm NewYmmReg(uint typeId, string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.NewYmmReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId, nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm NewZmmReg(uint typeId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.NewZmmReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm NewZmmReg(uint typeId, string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.NewZmmReg((__Instance + __PointerAdjustment), new IntPtr(&__ret), typeId, nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewI8()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewI8((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewI8(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewI8((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewU8()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewU8((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewU8(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewU8((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewI16()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewI16((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewI16(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewI16((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewU16()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewU16((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewU16(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewU16((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewI32()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewI32((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewI32(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewI32((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewU32()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewU32((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewU32(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewU32((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewI64()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewI64((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewI64(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewI64((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewU64()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewU64((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewU64(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewU64((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewInt8()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewInt8((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewInt8(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewInt8((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUInt8()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUInt8((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUInt8(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUInt8((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewInt16()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewInt16((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewInt16(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewInt16((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUInt16()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUInt16((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUInt16(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUInt16((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewInt32()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewInt32((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewInt32(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewInt32((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUInt32()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUInt32((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUInt32(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUInt32((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewInt64()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewInt64((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewInt64(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewInt64((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUInt64()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUInt64((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUInt64(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUInt64((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewIntPtr()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewIntPtr((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewIntPtr(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewIntPtr((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUIntPtr()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUIntPtr((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewUIntPtr(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewUIntPtr((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpb()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpb((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpb(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpb((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpw()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpw((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpw(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpw((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpd()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpd((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpd(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpd((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpq()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpq((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpq(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpq((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpz()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpz((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp NewGpz(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.NewGpz((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKb()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKb((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKb(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKb((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKw()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKw((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKw(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKw((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKd()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKd((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKd(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKd((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKq()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKq((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg NewKq(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.NewKq((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Mm NewMm()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal();
                __Internal.NewMm((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Mm NewMm(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal();
                __Internal.NewMm((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmm()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmm((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmm(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmm((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmSs()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmSs((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmSs(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmSs((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmSd()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmSd((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmSd(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmSd((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmPs()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmPs((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmPs(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmPs((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmPd()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmPd((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm NewXmmPd(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.NewXmmPd((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm NewYmm()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.NewYmm((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm NewYmm(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.NewYmm((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm NewYmmPs()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.NewYmmPs((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm NewYmmPs(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.NewYmmPs((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm NewYmmPd()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.NewYmmPd((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm NewYmmPd(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.NewYmmPd((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm NewZmm()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.NewZmm((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm NewZmm(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.NewZmm((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm NewZmmPs()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.NewZmmPs((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm NewZmmPs(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.NewZmmPs((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm NewZmmPd()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.NewZmmPd((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm NewZmmPd(string nameFmt)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.NewZmmPd((__Instance + __PointerAdjustment), new IntPtr(&__ret), nameFmt);
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            /// <summary>Create a new memory chunk allocated on the current function's stack.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewStack(uint size, uint alignment, string name)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewStack((__Instance + __PointerAdjustment), new IntPtr(&__ret), size, alignment, name);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put data to a constant-pool and get a memory reference to it.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewConst(uint scope, global::System.IntPtr data, ulong size)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, data, size);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a BYTE `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewByteConst(uint scope, byte val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewByteConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a WORD `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewWordConst(uint scope, ushort val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewWordConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a DWORD `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewDWordConst(uint scope, uint val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewDWordConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a QWORD `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewQWordConst(uint scope, ulong val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewQWordConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a WORD `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewInt16Const(uint scope, short val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewInt16Const((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a WORD `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewUInt16Const(uint scope, ushort val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewUInt16Const((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a DWORD `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewInt32Const(uint scope, int val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewInt32Const((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a DWORD `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewUInt32Const(uint scope, uint val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewUInt32Const((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a QWORD `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewInt64Const(uint scope, long val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewInt64Const((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a QWORD `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewUInt64Const(uint scope, ulong val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewUInt64Const((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a SP-FP `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewFloatConst(uint scope, float val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewFloatConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a DP-FP `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewDoubleConst(uint scope, double val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewDoubleConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, val);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a MMX `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewMmConst(uint scope, global::GraphEngine.Jit.Native.Asmjit.Data64 val)
            {
                var ____arg1 = val.__Instance;
                var __arg1 = new global::System.IntPtr(&____arg1);
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewMmConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, __arg1);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a XMM `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewXmmConst(uint scope, global::GraphEngine.Jit.Native.Asmjit.Data128 val)
            {
                var ____arg1 = val.__Instance;
                var __arg1 = new global::System.IntPtr(&____arg1);
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewXmmConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, __arg1);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Put a YMM `val` to a constant-pool.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem NewYmmConst(uint scope, global::GraphEngine.Jit.Native.Asmjit.Data256 val)
            {
                var ____arg1 = val.__Instance;
                var __arg1 = new global::System.IntPtr(&____arg1);
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.NewYmmConst((__Instance + __PointerAdjustment), new IntPtr(&__ret), scope, __arg1);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Tell the compiler that the destination variable will be overwritten.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Compiler Overwrite()
            {
                var __ret = __Internal.Overwrite((__Instance + __PointerAdjustment));
                global::GraphEngine.Jit.Native.Asmjit.X86Compiler __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.X86Compiler.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) global::GraphEngine.Jit.Native.Asmjit.X86Compiler.NativeToManagedMap[__ret];
                else global::GraphEngine.Jit.Native.Asmjit.X86Compiler.NativeToManagedMap[__ret] = __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) global::GraphEngine.Jit.Native.Asmjit.X86Compiler.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Call a function.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFuncCall Call(global::GraphEngine.Jit.Native.Asmjit.X86Gp dst, global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(dst, null))
                    throw new global::System.ArgumentNullException("dst", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = dst.__Instance;
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = sign.__Instance;
                var __ret = __Internal.Call((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall) global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__CreateInstance(__ret);
                return __result0;
            }


            public global::GraphEngine.Jit.Native.Asmjit.CCFuncCall Call(global::GraphEngine.Jit.Native.Asmjit.X86Mem dst, global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(dst, null))
                    throw new global::System.ArgumentNullException("dst", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = dst.__Instance;
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = sign.__Instance;
                var __ret = __Internal.Call_1((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall) global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__CreateInstance(__ret);
                return __result0;
            }


            public global::GraphEngine.Jit.Native.Asmjit.CCFuncCall Call(global::GraphEngine.Jit.Native.Asmjit.Label label, global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = sign.__Instance;
                var __ret = __Internal.Call_2((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall) global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__CreateInstance(__ret);
                return __result0;
            }


            public global::GraphEngine.Jit.Native.Asmjit.CCFuncCall Call(global::GraphEngine.Jit.Native.Asmjit.Imm dst, global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(dst, null))
                    throw new global::System.ArgumentNullException("dst", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = dst.__Instance;
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = sign.__Instance;
                var __ret = __Internal.Call_3((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall) global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__CreateInstance(__ret);
                return __result0;
            }


            public global::GraphEngine.Jit.Native.Asmjit.CCFuncCall Call(ulong dst, global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = sign.__Instance;
                var __ret = __Internal.Call((__Instance + __PointerAdjustment), dst, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall) global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Return.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFuncRet Ret()
            {
                var __ret = __Internal.Ret((__Instance + __PointerAdjustment));
                global::GraphEngine.Jit.Native.Asmjit.CCFuncRet __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet) global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__CreateInstance(__ret);
                return __result0;
            }


            public global::GraphEngine.Jit.Native.Asmjit.CCFuncRet Ret(global::GraphEngine.Jit.Native.Asmjit.X86Gp o0)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = o0.__Instance;
                var __ret = __Internal.Ret((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncRet __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet) global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__CreateInstance(__ret);
                return __result0;
            }


            public global::GraphEngine.Jit.Native.Asmjit.CCFuncRet Ret(global::GraphEngine.Jit.Native.Asmjit.X86Gp o0, global::GraphEngine.Jit.Native.Asmjit.X86Gp o1)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o1.__Instance;
                var __ret = __Internal.Ret((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncRet __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet) global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__CreateInstance(__ret);
                return __result0;
            }


            public global::GraphEngine.Jit.Native.Asmjit.CCFuncRet Ret(global::GraphEngine.Jit.Native.Asmjit.X86Xmm o0)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = o0.__Instance;
                var __ret = __Internal.Ret_1((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncRet __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet) global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__CreateInstance(__ret);
                return __result0;
            }


            public global::GraphEngine.Jit.Native.Asmjit.CCFuncRet Ret(global::GraphEngine.Jit.Native.Asmjit.X86Xmm o0, global::GraphEngine.Jit.Native.Asmjit.X86Xmm o1)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o1.__Instance;
                var __ret = __Internal.Ret_1((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncRet __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet) global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Explicit cast to `X86Emitter`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Emitter AsEmitter
            {
                get
                {
                    var __ret = __Internal.AsEmitter((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.X86Emitter __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.X86Emitter.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) global::GraphEngine.Jit.Native.Asmjit.X86Emitter.NativeToManagedMap[__ret];
                    else global::GraphEngine.Jit.Native.Asmjit.X86Emitter.NativeToManagedMap[__ret] = __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) global::GraphEngine.Jit.Native.Asmjit.X86Emitter.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Force the compiler to not follow the conditional or unconditional jump.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Compiler Unfollow
            {
                get
                {
                    var __ret = __Internal.Unfollow((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.X86Compiler __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.X86Compiler.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) global::GraphEngine.Jit.Native.Asmjit.X86Compiler.NativeToManagedMap[__ret];
                    else global::GraphEngine.Jit.Native.Asmjit.X86Compiler.NativeToManagedMap[__ret] = __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) global::GraphEngine.Jit.Native.Asmjit.X86Compiler.__CreateInstance(__ret);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ASMJIT_API ~X86Compiler() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error onAttach(CodeHolder* code) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnAttachDelegateInstance;

            private static uint _OnAttachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnAttach(__result0);
                return __ret;
            }

            // Error onDetach(CodeHolder* code) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnDetachDelegateInstance;

            private static uint _OnDetachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnDetach(__result0);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3, const Operand_& o4, const Operand_& o5) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _Emit_1DelegateInstance;

            private static uint _Emit_1DelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, global::System.IntPtr o5)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result5;
                if (o4 == IntPtr.Zero) __result5 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o4))
                    __result5 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o4];
                else __result5 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o4);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result6;
                if (o5 == IntPtr.Zero) __result6 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o5))
                    __result6 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o5];
                else __result6 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o5);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4, __result5, __result6);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr _EmitDelegateInstance;

            private static uint _EmitDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4);
                return __ret;
            }

            // Error _emitOpArray(uint32_t instId, const Operand_* opArray, size_t opCount)
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_ulong _EmitOpArrayDelegateInstance;

            private static uint _EmitOpArrayDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr opArray, ulong opCount)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (opArray == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(opArray))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[opArray];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(opArray);
                var __ret = __target.EmitOpArray(instId, __result1, opCount);
                return __ret;
            }

            // Label newLabel() override
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr _NewLabelDelegateInstance;

            private static void _NewLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewLabel();
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Label newNamedLabel(const char* name, size_t nameLength = Globals::kInvalidIndex, uint32_t type = Label::kTypeGlobal, uint32_t parentId = kInvalidValue) override
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint _NewNamedLabelDelegateInstance;

            private static void _NewNamedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string name, ulong nameLength, uint type, uint parentId)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewNamedLabel(name, nameLength, type, parentId);
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Error bind(const Label& label) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _BindDelegateInstance;

            private static uint _BindDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.Bind(__result0);
                return __ret;
            }

            // Error align(uint32_t mode, uint32_t alignment) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint _AlignDelegateInstance;

            private static uint _AlignDelegateHook(global::System.IntPtr instance, uint mode, uint alignment)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Align(mode, alignment);
                return __ret;
            }

            // Error embed(const void* data, uint32_t size) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint _EmbedDelegateInstance;

            private static uint _EmbedDelegateHook(global::System.IntPtr instance, global::System.IntPtr data, uint size)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Embed(data, size);
                return __ret;
            }

            // Error embedLabel(const Label& label) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _EmbedLabelDelegateInstance;

            private static uint _EmbedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.EmbedLabel(__result0);
                return __ret;
            }

            // Error embedConstPool(const Label& label, const ConstPool& pool) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr _EmbedConstPoolDelegateInstance;

            private static uint _EmbedConstPoolDelegateHook(global::System.IntPtr instance, global::System.IntPtr label, global::System.IntPtr pool)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                global::GraphEngine.Jit.Native.Asmjit.ConstPool __result1;
                if (pool == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap.ContainsKey(pool))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.ConstPool) global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap[pool];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.ConstPool.__CreateInstance(pool);
                var __ret = __target.EmbedConstPool(__result0, __result1);
                return __ret;
            }

            // Error comment(const char* s, size_t len = Globals::kInvalidIndex) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong _CommentDelegateInstance;

            private static uint _CommentDelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s, ulong len)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Comment(s, len);
                return __ret;
            }

            // Error finalize() override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr _FinalizeDelegateInstance;

            private static uint _FinalizeDelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Finalize();
                return __ret;
            }

            // Error serialize(CodeEmitter* dst)
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _SerializeDelegateInstance;

            private static uint _SerializeDelegateHook(global::System.IntPtr instance, global::System.IntPtr dst)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Compiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __result0;
                if (dst == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.NativeToManagedMap.ContainsKey(dst))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.NativeToManagedMap[dst];
                else __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__CreateInstance(dst, skipVTables: true);
                var __ret = __target.Serialize(__result0);
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[16];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _OnAttachDelegateInstance += _OnAttachDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnAttachDelegateInstance).ToPointer();
                    _OnDetachDelegateInstance += _OnDetachDelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnDetachDelegateInstance).ToPointer();
                    _Emit_1DelegateInstance += _Emit_1DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_Emit_1DelegateInstance).ToPointer();
                    _EmitDelegateInstance += _EmitDelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_EmitDelegateInstance).ToPointer();
                    _EmitOpArrayDelegateInstance += _EmitOpArrayDelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_EmitOpArrayDelegateInstance).ToPointer();
                    _NewLabelDelegateInstance += _NewLabelDelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewLabelDelegateInstance).ToPointer();
                    _NewNamedLabelDelegateInstance += _NewNamedLabelDelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewNamedLabelDelegateInstance).ToPointer();
                    _BindDelegateInstance += _BindDelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_BindDelegateInstance).ToPointer();
                    _AlignDelegateInstance += _AlignDelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_AlignDelegateInstance).ToPointer();
                    _EmbedDelegateInstance += _EmbedDelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_EmbedDelegateInstance).ToPointer();
                    _EmbedLabelDelegateInstance += _EmbedLabelDelegateHook;
                    _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_EmbedLabelDelegateInstance).ToPointer();
                    _EmbedConstPoolDelegateInstance += _EmbedConstPoolDelegateHook;
                    _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_EmbedConstPoolDelegateInstance).ToPointer();
                    _CommentDelegateInstance += _CommentDelegateHook;
                    _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_CommentDelegateInstance).ToPointer();
                    _FinalizeDelegateInstance += _FinalizeDelegateHook;
                    _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_FinalizeDelegateInstance).ToPointer();
                    _SerializeDelegateInstance += _SerializeDelegateHook;
                    _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_SerializeDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(16 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                        *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                        *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                        *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                        *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                        *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                        *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                        *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                        *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                        *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                        *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                        *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                        *(void**) (vfptr0 + 104) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 104);
                        *(void**) (vfptr0 + 112) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 112);
                        *(void**) (vfptr0 + 120) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 120);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(16 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                        *(void**) (vfptr0 + 16) = _Thunks[2];
                        *(void**) (vfptr0 + 24) = _Thunks[3];
                        *(void**) (vfptr0 + 32) = _Thunks[4];
                        *(void**) (vfptr0 + 40) = _Thunks[5];
                        *(void**) (vfptr0 + 48) = _Thunks[6];
                        *(void**) (vfptr0 + 56) = _Thunks[7];
                        *(void**) (vfptr0 + 64) = _Thunks[8];
                        *(void**) (vfptr0 + 72) = _Thunks[9];
                        *(void**) (vfptr0 + 80) = _Thunks[10];
                        *(void**) (vfptr0 + 88) = _Thunks[11];
                        *(void**) (vfptr0 + 96) = _Thunks[12];
                        *(void**) (vfptr0 + 104) = _Thunks[13];
                        *(void**) (vfptr0 + 112) = _Thunks[14];
                        *(void**) (vfptr0 + 120) = _Thunks[15];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }
    }

    namespace Asmjit
    {
        /// <summary>\{</summary>
        public enum KInvalidValue
        {
            kInvalidValue = -1
        }

        /// <summary>AsmJit error codes.</summary>
        public enum ErrorCode : uint
        {
            /// <summary>No error (success).</summary>
            /// <remarks>This is default state and state you want.</remarks>
            kErrorOk = 0,
            /// <summary>Heap memory allocation failed.</summary>
            kErrorNoHeapMemory = 1,
            /// <summary>Virtual memory allocation failed.</summary>
            kErrorNoVirtualMemory = 2,
            /// <summary>Invalid argument.</summary>
            kErrorInvalidArgument = 3,
            /// <summary>Invalid state.</summary>
            /// <remarks>
            /// <para>If this error is returned it means that either you are doing something</para>
            /// <para>wrong or AsmJit caught itself by doing something wrong. This error should</para>
            /// <para>not be underestimated.</para>
            /// </remarks>
            kErrorInvalidState = 4,
            /// <summary>Invalid or incompatible architecture.</summary>
            kErrorInvalidArch = 5,
            /// <summary>The object is not initialized.</summary>
            kErrorNotInitialized = 6,
            /// <summary>The object is already initialized.</summary>
            kErrorAlreadyInitialized = 7,
            /// <summary>Built-in feature was disabled at compile time and it's not available.</summary>
            kErrorFeatureNotEnabled = 8,
            /// <summary>CodeHolder can't have attached more than one</summary>
            kErrorSlotOccupied = 9,
            /// <summary>No code generated.</summary>
            /// <remarks>Returned by runtime if the</remarks>
            kErrorNoCodeGenerated = 10,
            /// <summary>Code generated is larger than allowed.</summary>
            kErrorCodeTooLarge = 11,
            /// <summary>Attempt to use uninitialized label.</summary>
            kErrorInvalidLabel = 12,
            /// <summary>
            /// <para>Label index overflow - a single `Assembler` instance can hold more than</para>
            /// <para>2 billion labels (2147483391 to be exact). If there is an attempt to</para>
            /// <para>create more labels this error is returned.</para>
            /// </summary>
            kErrorLabelIndexOverflow = 13,
            /// <summary>Label is already bound.</summary>
            kErrorLabelAlreadyBound = 14,
            /// <summary>Label is already defined (named labels).</summary>
            kErrorLabelAlreadyDefined = 15,
            /// <summary>Label name is too long.</summary>
            kErrorLabelNameTooLong = 16,
            /// <summary>Label must always be local if it's anonymous (without a name).</summary>
            kErrorInvalidLabelName = 17,
            /// <summary>Parent id passed to `CodeHolder::newNamedLabelId()` was invalid.</summary>
            kErrorInvalidParentLabel = 18,
            /// <summary>Parent id specified for a non-local (global) label.</summary>
            kErrorNonLocalLabelCantHaveParent = 19,
            /// <summary>Relocation index overflow.</summary>
            kErrorRelocIndexOverflow = 20,
            /// <summary>Invalid relocation entry.</summary>
            kErrorInvalidRelocEntry = 21,
            /// <summary>Invalid instruction.</summary>
            kErrorInvalidInstruction = 22,
            /// <summary>Invalid register type.</summary>
            kErrorInvalidRegType = 23,
            /// <summary>Invalid register kind.</summary>
            kErrorInvalidRegKind = 24,
            /// <summary>Invalid register's physical id.</summary>
            kErrorInvalidPhysId = 25,
            /// <summary>Invalid register's virtual id.</summary>
            kErrorInvalidVirtId = 26,
            /// <summary>Invalid prefix combination.</summary>
            kErrorInvalidPrefixCombination = 27,
            /// <summary>Invalid LOCK prefix.</summary>
            kErrorInvalidLockPrefix = 28,
            /// <summary>Invalid XACQUIRE prefix.</summary>
            kErrorInvalidXAcquirePrefix = 29,
            /// <summary>Invalid XACQUIRE prefix.</summary>
            kErrorInvalidXReleasePrefix = 30,
            /// <summary>Invalid REP prefix.</summary>
            kErrorInvalidRepPrefix = 31,
            /// <summary>Invalid REX prefix.</summary>
            kErrorInvalidRexPrefix = 32,
            /// <summary>Invalid mask register (not 'k').</summary>
            kErrorInvalidKMaskReg = 33,
            /// <summary>Invalid {k} use (not supported by the instruction).</summary>
            kErrorInvalidKMaskUse = 34,
            /// <summary>Invalid {k}{z} use (not supported by the instruction).</summary>
            kErrorInvalidKZeroUse = 35,
            /// <summary>Invalid broadcast - Currently only related to invalid use of AVX-512 {1tox}.</summary>
            kErrorInvalidBroadcast = 36,
            /// <summary>Invalid 'embedded-rounding' {er} or 'suppress-all-exceptions' {sae} (AVX-512).</summary>
            kErrorInvalidEROrSAE = 37,
            /// <summary>Invalid address used (not encodable).</summary>
            kErrorInvalidAddress = 38,
            /// <summary>Invalid index register used in memory address (not encodable).</summary>
            kErrorInvalidAddressIndex = 39,
            /// <summary>Invalid address scale (not encodable).</summary>
            kErrorInvalidAddressScale = 40,
            /// <summary>Invalid use of 64-bit address.</summary>
            kErrorInvalidAddress64Bit = 41,
            /// <summary>Invalid displacement (not encodable).</summary>
            kErrorInvalidDisplacement = 42,
            /// <summary>Invalid segment (X86).</summary>
            kErrorInvalidSegment = 43,
            /// <summary>Invalid immediate (out of bounds on X86 and invalid pattern on ARM).</summary>
            kErrorInvalidImmediate = 44,
            /// <summary>Invalid operand size.</summary>
            kErrorInvalidOperandSize = 45,
            /// <summary>Ambiguous operand size (memory has zero size while it's required to determine the operation type.</summary>
            kErrorAmbiguousOperandSize = 46,
            /// <summary>Mismatching operand size (size of multiple operands doesn't match the operation size).</summary>
            kErrorOperandSizeMismatch = 47,
            /// <summary>Invalid TypeId.</summary>
            kErrorInvalidTypeId = 48,
            /// <summary>Invalid use of a 8-bit GPB-HIGH register.</summary>
            kErrorInvalidUseOfGpbHi = 49,
            /// <summary>Invalid use of a 64-bit GPQ register in 32-bit mode.</summary>
            kErrorInvalidUseOfGpq = 50,
            /// <summary>Invalid use of an 80-bit float (TypeId::kF80).</summary>
            kErrorInvalidUseOfF80 = 51,
            /// <summary>Some registers in the instruction muse be consecutive (some ARM and AVX512 neural-net instructions).</summary>
            kErrorNotConsecutiveRegs = 52,
            /// <summary>AsmJit requires a physical register, but no one is available.</summary>
            kErrorNoMorePhysRegs = 53,
            /// <summary>A variable has been assigned more than once to a function argument (CodeCompiler).</summary>
            kErrorOverlappedRegs = 54,
            /// <summary>Invalid register to hold stack arguments offset.</summary>
            kErrorOverlappingStackRegWithRegArg = 55,
            /// <summary>Count of AsmJit error codes.</summary>
            kErrorCount = 56
        }

        /// <summary>AsmJit error type (uint32_t).</summary>
        public unsafe partial class _Init : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0_Init@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit._Init> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit._Init>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit._Init __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit._Init(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit._Init __CreateInstance(global::GraphEngine.Jit.Native.Asmjit._Init.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit._Init(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit._Init.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit._Init.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit._Init.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private _Init(global::GraphEngine.Jit.Native.Asmjit._Init.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected _Init(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public _Init()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit._Init.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public _Init(global::GraphEngine.Jit.Native.Asmjit._Init _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit._Init.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit._Init.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit._Init.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit._Init __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class _NoInit : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0_NoInit@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit._NoInit> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit._NoInit>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit._NoInit __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit._NoInit(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit._NoInit __CreateInstance(global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit._NoInit(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private _NoInit(global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected _NoInit(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public _NoInit()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public _NoInit(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit._NoInit __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class globals
        {
            public partial struct __Internal
            {
            }

            public static global::GraphEngine.Jit.Native.Asmjit._Init Init
            {
                get
                {
                    var __ptr = (global::GraphEngine.Jit.Native.Asmjit._Init.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?Init@asmjit@@3U_Init@1@B");
                    return global::GraphEngine.Jit.Native.Asmjit._Init.__CreateInstance(*__ptr);
                }
            }

            public static global::GraphEngine.Jit.Native.Asmjit._NoInit NoInit
            {
                get
                {
                    var __ptr = (global::GraphEngine.Jit.Native.Asmjit._NoInit.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?NoInit@asmjit@@3U_NoInit@1@B");
                    return global::GraphEngine.Jit.Native.Asmjit._NoInit.__CreateInstance(*__ptr);
                }
            }
        }

        namespace Globals
        {
            /// <summary>Global definitions.</summary>
            public enum Defs : uint
            {
                /// <summary>Invalid register id.</summary>
                kInvalidRegId = 0xff,
                /// <summary>Host memory allocator overhead.</summary>
                kAllocOverhead = 32,
                /// <summary>Aggressive growing strategy threshold.</summary>
                kAllocThreshold = 8388608
            }

            [Flags]
            public enum Limits : uint
            {
                /// <summary>
                /// <para>Count of register kinds that are important to Function API and CodeCompiler.</para>
                /// <para>The target architecture can define more register kinds for special registers,</para>
                /// <para>but these will never map to virtual registers and will never be used to pass</para>
                /// <para>and return function arguments and function return values, respectively.</para>
                /// </summary>
                kMaxVRegKinds = 4,
                /// <summary>
                /// <para>Maximum number of physical registers of all kinds of all supported</para>
                /// <para>architectures. This is only important for</para>
                /// </summary>
                /// <remarks>NOTE: The distribution of these registers is architecture specific.</remarks>
                kMaxPhysRegs = 64,
                /// <summary>Maximum alignment.</summary>
                kMaxAlignment = 64,
                /// <summary>
                /// <para>Maximum label or symbol length in bytes (take into consideration that a</para>
                /// <para>single UTF-8 character can take more than single byte to encode it).</para>
                /// </summary>
                kMaxLabelLength = 2048
            }

            public unsafe partial class globals
            {
                public partial struct __Internal
                {
                }

                /// <summary>Invalid index</summary>
                /// <remarks>
                /// <para>Invalid index is the last possible index that is never used in practice. In</para>
                /// <para>AsmJit it is used exclusively with strings to indicate the the length of the</para>
                /// <para>string is not known and has to be determined.</para>
                /// </remarks>
                public static ulong KInvalidIndex
                {
                    get
                    {
                        var __ptr = (ulong*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?kInvalidIndex@Globals@asmjit@@3_KB");
                        return *__ptr;
                    }
                }

                /// <summary>Invalid base address.</summary>
                public static ulong KNoBaseAddress
                {
                    get
                    {
                        var __ptr = (ulong*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?kNoBaseAddress@Globals@asmjit@@3_KB");
                        return *__ptr;
                    }
                }
            }
        }

        namespace Internal
        {
            public unsafe partial class globals
            {
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?allocMemory@Internal@asmjit@@YAPEAX_K@Z")]
                    internal static extern global::System.IntPtr AllocMemory(ulong size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?reallocMemory@Internal@asmjit@@YAPEAXPEAX_K@Z")]
                    internal static extern global::System.IntPtr ReallocMemory(global::System.IntPtr p, ulong size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?releaseMemory@Internal@asmjit@@YAXPEAX@Z")]
                    internal static extern void ReleaseMemory(global::System.IntPtr p);
                }

                public static global::System.IntPtr AllocMemory(ulong size)
                {
                    var __ret = __Internal.AllocMemory(size);
                    return __ret;
                }

                public static global::System.IntPtr ReallocMemory(global::System.IntPtr p, ulong size)
                {
                    var __ret = __Internal.ReallocMemory(p, size);
                    return __ret;
                }

                public static void ReleaseMemory(global::System.IntPtr p)
                {
                    __Internal.ReleaseMemory(p);
                }
            }
        }

        namespace DebugUtils
        {
            public unsafe partial class globals
            {
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?errored@DebugUtils@asmjit@@YAII@Z")]
                    internal static extern uint Errored(uint err);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?errorAsString@DebugUtils@asmjit@@YAPEBDI@Z")]
                    internal static extern global::System.IntPtr ErrorAsString(uint err);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?debugOutput@DebugUtils@asmjit@@YAXPEBD@Z")]
                    internal static extern void DebugOutput([MarshalAs(UnmanagedType.LPStr)] string str);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?assertionFailed@DebugUtils@asmjit@@YAXPEBDH0@Z")]
                    internal static extern void AssertionFailed([MarshalAs(UnmanagedType.LPStr)] string file, int line, [MarshalAs(UnmanagedType.LPStr)] string msg);
                }

                /// <summary>Returns the error `err` passed.</summary>
                /// <remarks>
                /// <para>Provided for debugging purposes. Putting a breakpoint inside `errored` can</para>
                /// <para>help with tracing the origin of any error reported / returned by AsmJit.</para>
                /// </remarks>
                public static uint Errored(uint err)
                {
                    var __ret = __Internal.Errored(err);
                    return __ret;
                }

                /// <summary>Get a printable version of `asmjit::Error` code.</summary>
                public static string ErrorAsString(uint err)
                {
                    var __ret = __Internal.ErrorAsString(err);
                    return Marshal.PtrToStringAnsi(__ret);
                }

                /// <summary>Called to output debugging message(s).</summary>
                public static void DebugOutput(string str)
                {
                    __Internal.DebugOutput(str);
                }

                /// <summary>Called on assertion failure.</summary>
                /// <param name="file">Source file name where it happened.</param>
                /// <param name="line">Line in the source file.</param>
                /// <param name="msg">Message to display.</param>
                /// <remarks>
                /// <para>If you have problems with assertions put a breakpoint at assertionFailed()</para>
                /// <para>function (asmjit/base/globals.cpp) and check the call stack to locate the</para>
                /// <para>failing code.</para>
                /// </remarks>
                public static void AssertionFailed(string file, int line, string msg)
                {
                    __Internal.AssertionFailed(file, line, msg);
                }
            }
        }
    }

    namespace Asmjit
    {
        public unsafe partial struct UInt64T
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal fixed sbyte i8[8];

                [FieldOffset(0)]
                internal fixed byte u8[8];

                [FieldOffset(0)]
                internal fixed short i16[4];

                [FieldOffset(0)]
                internal fixed ushort u16[4];

                [FieldOffset(0)]
                internal fixed int i32[2];

                [FieldOffset(0)]
                internal fixed uint u32[2];

                [FieldOffset(0)]
                internal long i64;

                [FieldOffset(0)]
                internal ulong u64;

                [FieldOffset(0)]
                internal fixed float f32[2];

                [FieldOffset(0)]
                internal double f64;

                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.UInt64T._.__Internal _;

                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.UInt64T._.__Internal _1;

                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.UInt64T._.__Internal _2;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0UInt64@asmjit@@QEAA@AEBT01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromUInt64@UInt64@asmjit@@QEAA?AT12@_K@Z")]
                internal static extern void FromUInt64(global::System.IntPtr instance, global::System.IntPtr @return, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromUInt64@UInt64@asmjit@@QEAA?AT12@AEBT12@@Z")]
                internal static extern void FromUInt64(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@UInt64@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setUInt64@UInt64@asmjit@@QEAAAEAT12@_K@Z")]
                internal static extern global::System.IntPtr SetUInt64(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setUInt64@UInt64@asmjit@@QEAAAEAT12@AEBT12@@Z")]
                internal static extern global::System.IntPtr SetUInt64(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setPacked_2x32@UInt64@asmjit@@QEAAAEAT12@II@Z")]
                internal static extern global::System.IntPtr SetPacked2x32(global::System.IntPtr instance, uint u0, uint u1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?add@UInt64@asmjit@@QEAAAEAT12@_K@Z")]
                internal static extern global::System.IntPtr Add(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?add@UInt64@asmjit@@QEAAAEAT12@AEBT12@@Z")]
                internal static extern global::System.IntPtr Add(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?sub@UInt64@asmjit@@QEAAAEAT12@_K@Z")]
                internal static extern global::System.IntPtr Sub(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?sub@UInt64@asmjit@@QEAAAEAT12@AEBT12@@Z")]
                internal static extern global::System.IntPtr Sub(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?and_@UInt64@asmjit@@QEAAAEAT12@_K@Z")]
                internal static extern global::System.IntPtr And(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?and_@UInt64@asmjit@@QEAAAEAT12@AEBT12@@Z")]
                internal static extern global::System.IntPtr And(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNot@UInt64@asmjit@@QEAAAEAT12@_K@Z")]
                internal static extern global::System.IntPtr AndNot(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNot@UInt64@asmjit@@QEAAAEAT12@AEBT12@@Z")]
                internal static extern global::System.IntPtr AndNot(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?or_@UInt64@asmjit@@QEAAAEAT12@_K@Z")]
                internal static extern global::System.IntPtr Or(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?or_@UInt64@asmjit@@QEAAAEAT12@AEBT12@@Z")]
                internal static extern global::System.IntPtr Or(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?xor_@UInt64@asmjit@@QEAAAEAT12@_K@Z")]
                internal static extern global::System.IntPtr Xor(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?xor_@UInt64@asmjit@@QEAAAEAT12@AEBT12@@Z")]
                internal static extern global::System.IntPtr Xor(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?eq@UInt64@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Eq(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?eq@UInt64@asmjit@@QEBA_NAEBT12@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Eq(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8UInt64@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8UInt64@asmjit@@QEBA_NAEBT01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9UInt64@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9UInt64@asmjit@@QEBA_NAEBT01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??MUInt64@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLess(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??MUInt64@asmjit@@QEBA_NAEBT01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??NUInt64@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??NUInt64@asmjit@@QEBA_NAEBT01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??OUInt64@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreater(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??OUInt64@asmjit@@QEBA_NAEBT01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??PUInt64@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??PUInt64@asmjit@@QEBA_NAEBT01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUInt64@UInt64@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetUInt64(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isZero@UInt64@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsZero(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isNonZero@UInt64@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsNonZero(global::System.IntPtr instance);
            }

            public unsafe partial class _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal float f32Lo;

                    [FieldOffset(4)]
                    internal float f32Hi;
                }
            }

            private UInt64T.__Internal __instance;
            internal UInt64T.__Internal __Instance { get { return __instance; } }

            internal static global::GraphEngine.Jit.Native.Asmjit.UInt64T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.UInt64T(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.UInt64T __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.UInt64T.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.UInt64T(native, skipVTables);
            }

            private UInt64T(global::GraphEngine.Jit.Native.Asmjit.UInt64T.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private UInt64T(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::GraphEngine.Jit.Native.Asmjit.UInt64T.__Internal*) native;
            }

            public UInt64T(global::GraphEngine.Jit.Native.Asmjit.UInt64T _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T FromUInt64(ulong val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.UInt64T.__Internal();
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.FromUInt64(new global::System.IntPtr(__instancePtr), new IntPtr(&__ret), val);
                    return global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T FromUInt64(global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = val.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.UInt64T.__Internal();
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.FromUInt64(new global::System.IntPtr(__instancePtr), new IntPtr(&__ret), __arg0);
                    return global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                }
            }

            public void Reset()
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.Reset(new global::System.IntPtr(__instancePtr));
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T SetUInt64(ulong val)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.SetUInt64(new global::System.IntPtr(__instancePtr), val);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T SetUInt64(global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = val.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.SetUInt64(new global::System.IntPtr(__instancePtr), __arg0);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T SetPacked2x32(uint u0, uint u1)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.SetPacked2x32(new global::System.IntPtr(__instancePtr), u0, u1);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T Add(ulong val)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Add(new global::System.IntPtr(__instancePtr), val);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T Add(global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = val.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Add(new global::System.IntPtr(__instancePtr), __arg0);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T Sub(ulong val)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Sub(new global::System.IntPtr(__instancePtr), val);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T Sub(global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = val.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Sub(new global::System.IntPtr(__instancePtr), __arg0);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T And(ulong val)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.And(new global::System.IntPtr(__instancePtr), val);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T And(global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = val.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.And(new global::System.IntPtr(__instancePtr), __arg0);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T AndNot(ulong val)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.AndNot(new global::System.IntPtr(__instancePtr), val);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T AndNot(global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = val.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.AndNot(new global::System.IntPtr(__instancePtr), __arg0);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T Or(ulong val)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Or(new global::System.IntPtr(__instancePtr), val);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T Or(global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = val.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Or(new global::System.IntPtr(__instancePtr), __arg0);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T Xor(ulong val)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Xor(new global::System.IntPtr(__instancePtr), val);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.UInt64T Xor(global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = val.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Xor(new global::System.IntPtr(__instancePtr), __arg0);
                    global::GraphEngine.Jit.Native.Asmjit.UInt64T __result0;
                    if (__ret == IntPtr.Zero) __result0 = new global::GraphEngine.Jit.Native.Asmjit.UInt64T();
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.UInt64T.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public bool Eq(ulong val)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Eq(new global::System.IntPtr(__instancePtr), val);
                    return __ret;
                }
            }

            public bool Eq(global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = val.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.Eq(new global::System.IntPtr(__instancePtr), __arg0);
                    return __ret;
                }
            }

            public static bool operator ==(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, ulong val)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool valNull = ReferenceEquals(val, null);
                if (__opNull || valNull)
                    return __opNull && valNull;
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorEqualEqual(new global::System.IntPtr(__instancePtr), val);
                return __ret;
            }

            public static bool operator ==(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool valNull = ReferenceEquals(val, null);
                if (__opNull || valNull)
                    return __opNull && valNull;
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var ____arg1 = val.__Instance;
                var __arg1 = new global::System.IntPtr(&____arg1);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorEqualEqual(new global::System.IntPtr(__instancePtr), __arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                if (!(obj is global::GraphEngine.Jit.Native.Asmjit.UInt64T)) return false;
                return this == (global::GraphEngine.Jit.Native.Asmjit.UInt64T) obj;
            }

            public override int GetHashCode()
            {
                return __Instance.GetHashCode();
            }

            public static bool operator !=(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, ulong val)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool valNull = ReferenceEquals(val, null);
                if (__opNull || valNull)
                    return !(__opNull && valNull);
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorExclaimEqual(new global::System.IntPtr(__instancePtr), val);
                return __ret;
            }

            public static bool operator !=(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool valNull = ReferenceEquals(val, null);
                if (__opNull || valNull)
                    return !(__opNull && valNull);
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var ____arg1 = val.__Instance;
                var __arg1 = new global::System.IntPtr(&____arg1);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorExclaimEqual(new global::System.IntPtr(__instancePtr), __arg1);
                return __ret;
            }

            public static bool operator <(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, ulong val)
            {
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorLess(new global::System.IntPtr(__instancePtr), val);
                return __ret;
            }

            public static bool operator <(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var ____arg1 = val.__Instance;
                var __arg1 = new global::System.IntPtr(&____arg1);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorLess(new global::System.IntPtr(__instancePtr), __arg1);
                return __ret;
            }

            public static bool operator <=(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, ulong val)
            {
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorLessEqual(new global::System.IntPtr(__instancePtr), val);
                return __ret;
            }

            public static bool operator <=(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var ____arg1 = val.__Instance;
                var __arg1 = new global::System.IntPtr(&____arg1);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorLessEqual(new global::System.IntPtr(__instancePtr), __arg1);
                return __ret;
            }

            public static bool operator >(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, ulong val)
            {
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorGreater(new global::System.IntPtr(__instancePtr), val);
                return __ret;
            }

            public static bool operator >(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var ____arg1 = val.__Instance;
                var __arg1 = new global::System.IntPtr(&____arg1);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorGreater(new global::System.IntPtr(__instancePtr), __arg1);
                return __ret;
            }

            public static bool operator >=(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, ulong val)
            {
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorGreaterEqual(new global::System.IntPtr(__instancePtr), val);
                return __ret;
            }

            public static bool operator >=(global::GraphEngine.Jit.Native.Asmjit.UInt64T __op, global::GraphEngine.Jit.Native.Asmjit.UInt64T val)
            {
                var ____arg0 = __op.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var ____arg1 = val.__Instance;
                var __arg1 = new global::System.IntPtr(&____arg1);
                var __instancePtr = &__op.__instance;
                var __ret = __Internal.OperatorGreaterEqual(new global::System.IntPtr(__instancePtr), __arg1);
                return __ret;
            }

            public ulong UInt64
            {
                get
                {
                    fixed (__Internal* __instancePtr = &__instance)
                    {
                        var __ret = __Internal.GetUInt64(new global::System.IntPtr(__instancePtr));
                        return __ret;
                    }
                }
            }

            public bool IsZero
            {
                get
                {
                    fixed (__Internal* __instancePtr = &__instance)
                    {
                        var __ret = __Internal.IsZero(new global::System.IntPtr(__instancePtr));
                        return __ret;
                    }
                }
            }

            public bool IsNonZero
            {
                get
                {
                    fixed (__Internal* __instancePtr = &__instance)
                    {
                        var __ret = __Internal.IsNonZero(new global::System.IntPtr(__instancePtr));
                        return __ret;
                    }
                }
            }
        }

        namespace Utils
        {

            public unsafe partial struct FloatBits
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal int i;

                    [FieldOffset(0)]
                    internal float f;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FloatBits@Utils@asmjit@@QEAA@AEBT012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                private FloatBits.__Internal __instance;
                internal FloatBits.__Internal __Instance { get { return __instance; } }

                internal static global::GraphEngine.Jit.Native.Asmjit.Utils.FloatBits __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Utils.FloatBits(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.Utils.FloatBits __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Utils.FloatBits.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Utils.FloatBits(native, skipVTables);
                }

                private FloatBits(global::GraphEngine.Jit.Native.Asmjit.Utils.FloatBits.__Internal native, bool skipVTables = false)
                    : this()
                {
                    __instance = native;
                }

                private FloatBits(void* native, bool skipVTables = false) : this()
                {
                    __instance = *(global::GraphEngine.Jit.Native.Asmjit.Utils.FloatBits.__Internal*) native;
                }

                public FloatBits(global::GraphEngine.Jit.Native.Asmjit.Utils.FloatBits _0)
                    : this()
                {
                    var ____arg0 = _0.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    fixed (__Internal* __instancePtr = &__instance)
                    {
                        __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                    }
                }
            }


            public unsafe partial struct DoubleBits
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal long i;

                    [FieldOffset(0)]
                    internal double d;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DoubleBits@Utils@asmjit@@QEAA@AEBT012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                private DoubleBits.__Internal __instance;
                internal DoubleBits.__Internal __Instance { get { return __instance; } }

                internal static global::GraphEngine.Jit.Native.Asmjit.Utils.DoubleBits __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Utils.DoubleBits(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.Utils.DoubleBits __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Utils.DoubleBits.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Utils.DoubleBits(native, skipVTables);
                }

                private DoubleBits(global::GraphEngine.Jit.Native.Asmjit.Utils.DoubleBits.__Internal native, bool skipVTables = false)
                    : this()
                {
                    __instance = native;
                }

                private DoubleBits(void* native, bool skipVTables = false) : this()
                {
                    __instance = *(global::GraphEngine.Jit.Native.Asmjit.Utils.DoubleBits.__Internal*) native;
                }

                public DoubleBits(global::GraphEngine.Jit.Native.Asmjit.Utils.DoubleBits _0)
                    : this()
                {
                    var ____arg0 = _0.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    fixed (__Internal* __instancePtr = &__instance)
                    {
                        __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                    }
                }
            }

            public unsafe partial class utils
            {
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?floatAsInt@Utils@asmjit@@YAHM@Z")]
                    internal static extern int FloatAsInt(float f);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?intAsFloat@Utils@asmjit@@YAMH@Z")]
                    internal static extern float IntAsFloat(int i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?doubleAsInt@Utils@asmjit@@YA_JN@Z")]
                    internal static extern long DoubleAsInt(double d);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?intAsDouble@Utils@asmjit@@YAN_J@Z")]
                    internal static extern double IntAsDouble(long i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?pack32_4x8@Utils@asmjit@@YAIIIII@Z")]
                    internal static extern uint Pack32_4x8(uint b0, uint b1, uint b2, uint b3);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?pack64_2x32@Utils@asmjit@@YA_KII@Z")]
                    internal static extern ulong Pack64_2x32(uint u0, uint u1);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byteShiftOfDWordStruct@Utils@asmjit@@YAII@Z")]
                    internal static extern uint ByteShiftOfDWordStruct(uint index);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hashRound@Utils@asmjit@@YAIII@Z")]
                    internal static extern uint HashRound(uint hash, uint c);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hashString@Utils@asmjit@@YAIPEBD_K@Z")]
                    internal static extern uint HashString([MarshalAs(UnmanagedType.LPStr)] string str, ulong len);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAII@Z")]
                    internal static extern uint Mask(uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAIII@Z")]
                    internal static extern uint Mask(uint x0, uint x1);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAIIII@Z")]
                    internal static extern uint Mask(uint x0, uint x1, uint x2);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAIIIII@Z")]
                    internal static extern uint Mask(uint x0, uint x1, uint x2, uint x3);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAIIIIII@Z")]
                    internal static extern uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAIIIIIII@Z")]
                    internal static extern uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAIIIIIIII@Z")]
                    internal static extern uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAIIIIIIIII@Z")]
                    internal static extern uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAIIIIIIIIII@Z")]
                    internal static extern uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7, uint x8);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mask@Utils@asmjit@@YAIIIIIIIIIII@Z")]
                    internal static extern uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7, uint x8, uint x9);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?bits@Utils@asmjit@@YAII@Z")]
                    internal static extern uint Bits(uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?bitCountSlow@Utils@asmjit@@YAII@Z")]
                    internal static extern uint BitCountSlow(uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?bitCount@Utils@asmjit@@YAII@Z")]
                    internal static extern uint BitCount(uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?findFirstBitSlow@Utils@asmjit@@YAII@Z")]
                    internal static extern uint FindFirstBitSlow(uint mask);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?findFirstBit@Utils@asmjit@@YAII@Z")]
                    internal static extern uint FindFirstBit(uint mask);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?keepNOnesFromRight@Utils@asmjit@@YAIII@Z")]
                    internal static extern uint KeepNOnesFromRight(uint mask, uint nBits);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?indexNOnesFromRight@Utils@asmjit@@YAIPEAEII@Z")]
                    internal static extern uint IndexNOnesFromRight(byte* dst, uint mask, uint nBits);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?strLen@Utils@asmjit@@YA_KPEBD_K@Z")]
                    internal static extern ulong StrLen([MarshalAs(UnmanagedType.LPStr)] string s, ulong maxlen);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?findPackedString@Utils@asmjit@@YAPEBDPEBDI@Z")]
                    internal static extern global::System.IntPtr FindPackedString([MarshalAs(UnmanagedType.LPStr)] string p, uint id);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?cmpInstName@Utils@asmjit@@YAHPEBD0_K@Z")]
                    internal static extern int CmpInstName([MarshalAs(UnmanagedType.LPStr)] string a, [MarshalAs(UnmanagedType.LPStr)] string b, ulong len);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byteswap32@Utils@asmjit@@YAII@Z")]
                    internal static extern uint Byteswap32(uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU8@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU8(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI8@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI8(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU16aLE@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU16aLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU16uLE@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU16uLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU16aBE@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU16aBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU16uBE@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU16uBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU16a@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU16a(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU16u@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU16u(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI16aLE@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI16aLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI16uLE@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI16uLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI16aBE@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI16aBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI16uBE@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI16uBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI16a@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI16a(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI16u@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI16u(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU32a@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU32a(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU32u@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU32u(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU32aLE@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU32aLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU32uLE@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU32uLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU32aBE@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU32aBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU32uBE@Utils@asmjit@@YAIPEBX@Z")]
                    internal static extern uint ReadU32uBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI32a@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI32a(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI32u@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI32u(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI32aLE@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI32aLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI32uLE@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI32uLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI32aBE@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI32aBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI32uBE@Utils@asmjit@@YAHPEBX@Z")]
                    internal static extern int ReadI32uBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU64a@Utils@asmjit@@YA_KPEBX@Z")]
                    internal static extern ulong ReadU64a(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU64u@Utils@asmjit@@YA_KPEBX@Z")]
                    internal static extern ulong ReadU64u(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU64aLE@Utils@asmjit@@YA_KPEBX@Z")]
                    internal static extern ulong ReadU64aLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU64uLE@Utils@asmjit@@YA_KPEBX@Z")]
                    internal static extern ulong ReadU64uLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU64aBE@Utils@asmjit@@YA_KPEBX@Z")]
                    internal static extern ulong ReadU64aBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readU64uBE@Utils@asmjit@@YA_KPEBX@Z")]
                    internal static extern ulong ReadU64uBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI64a@Utils@asmjit@@YA_JPEBX@Z")]
                    internal static extern long ReadI64a(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI64u@Utils@asmjit@@YA_JPEBX@Z")]
                    internal static extern long ReadI64u(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI64aLE@Utils@asmjit@@YA_JPEBX@Z")]
                    internal static extern long ReadI64aLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI64uLE@Utils@asmjit@@YA_JPEBX@Z")]
                    internal static extern long ReadI64uLE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI64aBE@Utils@asmjit@@YA_JPEBX@Z")]
                    internal static extern long ReadI64aBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?readI64uBE@Utils@asmjit@@YA_JPEBX@Z")]
                    internal static extern long ReadI64uBE(global::System.IntPtr p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU8@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU8(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI8@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI8(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU16aLE@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU16aLE(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU16uLE@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU16uLE(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU16aBE@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU16aBE(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU16uBE@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU16uBE(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU16a@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU16a(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU16u@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU16u(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI16aLE@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI16aLE(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI16uLE@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI16uLE(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI16aBE@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI16aBE(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI16uBE@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI16uBE(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI16a@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI16a(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI16u@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI16u(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU32aLE@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU32aLE(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU32uLE@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU32uLE(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU32aBE@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU32aBE(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU32uBE@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU32uBE(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU32a@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU32a(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU32u@Utils@asmjit@@YAXPEAXI@Z")]
                    internal static extern void WriteU32u(global::System.IntPtr p, uint x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI32aLE@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI32aLE(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI32uLE@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI32uLE(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI32aBE@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI32aBE(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI32uBE@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI32uBE(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI32a@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI32a(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI32u@Utils@asmjit@@YAXPEAXH@Z")]
                    internal static extern void WriteI32u(global::System.IntPtr p, int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU64aLE@Utils@asmjit@@YAXPEAX_K@Z")]
                    internal static extern void WriteU64aLE(global::System.IntPtr p, ulong x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU64uLE@Utils@asmjit@@YAXPEAX_K@Z")]
                    internal static extern void WriteU64uLE(global::System.IntPtr p, ulong x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU64aBE@Utils@asmjit@@YAXPEAX_K@Z")]
                    internal static extern void WriteU64aBE(global::System.IntPtr p, ulong x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU64uBE@Utils@asmjit@@YAXPEAX_K@Z")]
                    internal static extern void WriteU64uBE(global::System.IntPtr p, ulong x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU64a@Utils@asmjit@@YAXPEAX_K@Z")]
                    internal static extern void WriteU64a(global::System.IntPtr p, ulong x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeU64u@Utils@asmjit@@YAXPEAX_K@Z")]
                    internal static extern void WriteU64u(global::System.IntPtr p, ulong x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI64aLE@Utils@asmjit@@YAXPEAX_J@Z")]
                    internal static extern void WriteI64aLE(global::System.IntPtr p, long x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI64uLE@Utils@asmjit@@YAXPEAX_J@Z")]
                    internal static extern void WriteI64uLE(global::System.IntPtr p, long x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI64aBE@Utils@asmjit@@YAXPEAX_J@Z")]
                    internal static extern void WriteI64aBE(global::System.IntPtr p, long x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI64uBE@Utils@asmjit@@YAXPEAX_J@Z")]
                    internal static extern void WriteI64uBE(global::System.IntPtr p, long x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI64a@Utils@asmjit@@YAXPEAX_J@Z")]
                    internal static extern void WriteI64a(global::System.IntPtr p, long x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?writeI64u@Utils@asmjit@@YAXPEAX_J@Z")]
                    internal static extern void WriteI64u(global::System.IntPtr p, long x);
                }

                /// <summary>Bit-cast `float` to a 32-bit integer.</summary>
                public static int FloatAsInt(float f)
                {
                    var __ret = __Internal.FloatAsInt(f);
                    return __ret;
                }

                /// <summary>Bit-cast 32-bit integer to `float`.</summary>
                public static float IntAsFloat(int i)
                {
                    var __ret = __Internal.IntAsFloat(i);
                    return __ret;
                }

                /// <summary>Bit-cast `double` to a 64-bit integer.</summary>
                public static long DoubleAsInt(double d)
                {
                    var __ret = __Internal.DoubleAsInt(d);
                    return __ret;
                }

                /// <summary>Bit-cast 64-bit integer to `double`.</summary>
                public static double IntAsDouble(long i)
                {
                    var __ret = __Internal.IntAsDouble(i);
                    return __ret;
                }

                /// <summary>Pack four 8-bit integer into a 32-bit integer as it is an array of `{b0,b1,b2,b3}`.</summary>
                public static uint Pack32_4x8(uint b0, uint b1, uint b2, uint b3)
                {
                    var __ret = __Internal.Pack32_4x8(b0, b1, b2, b3);
                    return __ret;
                }

                /// <summary>Pack two 32-bit integer into a 64-bit integer as it is an array of `{u0,u1}`.</summary>
                public static ulong Pack64_2x32(uint u0, uint u1)
                {
                    var __ret = __Internal.Pack64_2x32(u0, u1);
                    return __ret;
                }

                public static uint ByteShiftOfDWordStruct(uint index)
                {
                    var __ret = __Internal.ByteShiftOfDWordStruct(index);
                    return __ret;
                }

                public static uint HashRound(uint hash, uint c)
                {
                    var __ret = __Internal.HashRound(hash, c);
                    return __ret;
                }

                public static uint HashString(string str, ulong len)
                {
                    var __ret = __Internal.HashString(str, len);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x` bit set.</summary>
                public static uint Mask(uint x)
                {
                    var __ret = __Internal.Mask(x);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x0` and `x1` bits set.</summary>
                public static uint Mask(uint x0, uint x1)
                {
                    var __ret = __Internal.Mask(x0, x1);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x0`, `x1` and `x2` bits set.</summary>
                public static uint Mask(uint x0, uint x1, uint x2)
                {
                    var __ret = __Internal.Mask(x0, x1, x2);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x0`, `x1`, `x2` and `x3` bits set.</summary>
                public static uint Mask(uint x0, uint x1, uint x2, uint x3)
                {
                    var __ret = __Internal.Mask(x0, x1, x2, x3);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x0`, `x1`, `x2`, `x3` and `x4` bits set.</summary>
                public static uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4)
                {
                    var __ret = __Internal.Mask(x0, x1, x2, x3, x4);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x0`, `x1`, `x2`, `x3`, `x4` and `x5` bits set.</summary>
                public static uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5)
                {
                    var __ret = __Internal.Mask(x0, x1, x2, x3, x4, x5);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x0`, `x1`, `x2`, `x3`, `x4`, `x5` and `x6` bits set.</summary>
                public static uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6)
                {
                    var __ret = __Internal.Mask(x0, x1, x2, x3, x4, x5, x6);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x0`, `x1`, `x2`, `x3`, `x4`, `x5`, `x6` and `x7` bits set.</summary>
                public static uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7)
                {
                    var __ret = __Internal.Mask(x0, x1, x2, x3, x4, x5, x6, x7);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x0`, `x1`, `x2`, `x3`, `x4`, `x5`, `x6`, `x7` and `x8` bits set.</summary>
                public static uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7, uint x8)
                {
                    var __ret = __Internal.Mask(x0, x1, x2, x3, x4, x5, x6, x7, x8);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x0`, `x1`, `x2`, `x3`, `x4`, `x5`, `x6`, `x7`, `x8` and `x9` bits set.</summary>
                public static uint Mask(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7, uint x8, uint x9)
                {
                    var __ret = __Internal.Mask(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
                    return __ret;
                }

                /// <summary>Generate a bit-mask that has `x` least significant bits set.</summary>
                public static uint Bits(uint x)
                {
                    var __ret = __Internal.Bits(x);
                    return __ret;
                }

                public static uint BitCountSlow(uint x)
                {
                    var __ret = __Internal.BitCountSlow(x);
                    return __ret;
                }

                /// <summary>Get count of bits in `x`.</summary>
                public static uint BitCount(uint x)
                {
                    var __ret = __Internal.BitCount(x);
                    return __ret;
                }


                public static uint FindFirstBitSlow(uint mask)
                {
                    var __ret = __Internal.FindFirstBitSlow(mask);
                    return __ret;
                }

                /// <summary>Find a first bit in `mask`.</summary>
                public static uint FindFirstBit(uint mask)
                {
                    var __ret = __Internal.FindFirstBit(mask);
                    return __ret;
                }

                public static uint KeepNOnesFromRight(uint mask, uint nBits)
                {
                    var __ret = __Internal.KeepNOnesFromRight(mask, nBits);
                    return __ret;
                }

                public static uint IndexNOnesFromRight(byte* dst, uint mask, uint nBits)
                {
                    var __ret = __Internal.IndexNOnesFromRight(dst, mask, nBits);
                    return __ret;
                }

                public static ulong StrLen(string s, ulong maxlen)
                {
                    var __ret = __Internal.StrLen(s, maxlen);
                    return __ret;
                }

                public static string FindPackedString(string p, uint id)
                {
                    var __ret = __Internal.FindPackedString(p, id);
                    return Marshal.PtrToStringAnsi(__ret);
                }

                /// <summary>Compare two instruction names.</summary>
                /// <remarks>
                /// <para>`a` is a null terminated instruction name from `???InstDB::nameData[]` table.</para>
                /// <para>`b` is a non-null terminated instruction name passed to `???Inst::getIdByName()`.</para>
                /// </remarks>
                public static int CmpInstName(string a, string b, ulong len)
                {
                    var __ret = __Internal.CmpInstName(a, b, len);
                    return __ret;
                }

                public static uint Byteswap32(uint x)
                {
                    var __ret = __Internal.Byteswap32(x);
                    return __ret;
                }

                public static uint ReadU8(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU8(p);
                    return __ret;
                }

                public static int ReadI8(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI8(p);
                    return __ret;
                }

                public static uint ReadU16aLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU16aLE(p);
                    return __ret;
                }

                public static uint ReadU16uLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU16uLE(p);
                    return __ret;
                }

                public static uint ReadU16aBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU16aBE(p);
                    return __ret;
                }

                public static uint ReadU16uBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU16uBE(p);
                    return __ret;
                }

                public static uint ReadU16a(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU16a(p);
                    return __ret;
                }

                public static uint ReadU16u(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU16u(p);
                    return __ret;
                }

                public static int ReadI16aLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI16aLE(p);
                    return __ret;
                }

                public static int ReadI16uLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI16uLE(p);
                    return __ret;
                }

                public static int ReadI16aBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI16aBE(p);
                    return __ret;
                }

                public static int ReadI16uBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI16uBE(p);
                    return __ret;
                }

                public static int ReadI16a(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI16a(p);
                    return __ret;
                }

                public static int ReadI16u(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI16u(p);
                    return __ret;
                }

                public static uint ReadU32a(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU32a(p);
                    return __ret;
                }

                public static uint ReadU32u(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU32u(p);
                    return __ret;
                }

                public static uint ReadU32aLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU32aLE(p);
                    return __ret;
                }

                public static uint ReadU32uLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU32uLE(p);
                    return __ret;
                }

                public static uint ReadU32aBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU32aBE(p);
                    return __ret;
                }

                public static uint ReadU32uBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU32uBE(p);
                    return __ret;
                }

                public static int ReadI32a(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI32a(p);
                    return __ret;
                }

                public static int ReadI32u(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI32u(p);
                    return __ret;
                }

                public static int ReadI32aLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI32aLE(p);
                    return __ret;
                }

                public static int ReadI32uLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI32uLE(p);
                    return __ret;
                }

                public static int ReadI32aBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI32aBE(p);
                    return __ret;
                }

                public static int ReadI32uBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI32uBE(p);
                    return __ret;
                }

                public static ulong ReadU64a(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU64a(p);
                    return __ret;
                }

                public static ulong ReadU64u(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU64u(p);
                    return __ret;
                }

                public static ulong ReadU64aLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU64aLE(p);
                    return __ret;
                }

                public static ulong ReadU64uLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU64uLE(p);
                    return __ret;
                }

                public static ulong ReadU64aBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU64aBE(p);
                    return __ret;
                }

                public static ulong ReadU64uBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadU64uBE(p);
                    return __ret;
                }

                public static long ReadI64a(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI64a(p);
                    return __ret;
                }

                public static long ReadI64u(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI64u(p);
                    return __ret;
                }

                public static long ReadI64aLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI64aLE(p);
                    return __ret;
                }

                public static long ReadI64uLE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI64uLE(p);
                    return __ret;
                }

                public static long ReadI64aBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI64aBE(p);
                    return __ret;
                }

                public static long ReadI64uBE(global::System.IntPtr p)
                {
                    var __ret = __Internal.ReadI64uBE(p);
                    return __ret;
                }

                public static void WriteU8(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU8(p, x);
                }

                public static void WriteI8(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI8(p, x);
                }

                public static void WriteU16aLE(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU16aLE(p, x);
                }

                public static void WriteU16uLE(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU16uLE(p, x);
                }

                public static void WriteU16aBE(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU16aBE(p, x);
                }

                public static void WriteU16uBE(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU16uBE(p, x);
                }

                public static void WriteU16a(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU16a(p, x);
                }

                public static void WriteU16u(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU16u(p, x);
                }

                public static void WriteI16aLE(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI16aLE(p, x);
                }

                public static void WriteI16uLE(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI16uLE(p, x);
                }

                public static void WriteI16aBE(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI16aBE(p, x);
                }

                public static void WriteI16uBE(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI16uBE(p, x);
                }

                public static void WriteI16a(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI16a(p, x);
                }

                public static void WriteI16u(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI16u(p, x);
                }

                public static void WriteU32aLE(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU32aLE(p, x);
                }

                public static void WriteU32uLE(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU32uLE(p, x);
                }

                public static void WriteU32aBE(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU32aBE(p, x);
                }

                public static void WriteU32uBE(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU32uBE(p, x);
                }

                public static void WriteU32a(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU32a(p, x);
                }

                public static void WriteU32u(global::System.IntPtr p, uint x)
                {
                    __Internal.WriteU32u(p, x);
                }

                public static void WriteI32aLE(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI32aLE(p, x);
                }

                public static void WriteI32uLE(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI32uLE(p, x);
                }

                public static void WriteI32aBE(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI32aBE(p, x);
                }

                public static void WriteI32uBE(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI32uBE(p, x);
                }

                public static void WriteI32a(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI32a(p, x);
                }

                public static void WriteI32u(global::System.IntPtr p, int x)
                {
                    __Internal.WriteI32u(p, x);
                }

                public static void WriteU64aLE(global::System.IntPtr p, ulong x)
                {
                    __Internal.WriteU64aLE(p, x);
                }

                public static void WriteU64uLE(global::System.IntPtr p, ulong x)
                {
                    __Internal.WriteU64uLE(p, x);
                }

                public static void WriteU64aBE(global::System.IntPtr p, ulong x)
                {
                    __Internal.WriteU64aBE(p, x);
                }

                public static void WriteU64uBE(global::System.IntPtr p, ulong x)
                {
                    __Internal.WriteU64uBE(p, x);
                }

                public static void WriteU64a(global::System.IntPtr p, ulong x)
                {
                    __Internal.WriteU64a(p, x);
                }

                public static void WriteU64u(global::System.IntPtr p, ulong x)
                {
                    __Internal.WriteU64u(p, x);
                }

                public static void WriteI64aLE(global::System.IntPtr p, long x)
                {
                    __Internal.WriteI64aLE(p, x);
                }

                public static void WriteI64uLE(global::System.IntPtr p, long x)
                {
                    __Internal.WriteI64uLE(p, x);
                }

                public static void WriteI64aBE(global::System.IntPtr p, long x)
                {
                    __Internal.WriteI64aBE(p, x);
                }

                public static void WriteI64uBE(global::System.IntPtr p, long x)
                {
                    __Internal.WriteI64uBE(p, x);
                }

                public static void WriteI64a(global::System.IntPtr p, long x)
                {
                    __Internal.WriteI64a(p, x);
                }

                public static void WriteI64u(global::System.IntPtr p, long x)
                {
                    __Internal.WriteI64u(p, x);
                }
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Constructor-less</summary>
        /// <remarks>
        /// <para>Contains no initialization code and can be used safely to define an array</para>
        /// <para>of operands that won't be initialized. This is a</para>
        /// <para>data structure designed to be statically initialized or `static const`.</para>
        /// </remarks>
        public unsafe partial class Operand_ : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Operand_@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isPackedId@Operand_@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isPackedId(uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?packId@Operand_@asmjit@@SAII@Z")]
                internal static extern uint packId(uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?unpackId@Operand_@asmjit@@SAII@Z")]
                internal static extern uint unpackId(uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_init@Operand_@asmjit@@QEAAXAEBU12@@Z")]
                internal static extern void _init(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_initReg@Operand_@asmjit@@QEAAXII@Z")]
                internal static extern void _initReg(global::System.IntPtr instance, uint signature, uint rd);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_init_packed_d0_d1@Operand_@asmjit@@QEAAXII@Z")]
                internal static extern void _init_packed_d0_d1(global::System.IntPtr instance, uint d0, uint d1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_init_packed_d2_d3@Operand_@asmjit@@QEAAXII@Z")]
                internal static extern void _init_packed_d2_d3(global::System.IntPtr instance, uint d2, uint d3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?copyFrom@Operand_@asmjit@@QEAAXAEBU12@@Z")]
                internal static extern void copyFrom(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasSignature@Operand_@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool hasSignature(global::System.IntPtr instance, uint signature);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasSignature@Operand_@asmjit@@QEBA_NAEBU12@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool hasSignature(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_hasSignatureData@Operand_@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool _hasSignatureData(global::System.IntPtr instance, uint bits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_getSignatureData@Operand_@asmjit@@QEBAIII@Z")]
                internal static extern uint _getSignatureData(global::System.IntPtr instance, uint bits, uint shift);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_setSignatureData@Operand_@asmjit@@QEAAXIII@Z")]
                internal static extern void _setSignatureData(global::System.IntPtr instance, uint value, uint bits, uint shift);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_addSignatureData@Operand_@asmjit@@QEAAXI@Z")]
                internal static extern void _addSignatureData(global::System.IntPtr instance, uint data);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_clearSignatureData@Operand_@asmjit@@QEAAXII@Z")]
                internal static extern void _clearSignatureData(global::System.IntPtr instance, uint bits, uint shift);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isReg@Operand_@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasSize@Operand_@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool hasSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasSize@Operand_@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool hasSize(global::System.IntPtr instance, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isEqual@Operand_@asmjit@@QEBA_NAEBU12@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isEqual(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isReg@Operand_@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isReg(global::System.IntPtr instance, uint rType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isReg@Operand_@asmjit@@QEBA_NII@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isReg(global::System.IntPtr instance, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@Operand_@asmjit@@QEAAXXZ")]
                internal static extern void reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSignature@Operand_@asmjit@@QEBAIXZ")]
                internal static extern uint getSignature(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setSignature@Operand_@asmjit@@QEAAXI@Z")]
                internal static extern void setSignature(global::System.IntPtr instance, uint signature);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOp@Operand_@asmjit@@QEBAIXZ")]
                internal static extern uint getOp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isNone@Operand_@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isNone(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isMem@Operand_@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isMem(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isImm@Operand_@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isImm(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isLabel@Operand_@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isLabel(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isPhysReg@Operand_@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isPhysReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVirtReg@Operand_@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isVirtReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSize@Operand_@asmjit@@QEBAIXZ")]
                internal static extern uint getSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getId@Operand_@asmjit@@QEBAIXZ")]
                internal static extern uint getId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRegOrMem@Operand_@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool isRegOrMem(global::System.IntPtr instance);
            }

            /// <summary>Operand types that can be encoded in</summary>
            public enum OpType : uint
            {
                /// <summary>Not an operand or not initialized.</summary>
                kOpNone = 0,
                /// <summary>Operand is a register.</summary>
                kOpReg = 1,
                /// <summary>Operand is a memory.</summary>
                kOpMem = 2,
                /// <summary>Operand is an immediate value.</summary>
                kOpImm = 3,
                /// <summary>Operand is a label.</summary>
                kOpLabel = 4
            }

            public enum SignatureBits : uint
            {
                kSignatureOpShift = 0,
                kSignatureOpBits = 0x7,
                kSignatureOpMask = 7,
                kSignatureSizeShift = 24,
                kSignatureSizeBits = 0xff,
                kSignatureSizeMask = 4278190080,
                kSignatureRegTypeShift = 3,
                kSignatureRegTypeBits = 0x1f,
                kSignatureRegTypeMask = 248,
                kSignatureRegKindShift = 8,
                kSignatureRegKindBits = 0xf,
                kSignatureRegKindMask = 3840,
                kSignatureMemBaseTypeShift = 3,
                kSignatureMemBaseTypeBits = 0x1f,
                kSignatureMemBaseTypeMask = 248,
                kSignatureMemIndexTypeShift = 8,
                kSignatureMemIndexTypeBits = 0x1f,
                kSignatureMemIndexTypeMask = 7936,
                kSignatureMemBaseIndexShift = 3,
                kSignatureMemBaseIndexBits = 0x3ff,
                kSignatureMemBaseIndexMask = 8184,
                kSignatureMemAddrTypeShift = 13,
                kSignatureMemAddrTypeBits = 0x3,
                kSignatureMemAddrTypeMask = 24576,
                kSignatureMemArgHomeShift = 15,
                kSignatureMemArgHomeBits = 0x1,
                kSignatureMemArgHomeFlag = 32768,
                kSignatureMemRegHomeShift = 16,
                kSignatureMemRegHomeBits = 0x1,
                kSignatureMemRegHomeFlag = 65536
            }

            /// <summary>Operand id helpers useful for id&lt;&gt;-&gt; index translation.</summary>
            public enum PackedId : uint
            {
                /// <summary>Minimum valid packed-id.</summary>
                kPackedIdMin = 0x100,
                /// <summary>Maximum valid packed-id.</summary>
                kPackedIdMax = 0xffffffff,
                /// <summary>Count of valid packed-ids.</summary>
                kPackedIdCount = 4294967040
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal _any;

                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal _reg;

                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal _mem;

                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal _imm;

                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal _label;

                    [FieldOffset(0)]
                    internal uint _signature;

                    [FieldOffset(0)]
                    internal fixed byte _packed[16];
                }
            }

            /// <summary>Any operand.</summary>
            public unsafe partial class AnyData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint signature;

                    [FieldOffset(4)]
                    internal uint id;

                    [FieldOffset(8)]
                    internal uint reserved8_4;

                    [FieldOffset(12)]
                    internal uint reserved12_4;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0AnyData@Operand_@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private AnyData(global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AnyData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AnyData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public AnyData(global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.Operand_.AnyData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            /// <summary>Register operand data.</summary>
            public unsafe partial class RegData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint signature;

                    [FieldOffset(4)]
                    internal uint id;

                    [FieldOffset(8)]
                    internal uint reserved8_4;

                    [FieldOffset(12)]
                    internal uint reserved12_4;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0RegData@Operand_@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private RegData(global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected RegData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public RegData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public RegData(global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.Operand_.RegData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            /// <summary>Memory operand data.</summary>
            public unsafe partial class MemData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint signature;

                    [FieldOffset(4)]
                    internal uint index;

                    [FieldOffset(8)]
                    internal global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData._.__Internal _;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MemData@Operand_@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public unsafe partial struct _
                {
                    [StructLayout(LayoutKind.Explicit, Size = 8)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal ulong offset64;

                        [FieldOffset(0)]
                        internal global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData._.__.__Internal __;
                    }

                    public unsafe partial class __
                    {
                        [StructLayout(LayoutKind.Explicit, Size = 8)]
                        public partial struct __Internal
                        {
                            [FieldOffset(0)]
                            internal uint offsetLo32;

                            [FieldOffset(4)]
                            internal uint @base;
                        }
                    }
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private MemData(global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MemData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MemData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public MemData(global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.Operand_.MemData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            /// <summary>Immediate operand data.</summary>
            public unsafe partial class ImmData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint signature;

                    [FieldOffset(4)]
                    internal uint id;

                    [FieldOffset(8)]
                    internal global::GraphEngine.Jit.Native.Asmjit.UInt64T.__Internal value;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ImmData@Operand_@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ImmData(global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ImmData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ImmData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public ImmData(global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.Operand_.ImmData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            /// <summary>Label operand data.</summary>
            public unsafe partial class LabelData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint signature;

                    [FieldOffset(4)]
                    internal uint id;

                    [FieldOffset(8)]
                    internal uint reserved8_4;

                    [FieldOffset(12)]
                    internal uint reserved12_4;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0LabelData@Operand_@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private LabelData(global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected LabelData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public LabelData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public LabelData(global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.Operand_.LabelData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Operand_>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.Operand_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Operand_(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Operand_ __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Operand_(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Operand_(global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Operand_(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Operand_()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Operand_(global::GraphEngine.Jit.Native.Asmjit.Operand_ _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Initialize the operand to `other` (used by constructors).</summary>
            public void _init(global::GraphEngine.Jit.Native.Asmjit.Operand_ other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal._init((__Instance + __PointerAdjustment), __arg0);
            }


            public void _initReg(uint signature, uint rd)
            {
                __Internal._initReg((__Instance + __PointerAdjustment), signature, rd);
            }


            public void _init_packed_d0_d1(uint d0, uint d1)
            {
                __Internal._init_packed_d0_d1((__Instance + __PointerAdjustment), d0, d1);
            }


            public void _init_packed_d2_d3(uint d2, uint d3)
            {
                __Internal._init_packed_d2_d3((__Instance + __PointerAdjustment), d2, d3);
            }

            /// <summary>Initialize the operand from `other` (used by operator overloads).</summary>
            public void copyFrom(global::GraphEngine.Jit.Native.Asmjit.Operand_ other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.copyFrom((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Get if the operand matches the given signature `sign`.</summary>
            public bool hasSignature(uint signature)
            {
                var __ret = __Internal.hasSignature((__Instance + __PointerAdjustment), signature);
                return __ret;
            }

            /// <summary>Get if the operand matches a signature of the `other` operand.</summary>
            public bool hasSignature(global::GraphEngine.Jit.Native.Asmjit.Operand_ other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var __ret = __Internal.hasSignature((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public bool _hasSignatureData(uint bits)
            {
                var __ret = __Internal._hasSignatureData((__Instance + __PointerAdjustment), bits);
                return __ret;
            }

            /// <summary>Unpacks information from operand's signature.</summary>
            public uint _getSignatureData(uint bits, uint shift)
            {
                var __ret = __Internal._getSignatureData((__Instance + __PointerAdjustment), bits, shift);
                return __ret;
            }

            /// <summary>Packs information to operand's signature.</summary>
            public void _setSignatureData(uint value, uint bits, uint shift)
            {
                __Internal._setSignatureData((__Instance + __PointerAdjustment), value, bits, shift);
            }

            public void _addSignatureData(uint data)
            {
                __Internal._addSignatureData((__Instance + __PointerAdjustment), data);
            }

            /// <summary>Clears specified bits in operand's signature.</summary>
            public void _clearSignatureData(uint bits, uint shift)
            {
                __Internal._clearSignatureData((__Instance + __PointerAdjustment), bits, shift);
            }

            /// <summary>Get if the operand is a register (</summary>
            public bool isReg()
            {
                var __ret = __Internal.isReg((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the operand specifies a size (i.e. the size is not zero).</summary>
            public bool hasSize()
            {
                var __ret = __Internal.hasSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the size of the operand matches `size`.</summary>
            public bool hasSize(uint size)
            {
                var __ret = __Internal.hasSize((__Instance + __PointerAdjustment), size);
                return __ret;
            }

            /// <summary>Get if the operand is 100% equal to `other`.</summary>
            public bool isEqual(global::GraphEngine.Jit.Native.Asmjit.Operand_ other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var __ret = __Internal.isEqual((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Get if the operand is a register matching `rType`.</summary>
            public bool isReg(uint rType)
            {
                var __ret = __Internal.isReg((__Instance + __PointerAdjustment), rType);
                return __ret;
            }

            /// <summary>Get whether the operand is register and of `type` and `id`.</summary>
            public bool isReg(uint rType, uint rId)
            {
                var __ret = __Internal.isReg((__Instance + __PointerAdjustment), rType, rId);
                return __ret;
            }

            /// <summary>Reset the `Operand` to none.</summary>
            /// <remarks>
            /// <para>None operand is defined the following way:</para>
            /// <para>- Its signature is zero (kOpNone, and the rest zero as well).</para>
            /// <para>- Its id is `0`.</para>
            /// <para>- The reserved8_4 field is set to `0`.</para>
            /// <para>- The reserved12_4 field is set to zero.</para>
            /// <para>In other words, reset operands have all members set to zero. Reset operand</para>
            /// <para>must match the Operand state right after its construction. Alternatively,</para>
            /// <para>if you have an array of operands, you can simply use `memset()`.</para>
            /// <para>```</para>
            /// <para>using namespace asmjit;</para>
            /// <para>Operand a;</para>
            /// <para>Operand b;</para>
            /// <para>assert(a == b);</para>
            /// <para>b = x86::eax;</para>
            /// <para>assert(a != b);</para>
            /// <para>b.reset();</para>
            /// <para>assert(a == b);</para>
            /// <para>memset(&amp;b, 0, sizeof(Operand));</para>
            /// <para>assert(a == b);</para>
            /// <para>```</para>
            /// </remarks>
            public void reset()
            {
                __Internal.reset((__Instance + __PointerAdjustment));
            }

            /// <summary>
            /// <para>Get if the given `id` is a valid packed-id that can be used by Operand.</para>
            /// <para>Packed ids are those equal or greater than `kPackedIdMin` and lesser or</para>
            /// <para>equal to `kPackedIdMax`. This concept was created to support virtual</para>
            /// <para>registers and to make them distinguishable from physical ones. It allows</para>
            /// <para>a single uint32_t to contain either physical register id or virtual</para>
            /// <para>register id represented as `packed-id`. This concept is used also for</para>
            /// <para>labels to make the API consistent.</para>
            /// </summary>
            public static bool isPackedId(uint id)
            {
                var __ret = __Internal.isPackedId(id);
                return __ret;
            }

            /// <summary>Convert a real-id into a packed-id that can be stored in Operand.</summary>
            public static uint packId(uint id)
            {
                var __ret = __Internal.packId(id);
                return __ret;
            }

            /// <summary>Convert a packed-id back to real-id.</summary>
            public static uint unpackId(uint id)
            {
                var __ret = __Internal.unpackId(id);
                return __ret;
            }

            /// <summary>Get a 32-bit operand signature.</summary>
            /// <remarks>
            /// <para>Signature is first 4 bytes of the operand data. It's used mostly for</para>
            /// <para>operand checking as it's much faster to check 4 bytes at once than having</para>
            /// <para>to check these bytes individually.</para>
            /// <para>Set the operand signature (see</para>
            /// <para>Improper use of `setSignature()` can lead to hard-to-debug errors.</para>
            /// </remarks>
            public uint signature
            {
                get
                {
                    var __ret = __Internal.getSignature((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.setSignature((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get type of the operand, see</summary>
            public uint op
            {
                get
                {
                    var __ret = __Internal.getOp((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the operand is none (</summary>
            public bool isNone
            {
                get
                {
                    var __ret = __Internal.isNone((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the operand is a memory location (</summary>
            public bool isMem
            {
                get
                {
                    var __ret = __Internal.isMem((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the operand is an immediate (</summary>
            public bool isImm
            {
                get
                {
                    var __ret = __Internal.isImm((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the operand is a label (</summary>
            public bool isLabel
            {
                get
                {
                    var __ret = __Internal.isLabel((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the operand is a physical register.</summary>
            public bool isPhysReg
            {
                get
                {
                    var __ret = __Internal.isPhysReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the operand is a virtual register.</summary>
            public bool isVirtReg
            {
                get
                {
                    var __ret = __Internal.isVirtReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get size of the operand (in bytes).</summary>
            /// <remarks>
            /// <para>The value returned depends on the operand type:</para>
            /// <para>* None  - Should always return zero size.</para>
            /// <para>* Reg   - Should always return the size of the register. If the register</para>
            /// <para>size depends on architecture (like</para>
            /// <para>the size returned should be the greatest possible (so it should</para>
            /// <para>return 64-bit size in such case).</para>
            /// <para>* Mem   - Size is optional and will be in most cases zero.</para>
            /// <para>* Imm   - Should always return zero size.</para>
            /// <para>* Label - Should always return zero size.</para>
            /// </remarks>
            public uint size
            {
                get
                {
                    var __ret = __Internal.getSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the operand id.</summary>
            /// <remarks>
            /// <para>The value returned should be interpreted accordingly to the operand type:</para>
            /// <para>* None  - Should be `0`.</para>
            /// <para>* Reg   - Physical or virtual register id.</para>
            /// <para>* Mem   - Multiple meanings - BASE address (register or label id), or</para>
            /// <para>high value of a 64-bit absolute address.</para>
            /// <para>* Imm   - Should be `0`.</para>
            /// <para>* Label - Label id if it was created by using `newLabel()` or `0`</para>
            /// <para>if the label is invalid or uninitialized.</para>
            /// </remarks>
            public uint id
            {
                get
                {
                    var __ret = __Internal.getId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the operand is a register or memory.</summary>
            public bool isRegOrMem
            {
                get
                {
                    var __ret = __Internal.isRegOrMem((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Operand can contain register, memory location, immediate, or label.</summary>
        public unsafe partial class Operand : global::GraphEngine.Jit.Native.Asmjit.Operand_, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Operand@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Operand@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Operand@asmjit@@QEAA@AEBUOperand_@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Operand@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@Operand@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.Operand __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Operand(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Operand __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Operand(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Operand(global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Operand(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create an uninitialized operand.</summary>
            public Operand()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            /// <summary>Create a reference to `other` operand.</summary>
            public Operand(global::GraphEngine.Jit.Native.Asmjit.Operand other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Create a reference to `other` operand.</summary>
            public Operand(global::GraphEngine.Jit.Native.Asmjit.Operand_ other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Create a completely uninitialized operand (dangerous).</summary>
            public Operand(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Clone the `Operand`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Operand Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.Operand.__CreateInstance(__ret);
            }
        }

        /// <summary>Label (jump target or data location).</summary>
        /// <remarks>
        /// <para>Label represents a location in code typically used as a jump target, but</para>
        /// <para>may be also a reference to some data or a static variable. Label has to be</para>
        /// <para>explicitly created by CodeEmitter.</para>
        /// <para>Example of using labels:</para>
        /// <para>~~~</para>
        /// <para>// Create a CodeEmitter (for example X86Assembler).</para>
        /// <para>X86Assembler a;</para>
        /// <para>// Create Label instance.</para>
        /// <para>Label L1 = a.newLabel();</para>
        /// <para>// ... your code ...</para>
        /// <para>// Using label.</para>
        /// <para>a.jump(L1);</para>
        /// <para>// ... your code ...</para>
        /// <para>// Bind label to the current position, see `CodeEmitter::bind()`.</para>
        /// <para>a.bind(L1);</para>
        /// <para>~~~</para>
        /// </remarks>
        public unsafe partial class Label : global::GraphEngine.Jit.Native.Asmjit.Operand, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Label@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Label@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Label@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Label@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@Label@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setId@Label@asmjit@@QEAAXI@Z")]
                internal static extern void SetId(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isValid@Label@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid(global::System.IntPtr instance);
            }

            /// <summary>Type of the Label.</summary>
            public enum Type
            {
                /// <summary>Anonymous (unnamed) label.</summary>
                kTypeAnonymous = 0,
                /// <summary>Local label (always has parentId).</summary>
                kTypeLocal = 1,
                /// <summary>Global label (never has parentId).</summary>
                kTypeGlobal = 2,
                /// <summary>Number of label types.</summary>
                kTypeCount = 3
            }

            public enum KLabelTag
            {
                /// <summary>
                /// <para>Label tag is used as a sub-type, forming a unique signature across all</para>
                /// <para>operand types as 0x1 is never associated with any register (reg-type).</para>
                /// <para>This means that a memory operand's BASE register can be constructed</para>
                /// <para>from virtually any operand (register vs. label) by just assigning its</para>
                /// <para>type (reg type or label-tag) and operand id.</para>
                /// </summary>
                kLabelTag = 1
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.Label __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Label(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Label __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Label(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.Label.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Label(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Label(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create new, unassociated label.</summary>
            public Label()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            /// <summary>Create a reference to another label.</summary>
            public Label(global::GraphEngine.Jit.Native.Asmjit.Label other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public Label(uint id)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), id);
            }

            public Label(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Set label id.</summary>
            public void SetId(uint id)
            {
                __Internal.SetId((__Instance + __PointerAdjustment), id);
            }

            /// <summary>Get if the label was created by CodeEmitter and has an assigned id.</summary>
            public bool IsValid
            {
                get
                {
                    var __ret = __Internal.IsValid((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Structure that contains core register information.</summary>
        /// <remarks>
        /// <para>This information is compatible with operand's signature (32-bit integer)</para>
        /// <para>and `RegInfo` just provides easy way to access it.</para>
        /// </remarks>
        public unsafe partial class RegInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint _signature;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0RegInfo@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSignature@RegInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetSignature(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOp@RegInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetOp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getType@RegInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getKind@RegInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetKind(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSize@RegInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetSize(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RegInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RegInfo>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.RegInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RegInfo(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.RegInfo __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RegInfo(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private RegInfo(global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RegInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public RegInfo(global::GraphEngine.Jit.Native.Asmjit.RegInfo _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal*) _0.__Instance);
            }

            public RegInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.RegInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint Signature
            {
                get
                {
                    var __ret = __Internal.GetSignature((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint Op
            {
                get
                {
                    var __ret = __Internal.GetOp((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint Type
            {
                get
                {
                    var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint Kind
            {
                get
                {
                    var __ret = __Internal.GetKind((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint Size
            {
                get
                {
                    var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Physical/Virtual register operand.</summary>
        public unsafe partial class Reg : global::GraphEngine.Jit.Native.Asmjit.Operand, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Reg@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Reg@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Reg@asmjit@@QEAA@AEBV01@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Reg@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr _0, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@Reg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isSame@Reg@asmjit@@QEBA_NAEBV12@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSame(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isType@Reg@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsType(global::System.IntPtr instance, uint rType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isKind@Reg@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsKind(global::System.IntPtr instance, uint rKind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGp@Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec@Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isReg@Reg@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsReg(global::System.IntPtr instance, uint rType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isReg@Reg@asmjit@@QEBA_NII@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsReg(global::System.IntPtr instance, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@Reg@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setId@Reg@asmjit@@QEAAXI@Z")]
                internal static extern void SetId(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setSignatureAndId@Reg@asmjit@@QEAAXII@Z")]
                internal static extern void SetSignatureAndId(global::System.IntPtr instance, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGp@Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGp_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec@Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGp@Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGp(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec@Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isValid@Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isPhysReg@Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsPhysReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVirtReg@Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVirtReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getType@Reg@asmjit@@QEBAIXZ")]
                internal static extern uint GetType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getKind@Reg@asmjit@@QEBAIXZ")]
                internal static extern uint GetKind(global::System.IntPtr instance);
            }

            /// <summary>Architecture neutral register types.</summary>
            /// <remarks>
            /// <para>These must be reused by any platform that contains that types. All GP</para>
            /// <para>and VEC registers are also allowed by design to be part of a BASE|INDEX</para>
            /// <para>of a memory operand.</para>
            /// </remarks>
            public enum RegType : uint
            {
                /// <summary>No register - unused, invalid, multiple meanings.</summary>
                kRegNone = 0,
                /// <summary>8-bit low general purpose register (X86).</summary>
                kRegGp8Lo = 2,
                /// <summary>8-bit high general purpose register (X86).</summary>
                kRegGp8Hi = 3,
                /// <summary>16-bit general purpose register (X86).</summary>
                kRegGp16 = 4,
                /// <summary>32-bit general purpose register (X86|ARM).</summary>
                kRegGp32 = 5,
                /// <summary>64-bit general purpose register (X86|ARM).</summary>
                kRegGp64 = 6,
                /// <summary>32-bit view of a vector register (ARM).</summary>
                kRegVec32 = 7,
                /// <summary>64-bit view of a vector register (ARM).</summary>
                kRegVec64 = 8,
                /// <summary>128-bit view of a vector register (X86|ARM).</summary>
                kRegVec128 = 9,
                /// <summary>256-bit view of a vector register (X86).</summary>
                kRegVec256 = 10,
                /// <summary>512-bit view of a vector register (X86).</summary>
                kRegVec512 = 11,
                /// <summary>1024-bit view of a vector register (future).</summary>
                kRegVec1024 = 12,
                /// <summary>2048-bit view of a vector register (future).</summary>
                kRegVec2048 = 13,
                /// <summary>Universal id of IP/PC register (if separate).</summary>
                kRegIP = 14,
                /// <summary>Start of platform dependent register types (must be honored).</summary>
                kRegCustom = 15,
                /// <summary>Maximum possible register id of all architectures.</summary>
                kRegMax = 31
            }

            /// <summary>Architecture neutral register kinds.</summary>
            public enum Kind : uint
            {
                /// <summary>General purpose register (X86|ARM).</summary>
                kKindGp = 0,
                /// <summary>Vector register (X86|ARM).</summary>
                kKindVec = 1,
                /// <summary>Maximum possible register kind of all architectures.</summary>
                kKindMax = 15
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.Reg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Reg(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Reg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Reg(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Reg(global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Reg(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a dummy register operand.</summary>
            public Reg()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            /// <summary>Create a new register operand which is the same as `other` .</summary>
            public Reg(global::GraphEngine.Jit.Native.Asmjit.Reg other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Create a new register operand compatible with `other`, but with a different `rId`.</summary>
            public Reg(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            /// <summary>Create a register initialized to `signature` and `rId`.</summary>
            public Reg(global::GraphEngine.Jit.Native.Asmjit._Init _0, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public Reg(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Get if this register is the same as `other`.</summary>
            /// <remarks>
            /// <para>This is just an optimization. Registers by default only use the first</para>
            /// <para>8 bytes of the Operand, so this method takes advantage of this knowledge</para>
            /// <para>and only compares these 8 bytes. If both operands were created correctly</para>
            /// <para>then `isEqual()` and `isSame()` should give the same answer, however, if</para>
            /// <para>some operands contains a garbage or other metadata in the upper 8 bytes</para>
            /// <para>then `isSame()` may return `true` in cases where `isEqual()` returns</para>
            /// <para>false. However. no such case is known at the moment.</para>
            /// </remarks>
            public bool IsSame(global::GraphEngine.Jit.Native.Asmjit.Reg other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var __ret = __Internal.IsSame((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Get if the register type matches `rType` - same as `isReg(rType)`, provided for convenience.</summary>
            public bool IsType(uint rType)
            {
                var __ret = __Internal.IsType((__Instance + __PointerAdjustment), rType);
                return __ret;
            }

            /// <summary>Get if the register kind matches `rKind`.</summary>
            public bool IsKind(uint rKind)
            {
                var __ret = __Internal.IsKind((__Instance + __PointerAdjustment), rKind);
                return __ret;
            }

            /// <summary>Get if the register is a general purpose register (any size).</summary>
            public bool IsGp()
            {
                var __ret = __Internal.IsGp((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a vector register.</summary>
            public bool IsVec()
            {
                var __ret = __Internal.IsVec((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Same as `isType()`, provided for convenience.</summary>
            public bool IsReg(uint rType)
            {
                var __ret = __Internal.IsReg((__Instance + __PointerAdjustment), rType);
                return __ret;
            }

            /// <summary>Get if the register type matches `type` and register id matches `rId`.</summary>
            public bool IsReg(uint rType, uint rId)
            {
                var __ret = __Internal.IsReg((__Instance + __PointerAdjustment), rType, rId);
                return __ret;
            }

            /// <summary>Clone the register operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Reg Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.Reg.__CreateInstance(__ret);
            }

            /// <summary>Set the register id to `id`.</summary>
            public void SetId(uint rId)
            {
                __Internal.SetId((__Instance + __PointerAdjustment), rId);
            }

            /// <summary>Set register's `signature` and `rId`.</summary>
            public void SetSignatureAndId(uint signature, uint rId)
            {
                __Internal.SetSignatureAndId((__Instance + __PointerAdjustment), signature, rId);
            }

            /// <summary>Create a new register based on `signature` and `rId`.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Reg FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.Reg.__CreateInstance(__ret);
            }

            public static bool IsGp(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGp_1(__arg0);
                return __ret;
            }

            /// <summary>Get if the `op` operand is either a low or high 8-bit GPB register.</summary>
            public static bool IsVec(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsVec_1(__arg0);
                return __ret;
            }

            public static bool IsGp(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGp(__arg0, rId);
                return __ret;
            }

            public static bool IsVec(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsVec(__arg0, rId);
                return __ret;
            }

            /// <summary>Get if the register is valid (either virtual or physical).</summary>
            public bool IsValid
            {
                get
                {
                    var __ret = __Internal.IsValid((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if this is a physical register.</summary>
            public bool isPhysReg
            {
                get
                {
                    var __ret = __Internal.IsPhysReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if this is a virtual register (used by</summary>
            public bool isVirtReg
            {
                get
                {
                    var __ret = __Internal.IsVirtReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the register type.</summary>
            public uint Type
            {
                get
                {
                    var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the register kind.</summary>
            public uint kind
            {
                get
                {
                    var __ret = __Internal.GetKind((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>RegOnly is 8-byte version of `Reg` that only allows to store either `Reg`</para>
        /// <para>or nothing. This class was designed to decrease the space consumed by each</para>
        /// <para>extra &quot;operand&quot; in `CodeEmitter` and `CBInst` classes.</para>
        /// </summary>
        public unsafe partial class RegOnly : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint _signature;

                [FieldOffset(4)]
                internal uint _id;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0RegOnly@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@RegOnly@asmjit@@QEAAXII@Z")]
                internal static extern void Init(global::System.IntPtr instance, uint signature, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@RegOnly@asmjit@@QEAAXAEBVReg@2@@Z")]
                internal static extern void Init(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@RegOnly@asmjit@@QEAAXAEBU12@@Z")]
                internal static extern void Init_1(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@RegOnly@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_getSignatureData@RegOnly@asmjit@@QEBAIII@Z")]
                internal static extern uint GetSignatureData(global::System.IntPtr instance, uint bits, uint shift);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isNone@RegOnly@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsNone(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isValid@RegOnly@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isPhysReg@RegOnly@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsPhysReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVirtReg@RegOnly@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVirtReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSignature@RegOnly@asmjit@@QEBAIXZ")]
                internal static extern uint GetSignature(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getId@RegOnly@asmjit@@QEBAIXZ")]
                internal static extern uint GetId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getType@RegOnly@asmjit@@QEBAIXZ")]
                internal static extern uint GetType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getKind@RegOnly@asmjit@@QEBAIXZ")]
                internal static extern uint GetKind(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RegOnly> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RegOnly>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.RegOnly __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RegOnly(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.RegOnly __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RegOnly(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private RegOnly(global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RegOnly(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public RegOnly()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public RegOnly(global::GraphEngine.Jit.Native.Asmjit.RegOnly _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.RegOnly __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Initialize the `RegOnly` instance to hold register `signature` and `id`.</summary>
            public void Init(uint signature, uint id)
            {
                __Internal.Init((__Instance + __PointerAdjustment), signature, id);
            }

            public void Init(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                __Internal.Init((__Instance + __PointerAdjustment), __arg0);
            }

            public void Init(global::GraphEngine.Jit.Native.Asmjit.RegOnly reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                __Internal.Init_1((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Reset the `RegOnly` to none.</summary>
            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Unpacks information from operand's signature.</summary>
            public uint GetSignatureData(uint bits, uint shift)
            {
                var __ret = __Internal.GetSignatureData((__Instance + __PointerAdjustment), bits, shift);
                return __ret;
            }

            /// <summary>Get if the `ExtraReg` is none (same as calling `Operand_::isNone()`).</summary>
            public bool IsNone
            {
                get
                {
                    var __ret = __Internal.IsNone((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the register is valid (either virtual or physical).</summary>
            public bool IsValid
            {
                get
                {
                    var __ret = __Internal.IsValid((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if this is a physical register.</summary>
            public bool IsPhysReg
            {
                get
                {
                    var __ret = __Internal.IsPhysReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if this is a virtual register (used by</summary>
            public bool IsVirtReg
            {
                get
                {
                    var __ret = __Internal.IsVirtReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get register signature or 0.</summary>
            public uint Signature
            {
                get
                {
                    var __ret = __Internal.GetSignature((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get register id or 0.</summary>
            public uint Id
            {
                get
                {
                    var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the register type.</summary>
            public uint Type
            {
                get
                {
                    var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the register kind.</summary>
            public uint Kind
            {
                get
                {
                    var __ret = __Internal.GetKind((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Base class for all memory operands.</summary>
        /// <remarks>
        /// <para>NOTE: It's tricky to pack all possible cases that define a memory operand</para>
        /// <para>into just 16 bytes. The `Mem` splits data into the following parts:</para>
        /// <para>BASE - Base register or label - requires 36 bits total. 4 bits are used</para>
        /// <para>to encode the type of the BASE operand (label vs. register type) and</para>
        /// <para>the remaining 32 bits define the BASE id, which can be a physical or</para>
        /// <para>virtual register index. If BASE type is zero, which is never used as</para>
        /// <para>a register-type and label doesn't use it as well then BASE field</para>
        /// <para>contains a high DWORD of a possible 64-bit absolute address, which is</para>
        /// <para>possible on X64.</para>
        /// <para>INDEX - Index register (or theoretically Label, which doesn't make sense).</para>
        /// <para>Encoding is similar to BASE - it also requires 36 bits and splits the</para>
        /// <para>encoding to INDEX type (4 bits defining the register type) and id (32-bits).</para>
        /// <para>OFFSET - A relative offset of the address. Basically if BASE is specified</para>
        /// <para>the relative displacement adjusts BASE and an optional INDEX. if BASE is</para>
        /// <para>not specified then the OFFSET should be considered as ABSOLUTE address</para>
        /// <para>(at least on X86/X64). In that case its low 32 bits are stored in</para>
        /// <para>DISPLACEMENT field and the remaining high 32 bits are stored in BASE.</para>
        /// <para>OTHER FIELDS - There is rest 8 bits that can be used for whatever purpose.</para>
        /// <para>The X86Mem operand uses these bits to store segment override</para>
        /// <para>prefix and index shift (scale).</para>
        /// </remarks>
        public unsafe partial class Mem : global::GraphEngine.Jit.Native.Asmjit.Operand, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Mem@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Mem@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Mem@asmjit@@QEAA@AEBU_Init@1@IIIIHII@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr _0, uint baseType, uint baseId, uint indexType, uint indexId, int off, uint size, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@Mem@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@Mem@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetAddrType@Mem@asmjit@@QEAAXXZ")]
                internal static extern void ResetAddrType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setAbs@Mem@asmjit@@QEAAXXZ")]
                internal static extern void SetAbs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setRel@Mem@asmjit@@QEAAXXZ")]
                internal static extern void SetRel(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setWrt@Mem@asmjit@@QEAAXXZ")]
                internal static extern void SetWrt(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setArgHome@Mem@asmjit@@QEAAXXZ")]
                internal static extern void SetArgHome(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setRegHome@Mem@asmjit@@QEAAXXZ")]
                internal static extern void SetRegHome(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearArgHome@Mem@asmjit@@QEAAXXZ")]
                internal static extern void ClearArgHome(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearRegHome@Mem@asmjit@@QEAAXXZ")]
                internal static extern void ClearRegHome(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_setBase@Mem@asmjit@@QEAAXII@Z")]
                internal static extern void SetBase(global::System.IntPtr instance, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_setIndex@Mem@asmjit@@QEAAXII@Z")]
                internal static extern void SetIndex(global::System.IntPtr instance, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setBase@Mem@asmjit@@QEAAXAEBVReg@2@@Z")]
                internal static extern void SetBase(global::System.IntPtr instance, global::System.IntPtr @base);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setIndex@Mem@asmjit@@QEAAXAEBVReg@2@@Z")]
                internal static extern void SetIndex(global::System.IntPtr instance, global::System.IntPtr index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetBase@Mem@asmjit@@QEAAXXZ")]
                internal static extern void ResetBase(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetIndex@Mem@asmjit@@QEAAXXZ")]
                internal static extern void ResetIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setSize@Mem@asmjit@@QEAAXI@Z")]
                internal static extern void SetSize(global::System.IntPtr instance, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addOffset@Mem@asmjit@@QEAAX_J@Z")]
                internal static extern void AddOffset(global::System.IntPtr instance, long off);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetOffset@Mem@asmjit@@QEAAXXZ")]
                internal static extern void ResetOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addOffsetLo32@Mem@asmjit@@QEAAXH@Z")]
                internal static extern void AddOffsetLo32(global::System.IntPtr instance, int off);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetOffsetLo32@Mem@asmjit@@QEAAXXZ")]
                internal static extern void ResetOffsetLo32(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAddrType@Mem@asmjit@@QEBAIXZ")]
                internal static extern uint GetAddrType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setAddrType@Mem@asmjit@@QEAAXI@Z")]
                internal static extern void SetAddrType(global::System.IntPtr instance, uint addrType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOffset@Mem@asmjit@@QEBA_JXZ")]
                internal static extern long GetOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setOffset@Mem@asmjit@@QEAAX_J@Z")]
                internal static extern void SetOffset(global::System.IntPtr instance, long offset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOffsetLo32@Mem@asmjit@@QEBAHXZ")]
                internal static extern int GetOffsetLo32(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setOffsetLo32@Mem@asmjit@@QEAAXH@Z")]
                internal static extern void SetOffsetLo32(global::System.IntPtr instance, int off);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAddrType@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAddrType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isAbs@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAbs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRel@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRel(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isWrt@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsWrt(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isArgHome@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsArgHome(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRegHome@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRegHome(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasBase@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasBase(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasIndex@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasBaseOrIndex@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasBaseOrIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasBaseAndIndex@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasBaseAndIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasBaseReg@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasBaseReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasBaseLabel@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasBaseLabel(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasIndexReg@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasIndexReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBaseType@Mem@asmjit@@QEBAIXZ")]
                internal static extern uint GetBaseType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getIndexType@Mem@asmjit@@QEBAIXZ")]
                internal static extern uint GetIndexType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBaseIndexType@Mem@asmjit@@QEBAIXZ")]
                internal static extern uint GetBaseIndexType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBaseId@Mem@asmjit@@QEBAIXZ")]
                internal static extern uint GetBaseId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getIndexId@Mem@asmjit@@QEBAIXZ")]
                internal static extern uint GetIndexId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasOffset@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?has64BitOffset@Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Has64BitOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOffsetHi32@Mem@asmjit@@QEBAHXZ")]
                internal static extern int GetOffsetHi32(global::System.IntPtr instance);
            }

            public enum AddrType
            {
                kAddrTypeDefault = 0,
                kAddrTypeAbs = 1,
                kAddrTypeRel = 2,
                kAddrTypeWrt = 3
            }

            public enum SignatureMem
            {
                kSignatureMemAbs = 8192,
                kSignatureMemRel = 16384,
                kSignatureMemWrt = 24576
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.Mem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Mem(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Mem __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Mem(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Mem(global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Mem(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Construct a default `Mem` operand, that points to [0].</summary>
            public Mem()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public Mem(global::GraphEngine.Jit.Native.Asmjit.Mem other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public Mem(global::GraphEngine.Jit.Native.Asmjit._Init _0, uint baseType, uint baseId, uint indexType, uint indexId, int off, uint size, uint flags)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, baseType, baseId, indexType, indexId, off, size, flags);
            }

            public Mem(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Clone `Mem` operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Mem Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Mem.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.Mem.__CreateInstance(__ret);
            }

            /// <summary>Reset the memory operand - after reset the memory points to [0].</summary>
            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            public void ResetAddrType()
            {
                __Internal.ResetAddrType((__Instance + __PointerAdjustment));
            }

            public void SetAbs()
            {
                __Internal.SetAbs((__Instance + __PointerAdjustment));
            }

            public void SetRel()
            {
                __Internal.SetRel((__Instance + __PointerAdjustment));
            }

            public void SetWrt()
            {
                __Internal.SetWrt((__Instance + __PointerAdjustment));
            }

            public void SetArgHome()
            {
                __Internal.SetArgHome((__Instance + __PointerAdjustment));
            }

            public void SetRegHome()
            {
                __Internal.SetRegHome((__Instance + __PointerAdjustment));
            }

            public void ClearArgHome()
            {
                __Internal.ClearArgHome((__Instance + __PointerAdjustment));
            }

            public void ClearRegHome()
            {
                __Internal.ClearRegHome((__Instance + __PointerAdjustment));
            }

            public void SetBase(uint rType, uint rId)
            {
                __Internal.SetBase((__Instance + __PointerAdjustment), rType, rId);
            }

            public void SetIndex(uint rType, uint rId)
            {
                __Internal.SetIndex((__Instance + __PointerAdjustment), rType, rId);
            }

            public void SetBase(global::GraphEngine.Jit.Native.Asmjit.Reg @base)
            {
                if (ReferenceEquals(@base, null))
                    throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @base.__Instance;
                __Internal.SetBase((__Instance + __PointerAdjustment), __arg0);
            }

            public void SetIndex(global::GraphEngine.Jit.Native.Asmjit.Reg index)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                __Internal.SetIndex((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Reset the memory operand's BASE register / label.</summary>
            public void ResetBase()
            {
                __Internal.ResetBase((__Instance + __PointerAdjustment));
            }

            /// <summary>Reset the memory operand's INDEX register.</summary>
            public void ResetIndex()
            {
                __Internal.ResetIndex((__Instance + __PointerAdjustment));
            }

            /// <summary>Set memory operand size.</summary>
            public void SetSize(uint size)
            {
                __Internal.SetSize((__Instance + __PointerAdjustment), size);
            }

            /// <summary>Adjust the offset by a 64-bit `off`.</summary>
            public void AddOffset(long off)
            {
                __Internal.AddOffset((__Instance + __PointerAdjustment), off);
            }

            /// <summary>Reset the memory offset to zero.</summary>
            public void ResetOffset()
            {
                __Internal.ResetOffset((__Instance + __PointerAdjustment));
            }

            /// <summary>Adjust the offset by `off`.</summary>
            /// <remarks>
            /// <para>NOTE: This is a fast function that doesn't use the HI 32-bits of a</para>
            /// <para>64-bit offset. Use it only if you know that there is a BASE register</para>
            /// <para>and the offset is only 32 bits anyway.</para>
            /// </remarks>
            public void AddOffsetLo32(int off)
            {
                __Internal.AddOffsetLo32((__Instance + __PointerAdjustment), off);
            }

            /// <summary>Reset the memory offset to zero.</summary>
            public void ResetOffsetLo32()
            {
                __Internal.ResetOffsetLo32((__Instance + __PointerAdjustment));
            }

            public uint addrType
            {
                get
                {
                    var __ret = __Internal.GetAddrType((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetAddrType((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get a 64-bit offset or absolute address.</summary>
            /// <remarks>
            /// <para>Set a 64-bit offset or an absolute address to `offset`.</para>
            /// <para>NOTE: This functions attempts to set both high and low parts of a 64-bit</para>
            /// <para>offset, however, if the operand has a BASE register it will store only the</para>
            /// <para>low 32 bits of the offset / address as there is no way to store both BASE</para>
            /// <para>and 64-bit offset, and there is currently no architecture that has such</para>
            /// <para>capability targeted by AsmJit.</para>
            /// </remarks>
            public long Offset
            {
                get
                {
                    var __ret = __Internal.GetOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetOffset((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get a lower part of a 64-bit offset or absolute address.</summary>
            /// <remarks>Set a low 32-bit offset to `off`.</remarks>
            public int OffsetLo32
            {
                get
                {
                    var __ret = __Internal.GetOffsetLo32((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetOffsetLo32((__Instance + __PointerAdjustment), value);
                }
            }

            public bool HasAddrType
            {
                get
                {
                    var __ret = __Internal.HasAddrType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsAbs
            {
                get
                {
                    var __ret = __Internal.IsAbs((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsRel
            {
                get
                {
                    var __ret = __Internal.IsRel((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsWrt
            {
                get
                {
                    var __ret = __Internal.IsWrt((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsArgHome
            {
                get
                {
                    var __ret = __Internal.IsArgHome((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsRegHome
            {
                get
                {
                    var __ret = __Internal.IsRegHome((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the memory operand has a BASE register or label specified.</summary>
            public bool HasBase
            {
                get
                {
                    var __ret = __Internal.HasBase((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the memory operand has an INDEX register specified.</summary>
            public bool HasIndex
            {
                get
                {
                    var __ret = __Internal.HasIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the memory operand has BASE and INDEX register.</summary>
            public bool HasBaseOrIndex
            {
                get
                {
                    var __ret = __Internal.HasBaseOrIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the memory operand has BASE and INDEX register.</summary>
            public bool HasBaseAndIndex
            {
                get
                {
                    var __ret = __Internal.HasBaseAndIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the BASE operand is a register (registers start after `kLabelTag`).</summary>
            public bool HasBaseReg
            {
                get
                {
                    var __ret = __Internal.HasBaseReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the BASE operand is a label.</summary>
            public bool HasBaseLabel
            {
                get
                {
                    var __ret = __Internal.HasBaseLabel((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the INDEX operand is a register (registers start after `kLabelTag`).</summary>
            public bool HasIndexReg
            {
                get
                {
                    var __ret = __Internal.HasIndexReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get type of a BASE register (0 if this memory operand doesn't use the BASE register).</summary>
            /// <remarks>
            /// <para>NOTE: If the returned type is one (a value never associated to a register</para>
            /// <para>type) the BASE is not register, but it's a label. One equals to `kLabelTag`.</para>
            /// <para>You should always check `hasBaseLabel()` before using `getBaseId()` result.</para>
            /// </remarks>
            public uint BaseType
            {
                get
                {
                    var __ret = __Internal.GetBaseType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get type of an INDEX register (0 if this memory operand doesn't use the INDEX register).</summary>
            public uint IndexType
            {
                get
                {
                    var __ret = __Internal.GetIndexType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get both BASE (4:0 bits) and INDEX (9:5 bits) types combined into a single integer.</summary>
            /// <remarks>This is used internally for BASE+INDEX validation.</remarks>
            public uint BaseIndexType
            {
                get
                {
                    var __ret = __Internal.GetBaseIndexType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get id of the BASE register or label (if the BASE was specified as label).</summary>
            public uint BaseId
            {
                get
                {
                    var __ret = __Internal.GetBaseId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get id of the INDEX register.</summary>
            public uint IndexId
            {
                get
                {
                    var __ret = __Internal.GetIndexId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasOffset
            {
                get
                {
                    var __ret = __Internal.HasOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the memory operand has 64-bit offset or absolute address.</summary>
            /// <remarks>If this is true then `hasBase()` must always report false.</remarks>
            public bool Has64BitOffset
            {
                get
                {
                    var __ret = __Internal.Has64BitOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a higher part of a 64-bit offset or absolute address.</summary>
            /// <remarks>
            /// <para>NOTE: This function is UNSAFE and returns garbage if `has64BitOffset()`</para>
            /// <para>returns false. Never use it blindly without checking it.</para>
            /// </remarks>
            public int OffsetHi32
            {
                get
                {
                    var __ret = __Internal.GetOffsetHi32((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Immediate operand.</summary>
        /// <remarks>
        /// <para>Immediate operand is usually part of instruction itself. It's inlined after</para>
        /// <para>or before the instruction opcode. Immediates can be only signed or unsigned</para>
        /// <para>integers.</para>
        /// <para>To create immediate operand use `imm()` or `imm_u()` non-members or `Imm`</para>
        /// <para>constructors.</para>
        /// </remarks>
        public unsafe partial class Imm : global::GraphEngine.Jit.Native.Asmjit.Operand, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Imm@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Imm@asmjit@@QEAA@_J@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, long val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Imm@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Imm@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@Imm@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setPtr@Imm@asmjit@@QEAAXPEAX@Z")]
                internal static extern void SetPtr(global::System.IntPtr instance, global::System.IntPtr p);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setFloat@Imm@asmjit@@QEAAXM@Z")]
                internal static extern void SetFloat(global::System.IntPtr instance, float f);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setDouble@Imm@asmjit@@QEAAXN@Z")]
                internal static extern void SetDouble(global::System.IntPtr instance, double d);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?truncateTo8Bits@Imm@asmjit@@QEAAXXZ")]
                internal static extern void TruncateTo8Bits(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?truncateTo16Bits@Imm@asmjit@@QEAAXXZ")]
                internal static extern void TruncateTo16Bits(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?truncateTo32Bits@Imm@asmjit@@QEAAXXZ")]
                internal static extern void TruncateTo32Bits(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInt8@Imm@asmjit@@QEBACXZ")]
                internal static extern sbyte GetInt8(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setInt8@Imm@asmjit@@QEAAXC@Z")]
                internal static extern void SetInt8(global::System.IntPtr instance, sbyte val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUInt8@Imm@asmjit@@QEBAEXZ")]
                internal static extern byte GetUInt8(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setUInt8@Imm@asmjit@@QEAAXE@Z")]
                internal static extern void SetUInt8(global::System.IntPtr instance, byte val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInt16@Imm@asmjit@@QEBAFXZ")]
                internal static extern short GetInt16(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setInt16@Imm@asmjit@@QEAAXF@Z")]
                internal static extern void SetInt16(global::System.IntPtr instance, short val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUInt16@Imm@asmjit@@QEBAGXZ")]
                internal static extern ushort GetUInt16(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setUInt16@Imm@asmjit@@QEAAXG@Z")]
                internal static extern void SetUInt16(global::System.IntPtr instance, ushort val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInt32@Imm@asmjit@@QEBAHXZ")]
                internal static extern int GetInt32(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setInt32@Imm@asmjit@@QEAAXH@Z")]
                internal static extern void SetInt32(global::System.IntPtr instance, int val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUInt32@Imm@asmjit@@QEBAIXZ")]
                internal static extern uint GetUInt32(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setUInt32@Imm@asmjit@@QEAAXI@Z")]
                internal static extern void SetUInt32(global::System.IntPtr instance, uint val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInt64@Imm@asmjit@@QEBA_JXZ")]
                internal static extern long GetInt64(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setInt64@Imm@asmjit@@QEAAX_J@Z")]
                internal static extern void SetInt64(global::System.IntPtr instance, long val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUInt64@Imm@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetUInt64(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setUInt64@Imm@asmjit@@QEAAX_K@Z")]
                internal static extern void SetUInt64(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getIntPtr@Imm@asmjit@@QEBA_JXZ")]
                internal static extern long GetIntPtr(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setIntPtr@Imm@asmjit@@QEAAX_J@Z")]
                internal static extern void SetIntPtr(global::System.IntPtr instance, long val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUIntPtr@Imm@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetUIntPtr(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setUIntPtr@Imm@asmjit@@QEAAX_K@Z")]
                internal static extern void SetUIntPtr(global::System.IntPtr instance, ulong val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInt8@Imm@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInt8(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isUInt8@Imm@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsUInt8(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInt16@Imm@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInt16(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isUInt16@Imm@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsUInt16(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInt32@Imm@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInt32(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isUInt32@Imm@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsUInt32(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInt32Lo@Imm@asmjit@@QEBAHXZ")]
                internal static extern int GetInt32Lo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInt32Hi@Imm@asmjit@@QEBAHXZ")]
                internal static extern int GetInt32Hi(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUInt32Lo@Imm@asmjit@@QEBAIXZ")]
                internal static extern uint GetUInt32Lo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUInt32Hi@Imm@asmjit@@QEBAIXZ")]
                internal static extern uint GetUInt32Hi(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.Imm __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Imm(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Imm __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Imm(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Imm(global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Imm(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new immediate value (initial value is 0).</summary>
            public Imm()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            /// <summary>Create a new signed immediate value, assigning the value to `val`.</summary>
            public Imm(long val)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), val);
            }

            /// <summary>Create a new immediate value from `other`.</summary>
            public Imm(global::GraphEngine.Jit.Native.Asmjit.Imm other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public Imm(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Clone `Imm` operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Imm Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.Imm.__CreateInstance(__ret);
            }

            /// <summary>Set immediate value as unsigned type to `val`.</summary>
            public void SetPtr(global::System.IntPtr p)
            {
                __Internal.SetPtr((__Instance + __PointerAdjustment), p);
            }

            public void SetFloat(float f)
            {
                __Internal.SetFloat((__Instance + __PointerAdjustment), f);
            }

            public void SetDouble(double d)
            {
                __Internal.SetDouble((__Instance + __PointerAdjustment), d);
            }

            public void TruncateTo8Bits()
            {
                __Internal.TruncateTo8Bits((__Instance + __PointerAdjustment));
            }

            public void TruncateTo16Bits()
            {
                __Internal.TruncateTo16Bits((__Instance + __PointerAdjustment));
            }

            public void TruncateTo32Bits()
            {
                __Internal.TruncateTo32Bits((__Instance + __PointerAdjustment));
            }

            /// <summary>Get immediate value as 8-bit signed integer.</summary>
            /// <remarks>Set immediate value to 8-bit signed integer `val`.</remarks>
            public sbyte Int8
            {
                get
                {
                    var __ret = __Internal.GetInt8((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetInt8((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get immediate value as 8-bit unsigned integer.</summary>
            /// <remarks>Set immediate value to 8-bit unsigned integer `val`.</remarks>
            public byte UInt8
            {
                get
                {
                    var __ret = __Internal.GetUInt8((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetUInt8((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get immediate value as 16-bit signed integer.</summary>
            /// <remarks>Set immediate value to 16-bit signed integer `val`.</remarks>
            public short Int16
            {
                get
                {
                    var __ret = __Internal.GetInt16((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetInt16((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get immediate value as 16-bit unsigned integer.</summary>
            /// <remarks>Set immediate value to 16-bit unsigned integer `val`.</remarks>
            public ushort UInt16
            {
                get
                {
                    var __ret = __Internal.GetUInt16((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetUInt16((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get immediate value as 32-bit signed integer.</summary>
            /// <remarks>Set immediate value to 32-bit signed integer `val`.</remarks>
            public int Int32
            {
                get
                {
                    var __ret = __Internal.GetInt32((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetInt32((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get immediate value as 32-bit unsigned integer.</summary>
            /// <remarks>Set immediate value to 32-bit unsigned integer `val`.</remarks>
            public uint UInt32
            {
                get
                {
                    var __ret = __Internal.GetUInt32((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetUInt32((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get immediate value as 64-bit signed integer.</summary>
            /// <remarks>Set immediate value to 64-bit signed integer `val`.</remarks>
            public long Int64
            {
                get
                {
                    var __ret = __Internal.GetInt64((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetInt64((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get immediate value as 64-bit unsigned integer.</summary>
            /// <remarks>Set immediate value to 64-bit unsigned integer `val`.</remarks>
            public ulong UInt64
            {
                get
                {
                    var __ret = __Internal.GetUInt64((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetUInt64((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get immediate value as `intptr_t`.</summary>
            /// <remarks>Set immediate value to intptr_t `val`.</remarks>
            public long IntPtr
            {
                get
                {
                    var __ret = __Internal.GetIntPtr((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetIntPtr((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get immediate value as `uintptr_t`.</summary>
            /// <remarks>Set immediate value to uintptr_t `val`.</remarks>
            public ulong UIntPtr
            {
                get
                {
                    var __ret = __Internal.GetUIntPtr((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetUIntPtr((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get whether the immediate can be casted to 8-bit signed integer.</summary>
            public bool IsInt8
            {
                get
                {
                    var __ret = __Internal.IsInt8((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the immediate can be casted to 8-bit unsigned integer.</summary>
            public bool IsUInt8
            {
                get
                {
                    var __ret = __Internal.IsUInt8((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the immediate can be casted to 16-bit signed integer.</summary>
            public bool IsInt16
            {
                get
                {
                    var __ret = __Internal.IsInt16((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the immediate can be casted to 16-bit unsigned integer.</summary>
            public bool IsUInt16
            {
                get
                {
                    var __ret = __Internal.IsUInt16((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the immediate can be casted to 32-bit signed integer.</summary>
            public bool IsInt32
            {
                get
                {
                    var __ret = __Internal.IsInt32((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the immediate can be casted to 32-bit unsigned integer.</summary>
            public bool IsUInt32
            {
                get
                {
                    var __ret = __Internal.IsUInt32((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get low 32-bit signed integer.</summary>
            public int Int32Lo
            {
                get
                {
                    var __ret = __Internal.GetInt32Lo((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get high 32-bit signed integer.</summary>
            public int Int32Hi
            {
                get
                {
                    var __ret = __Internal.GetInt32Hi((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get low 32-bit signed integer.</summary>
            public uint UInt32Lo
            {
                get
                {
                    var __ret = __Internal.GetUInt32Lo((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get high 32-bit signed integer.</summary>
            public uint UInt32Hi
            {
                get
                {
                    var __ret = __Internal.GetUInt32Hi((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Type-id.</summary>
        /// <remarks>
        /// <para>This is an additional information that can be used to describe a physical</para>
        /// <para>or virtual register. it's used mostly by CodeCompiler to describe register</para>
        /// <para>representation (the kind of data stored in the register and the width used)</para>
        /// <para>and it's also used by APIs that allow to describe and work with function</para>
        /// <para>signatures.</para>
        /// </remarks>
        public unsafe partial class TypeId : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0TypeId@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVoid@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVoid(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isValid@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isAbstract@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAbstract(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInt@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInt(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpb@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpb(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpw@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpw(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpd@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpd(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpq@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpq(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isFloat@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFloat(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isMask@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMask(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isMmx@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMmx(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec32@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec32(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec64@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec64(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec128@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec128(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec256@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec256(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec512@TypeId@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec512(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?sizeOf@TypeId@asmjit@@SAII@Z")]
                internal static extern uint SizeOf(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?elementOf@TypeId@asmjit@@SAII@Z")]
                internal static extern uint ElementOf(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?deabstractDeltaOfSize@TypeId@asmjit@@SAII@Z")]
                internal static extern uint DeabstractDeltaOfSize(uint gpSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?deabstract@TypeId@asmjit@@SAIII@Z")]
                internal static extern uint Deabstract(uint typeId, uint deabstractDelta);
            }

            public enum Id
            {
                kVoid = 0,
                KIntStart = 32,
                KIntEnd = 41,
                kIntPtr = 32,
                kUIntPtr = 33,
                kI8 = 34,
                kU8 = 35,
                kI16 = 36,
                kU16 = 37,
                kI32 = 38,
                kU32 = 39,
                kI64 = 40,
                kU64 = 41,
                KFloatStart = 42,
                KFloatEnd = 44,
                kF32 = 42,
                kF64 = 43,
                kF80 = 44,
                KMaskStart = 45,
                KMaskEnd = 48,
                kMask8 = 45,
                kMask16 = 46,
                kMask32 = 47,
                kMask64 = 48,
                KMmxStart = 49,
                KMmxEnd = 50,
                kMmx32 = 49,
                kMmx64 = 50,
                KVec32Start = 51,
                KVec32End = 60,
                kI8x4 = 51,
                kU8x4 = 52,
                kI16x2 = 53,
                kU16x2 = 54,
                kI32x1 = 55,
                kU32x1 = 56,
                kF32x1 = 59,
                KVec64Start = 61,
                KVec64End = 70,
                kI8x8 = 61,
                kU8x8 = 62,
                kI16x4 = 63,
                kU16x4 = 64,
                kI32x2 = 65,
                kU32x2 = 66,
                kI64x1 = 67,
                kU64x1 = 68,
                kF32x2 = 69,
                kF64x1 = 70,
                KVec128Start = 71,
                KVec128End = 80,
                kI8x16 = 71,
                kU8x16 = 72,
                kI16x8 = 73,
                kU16x8 = 74,
                kI32x4 = 75,
                kU32x4 = 76,
                kI64x2 = 77,
                kU64x2 = 78,
                kF32x4 = 79,
                kF64x2 = 80,
                KVec256Start = 81,
                KVec256End = 90,
                kI8x32 = 81,
                kU8x32 = 82,
                kI16x16 = 83,
                kU16x16 = 84,
                kI32x8 = 85,
                kU32x8 = 86,
                kI64x4 = 87,
                kU64x4 = 88,
                kF32x8 = 89,
                kF64x4 = 90,
                KVec512Start = 91,
                KVec512End = 100,
                kI8x64 = 91,
                kU8x64 = 92,
                kI16x32 = 93,
                kU16x32 = 94,
                kI32x16 = 95,
                kU32x16 = 96,
                kI64x8 = 97,
                kU64x8 = 98,
                kF32x16 = 99,
                kF64x8 = 100,
                kCount = 101
            }

            public unsafe partial class Int8 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Int8@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Int8(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Int8(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Int8()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Int8(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Int8 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class UInt8 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0UInt8@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private UInt8(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UInt8(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UInt8()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public UInt8(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt8 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Int16 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Int16@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Int16(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Int16(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Int16()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Int16(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Int16 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class UInt16 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0UInt16@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private UInt16(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UInt16(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UInt16()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public UInt16(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt16 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Int32 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Int32@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Int32(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Int32(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Int32()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Int32(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Int32 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class UInt32 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0UInt32@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private UInt32(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UInt32(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UInt32()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public UInt32(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt32 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Int64 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Int64@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Int64(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Int64(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Int64()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Int64(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Int64 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class UInt64 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0UInt64@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private UInt64(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UInt64(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UInt64()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public UInt64(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.UInt64 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class IntPtrT : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0IntPtr@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private IntPtrT(global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected IntPtrT(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public IntPtrT()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public IntPtrT(global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.IntPtrT __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class UIntPtr : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0UIntPtr@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private UIntPtr(global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UIntPtr(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UIntPtr()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public UIntPtr(global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.UIntPtr __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Float : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Float@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Float> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Float>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Float __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Float(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Float __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Float.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Float(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Float.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Float.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Float.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Float(global::GraphEngine.Jit.Native.Asmjit.TypeId.Float.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Float(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Float()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Float.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Float(global::GraphEngine.Jit.Native.Asmjit.TypeId.Float _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Float.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Float.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Float.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Float __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Double : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Double@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Double> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Double>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Double __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Double(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Double __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Double.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Double(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Double.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Double.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Double.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Double(global::GraphEngine.Jit.Native.Asmjit.TypeId.Double.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Double(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Double()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Double.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Double(global::GraphEngine.Jit.Native.Asmjit.TypeId.Double _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Double.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Double.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Double.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Double __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class MmxReg : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MmxReg@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private MmxReg(global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MmxReg(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MmxReg()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public MmxReg(global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.MmxReg __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Vec128 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Vec128@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Vec128(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Vec128(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Vec128()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Vec128(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec128 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Vec256 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Vec256@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Vec256(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Vec256(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Vec256()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Vec256(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec256 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Vec512 : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Vec512@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Vec512(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Vec512(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Vec512()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Vec512(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512 _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Vec512 __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Info : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 256)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed byte sizeOf[128];

                    [FieldOffset(128)]
                    internal fixed byte elementOf[128];

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Info@TypeId@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Info> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId.Info>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Info __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Info(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.TypeId.Info __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.TypeId.Info(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Info(global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Info(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Info()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Info(global::GraphEngine.Jit.Native.Asmjit.TypeId.Info _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.TypeId.Info __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TypeId>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.TypeId __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.TypeId(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.TypeId __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TypeId.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.TypeId(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TypeId.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.TypeId.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TypeId(global::GraphEngine.Jit.Native.Asmjit.TypeId.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeId(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public TypeId()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public TypeId(global::GraphEngine.Jit.Native.Asmjit.TypeId _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TypeId.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.TypeId.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.TypeId.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.TypeId __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static bool IsVoid(uint typeId)
            {
                var __ret = __Internal.IsVoid(typeId);
                return __ret;
            }

            public static bool IsValid(uint typeId)
            {
                var __ret = __Internal.IsValid(typeId);
                return __ret;
            }

            public static bool IsAbstract(uint typeId)
            {
                var __ret = __Internal.IsAbstract(typeId);
                return __ret;
            }

            public static bool IsInt(uint typeId)
            {
                var __ret = __Internal.IsInt(typeId);
                return __ret;
            }

            public static bool IsGpb(uint typeId)
            {
                var __ret = __Internal.IsGpb(typeId);
                return __ret;
            }

            public static bool IsGpw(uint typeId)
            {
                var __ret = __Internal.IsGpw(typeId);
                return __ret;
            }

            public static bool IsGpd(uint typeId)
            {
                var __ret = __Internal.IsGpd(typeId);
                return __ret;
            }

            public static bool IsGpq(uint typeId)
            {
                var __ret = __Internal.IsGpq(typeId);
                return __ret;
            }

            public static bool IsFloat(uint typeId)
            {
                var __ret = __Internal.IsFloat(typeId);
                return __ret;
            }

            public static bool IsMask(uint typeId)
            {
                var __ret = __Internal.IsMask(typeId);
                return __ret;
            }

            public static bool IsMmx(uint typeId)
            {
                var __ret = __Internal.IsMmx(typeId);
                return __ret;
            }

            public static bool IsVec(uint typeId)
            {
                var __ret = __Internal.IsVec(typeId);
                return __ret;
            }

            public static bool IsVec32(uint typeId)
            {
                var __ret = __Internal.IsVec32(typeId);
                return __ret;
            }

            public static bool IsVec64(uint typeId)
            {
                var __ret = __Internal.IsVec64(typeId);
                return __ret;
            }

            public static bool IsVec128(uint typeId)
            {
                var __ret = __Internal.IsVec128(typeId);
                return __ret;
            }

            public static bool IsVec256(uint typeId)
            {
                var __ret = __Internal.IsVec256(typeId);
                return __ret;
            }

            public static bool IsVec512(uint typeId)
            {
                var __ret = __Internal.IsVec512(typeId);
                return __ret;
            }

            public static uint SizeOf(uint typeId)
            {
                var __ret = __Internal.SizeOf(typeId);
                return __ret;
            }

            public static uint ElementOf(uint typeId)
            {
                var __ret = __Internal.ElementOf(typeId);
                return __ret;
            }

            /// <summary>
            /// <para>Get an offset to convert a `kIntPtr` and `kUIntPtr` TypeId into a</para>
            /// <para>type that matches `gpSize` (general-purpose register size). If you</para>
            /// <para>find such TypeId it's then only about adding the offset to it.</para>
            /// </summary>
            /// <remarks>
            /// <para>For example:</para>
            /// <para>~~~</para>
            /// <para>uint32_t gpSize = '4' or '8';</para>
            /// <para>uint32_t deabstractDelta = TypeId::deabstractDeltaOfSize(gpSize);</para>
            /// <para>uint32_t typeId = 'some type-id';</para>
            /// <para>// Normalize some typeId into a non-abstract typeId.</para>
            /// <para>if (TypeId::isAbstract(typeId)) typeId += deabstractDelta;</para>
            /// <para>// The same, but by using TypeId::deabstract() function.</para>
            /// <para>typeId = TypeId::deabstract(typeId, deabstractDelta);</para>
            /// <para>~~~</para>
            /// </remarks>
            public static uint DeabstractDeltaOfSize(uint gpSize)
            {
                var __ret = __Internal.DeabstractDeltaOfSize(gpSize);
                return __ret;
            }

            public static uint Deabstract(uint typeId, uint deabstractDelta)
            {
                var __ret = __Internal.Deabstract(typeId, deabstractDelta);
                return __ret;
            }

            public static global::GraphEngine.Jit.Native.Asmjit.TypeId.Info _info
            {
                get
                {
                    var __ptr = (global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?_info@TypeId@asmjit@@2UInfo@12@B");
                    return global::GraphEngine.Jit.Native.Asmjit.TypeId.Info.__CreateInstance(*__ptr);
                }
            }
        }

        public unsafe partial class operand
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?imm@asmjit@@YA?AVImm@1@_J@Z")]
                internal static extern void imm(global::System.IntPtr @return, long val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?imm_u@asmjit@@YA?AVImm@1@_K@Z")]
                internal static extern void ImmU(global::System.IntPtr @return, ulong val);
            }

            /// <summary>Create a signed immediate operand.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Imm imm(long val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal();
                __Internal.imm(new IntPtr(&__ret), val);
                return global::GraphEngine.Jit.Native.Asmjit.Imm.__CreateInstance(__ret);
            }

            /// <summary>Create an unsigned immediate operand.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Imm ImmU(ulong val)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Imm.__Internal();
                __Internal.ImmU(new IntPtr(&__ret), val);
                return global::GraphEngine.Jit.Native.Asmjit.Imm.__CreateInstance(__ret);
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>\{</summary>
        public unsafe partial class ArchInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.ArchInfo._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ArchInfo@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ArchInfo@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ArchInfo@asmjit@@QEAA@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint type, uint subType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isX86Family@ArchInfo@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsX86Family(uint archType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isArmFamily@ArchInfo@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsArmFamily(uint archType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@ArchInfo@asmjit@@QEAAXII@Z")]
                internal static extern void Init(global::System.IntPtr instance, uint type, uint subType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@ArchInfo@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isX86Family@ArchInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsX86Family(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isArmFamily@ArchInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsArmFamily(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8ArchInfo@asmjit@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9ArchInfo@asmjit@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?host@ArchInfo@asmjit@@SA?AV12@XZ")]
                internal static extern void Host(global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInitialized@ArchInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInitialized(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?is32Bit@ArchInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Is32Bit(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?is64Bit@ArchInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Is64Bit(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getType@ArchInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSubType@ArchInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetSubType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGpSize@ArchInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetGpSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGpCount@ArchInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetGpCount(global::System.IntPtr instance);
            }

            /// <summary>Architecture type.</summary>
            public enum Type : uint
            {
                /// <summary>No/Unknown architecture.</summary>
                kTypeNone = 0,
                /// <summary>X86 architecture (32-bit).</summary>
                kTypeX86 = 1,
                /// <summary>X64 architecture (64-bit) (AMD64).</summary>
                kTypeX64 = 2,
                /// <summary>X32 architecture (DEAD-END).</summary>
                kTypeX32 = 3,
                /// <summary>ARM 32-bit architecture (AArch32/ARM/THUMB).</summary>
                kTypeA32 = 4,
                /// <summary>ARM 64-bit architecture (AArch64).</summary>
                kTypeA64 = 5,
                /// <summary>Architecture detected at compile-time (architecture of the host).</summary>
                kTypeHost = 2
            }

            /// <summary>Architecture sub-type or execution mode.</summary>
            public enum SubType : uint
            {
                /// <summary>Default mode (or no specific mode).</summary>
                kSubTypeNone = 0,
                /// <summary>Code generation uses AVX         by default (VEC instructions).</summary>
                kSubTypeX86AVX = 1,
                /// <summary>Code generation uses AVX2        by default (VEC instructions).</summary>
                kSubTypeX86AVX2 = 2,
                /// <summary>Code generation uses AVX-512F    by default (+32 vector regs).</summary>
                kSubTypeX86AVX512 = 3,
                /// <summary>Code generation uses AVX-512F-VL by default (+VL extensions).</summary>
                kSubTypeX86AVX512VL = 4,
                /// <summary>THUMB|THUMB2 sub-type (only ARM in 32-bit mode).</summary>
                kSubTypeA32Thumb = 8,
                kSubTypeHost = 0
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.ArchInfo._.__.__Internal __;

                    [FieldOffset(0)]
                    internal uint _signature;
                }

                public unsafe partial class __
                {
                    [StructLayout(LayoutKind.Explicit, Size = 4)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal byte _type;

                        [FieldOffset(1)]
                        internal byte _subType;

                        [FieldOffset(2)]
                        internal byte _gpSize;

                        [FieldOffset(3)]
                        internal byte _gpCount;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ArchInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ArchInfo>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ArchInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ArchInfo(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ArchInfo __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ArchInfo(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private ArchInfo(global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ArchInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ArchInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public ArchInfo(global::GraphEngine.Jit.Native.Asmjit.ArchInfo other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public ArchInfo(uint type, uint subType)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), type, subType);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ArchInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Init(uint type, uint subType)
            {
                __Internal.Init((__Instance + __PointerAdjustment), type, subType);
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Get if the architecture is X86, X64, or X32.</summary>
            public bool IsX86Family()
            {
                var __ret = __Internal.IsX86Family((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the architecture is ARM32 or ARM64.</summary>
            public bool IsArmFamily()
            {
                var __ret = __Internal.IsArmFamily((__Instance + __PointerAdjustment));
                return __ret;
            }

            public static bool operator ==(global::GraphEngine.Jit.Native.Asmjit.ArchInfo __op, global::GraphEngine.Jit.Native.Asmjit.ArchInfo other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return __opNull && otherNull;
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::GraphEngine.Jit.Native.Asmjit.ArchInfo;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::GraphEngine.Jit.Native.Asmjit.ArchInfo __op, global::GraphEngine.Jit.Native.Asmjit.ArchInfo other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return !(__opNull && otherNull);
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return __ret;
            }

            public static bool IsX86Family(uint archType)
            {
                var __ret = __Internal.IsX86Family(archType);
                return __ret;
            }

            public static bool IsArmFamily(uint archType)
            {
                var __ret = __Internal.IsArmFamily(archType);
                return __ret;
            }

            public static global::GraphEngine.Jit.Native.Asmjit.ArchInfo Host
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal();
                    __Internal.Host(new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__CreateInstance(__ret);
                }
            }

            public bool IsInitialized
            {
                get
                {
                    var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the architecture is 32-bit.</summary>
            public bool Is32Bit
            {
                get
                {
                    var __ret = __Internal.Is32Bit((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the architecture is 64-bit.</summary>
            public bool Is64Bit
            {
                get
                {
                    var __ret = __Internal.Is64Bit((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get architecture type, see</summary>
            public uint type
            {
                get
                {
                    var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get architecture sub-type, see</summary>
            /// <remarks>
            /// <para>X86&amp;X64</para>
            /// <para>---------</para>
            /// <para>Architecture subtype describe the highest instruction-set level that can</para>
            /// <para>be used.</para>
            /// <para>ARM32</para>
            /// <para>-----</para>
            /// <para>Architecture mode means the instruction encoding to be used when generating</para>
            /// <para>machine code, thus mode can be used to force generation of THUMB and THUMB2</para>
            /// <para>encoding or regular ARM encoding.</para>
            /// <para>ARM64</para>
            /// <para>-----</para>
            /// <para>No meaning yet.</para>
            /// </remarks>
            public uint subType
            {
                get
                {
                    var __ret = __Internal.GetSubType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a size of a general-purpose register.</summary>
            public uint GpSize
            {
                get
                {
                    var __ret = __Internal.GetGpSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get number of general-purpose registers.</summary>
            public uint GpCount
            {
                get
                {
                    var __ret = __Internal.GetGpCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Information about all architecture registers.</summary>
        public unsafe partial class ArchRegs : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 192)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal fixed byte regInfo[128];

                [FieldOffset(128)]
                internal fixed byte regCount[32];

                [FieldOffset(160)]
                internal fixed byte regTypeToTypeId[32];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ArchRegs@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ArchRegs> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ArchRegs>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ArchRegs __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ArchRegs(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ArchRegs __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ArchRegs(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ArchRegs(global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ArchRegs(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ArchRegs(global::GraphEngine.Jit.Native.Asmjit.ArchRegs _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal*) _0.__Instance);
            }

            public ArchRegs()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ArchRegs __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class ArchUtils : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ArchUtils@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?typeIdToRegInfo@ArchUtils@asmjit@@SAIIAEAIAEAURegInfo@2@@Z")]
                internal static extern uint TypeIdToRegInfo(uint archType, uint* typeIdInOut, global::System.IntPtr regInfo);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ArchUtils> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ArchUtils>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ArchUtils __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ArchUtils(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ArchUtils __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ArchUtils.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ArchUtils(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ArchUtils.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchUtils.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ArchUtils.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ArchUtils(global::GraphEngine.Jit.Native.Asmjit.ArchUtils.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ArchUtils(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ArchUtils()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchUtils.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public ArchUtils(global::GraphEngine.Jit.Native.Asmjit.ArchUtils _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ArchUtils.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.ArchUtils.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ArchUtils.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ArchUtils __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static uint TypeIdToRegInfo(uint archType, ref uint typeIdInOut, global::GraphEngine.Jit.Native.Asmjit.RegInfo regInfo)
            {
                fixed (uint* __refParamPtr1 = &typeIdInOut)
                {
                    var __arg1 = __refParamPtr1;
                    if (ReferenceEquals(regInfo, null))
                        throw new global::System.ArgumentNullException("regInfo", "Cannot be null because it is a C++ reference (&).");
                    var __arg2 = regInfo.__Instance;
                    var __ret = __Internal.TypeIdToRegInfo(archType, __arg1, __arg2);
                    return __ret;
                }
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Function argument index (lo/hi).</summary>
        [Flags]
        public enum FuncArgIndex : uint
        {
            /// <summary>Maximum number of function arguments supported by AsmJit.</summary>
            kFuncArgCount = 16,
            /// <summary>Extended maximum number of arguments (used internally).</summary>
            kFuncArgCountLoHi = 32,
            /// <summary>Index to the LO part of function argument (default).</summary>
            /// <remarks>
            /// <para>This value is typically omitted and added only if there is HI argument</para>
            /// <para>accessed.</para>
            /// </remarks>
            kFuncArgLo = 0,
            /// <summary>Index to the HI part of function argument.</summary>
            /// <remarks>
            /// <para>HI part of function argument depends on target architecture. On x86 it's</para>
            /// <para>typically used to transfer 64-bit integers (they form a pair of 32-bit</para>
            /// <para>integers).</para>
            /// </remarks>
            kFuncArgHi = 16
        }

        /// <summary>Function calling convention.</summary>
        /// <remarks>
        /// <para>Function calling convention is a scheme that defines how function parameters</para>
        /// <para>are passed and how function returns its result. AsmJit defines a variety of</para>
        /// <para>architecture and OS specific calling conventions and also provides a compile</para>
        /// <para>time detection to make JIT code-generation easier.</para>
        /// </remarks>
        public unsafe partial class CallConv : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 72)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal byte _id;

                [FieldOffset(1)]
                internal byte _archType;

                [FieldOffset(2)]
                internal byte _algorithm;

                [FieldOffset(3)]
                internal byte _flags;

                [FieldOffset(4)]
                internal byte _naturalStackAlignment;

                [FieldOffset(5)]
                internal byte _spillZoneSize;

                [FieldOffset(6)]
                internal ushort _redZoneSize;

                [FieldOffset(8)]
                internal fixed byte _passedOrder[32];

                [FieldOffset(40)]
                internal fixed uint _passedRegs[4];

                [FieldOffset(56)]
                internal fixed uint _preservedRegs[4];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CallConv@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isX86Family@CallConv@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsX86Family(uint ccId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isArmFamily@CallConv@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsArmFamily(uint ccId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@CallConv@asmjit@@QEAAII@Z")]
                internal static extern uint Init(global::System.IntPtr instance, uint ccId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@CallConv@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasFlag@CallConv@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasFlag(global::System.IntPtr instance, uint flag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addFlags@CallConv@asmjit@@QEAAXI@Z")]
                internal static extern void AddFlags(global::System.IntPtr instance, uint flag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPassedOrder@CallConv@asmjit@@QEBAPEBEI@Z")]
                internal static extern byte* GetPassedOrder(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPassedRegs@CallConv@asmjit@@QEBAII@Z")]
                internal static extern uint GetPassedRegs(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_setPassedPacked@CallConv@asmjit@@QEAAXIII@Z")]
                internal static extern void SetPassedPacked(global::System.IntPtr instance, uint kind, uint p0, uint p1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setPassedToNone@CallConv@asmjit@@QEAAXI@Z")]
                internal static extern void SetPassedToNone(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setPassedOrder@CallConv@asmjit@@QEAAXIIIIIIIII@Z")]
                internal static extern void SetPassedOrder(global::System.IntPtr instance, uint kind, uint a0, uint a1, uint a2, uint a3, uint a4, uint a5, uint a6, uint a7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPreservedRegs@CallConv@asmjit@@QEBAII@Z")]
                internal static extern uint GetPreservedRegs(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setPreservedRegs@CallConv@asmjit@@QEAAXII@Z")]
                internal static extern void SetPreservedRegs(global::System.IntPtr instance, uint kind, uint regs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getId@CallConv@asmjit@@QEBAIXZ")]
                internal static extern uint GetId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setId@CallConv@asmjit@@QEAAXI@Z")]
                internal static extern void SetId(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchType@CallConv@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setArchType@CallConv@asmjit@@QEAAXI@Z")]
                internal static extern void SetArchType(global::System.IntPtr instance, uint archType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAlgorithm@CallConv@asmjit@@QEBAIXZ")]
                internal static extern uint GetAlgorithm(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setAlgorithm@CallConv@asmjit@@QEAAXI@Z")]
                internal static extern void SetAlgorithm(global::System.IntPtr instance, uint algorithm);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFlags@CallConv@asmjit@@QEBAIXZ")]
                internal static extern uint GetFlags(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setFlags@CallConv@asmjit@@QEAAXI@Z")]
                internal static extern void SetFlags(global::System.IntPtr instance, uint flag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getNaturalStackAlignment@CallConv@asmjit@@QEBAIXZ")]
                internal static extern uint GetNaturalStackAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setNaturalStackAlignment@CallConv@asmjit@@QEAAXI@Z")]
                internal static extern void SetNaturalStackAlignment(global::System.IntPtr instance, uint value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSpillZoneSize@CallConv@asmjit@@QEBAIXZ")]
                internal static extern uint GetSpillZoneSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setSpillZoneSize@CallConv@asmjit@@QEAAXI@Z")]
                internal static extern void SetSpillZoneSize(global::System.IntPtr instance, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRedZoneSize@CallConv@asmjit@@QEBAIXZ")]
                internal static extern uint GetRedZoneSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setRedZoneSize@CallConv@asmjit@@QEAAXI@Z")]
                internal static extern void SetRedZoneSize(global::System.IntPtr instance, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasSpillZone@CallConv@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasSpillZone(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasRedZone@CallConv@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasRedZone(global::System.IntPtr instance);
            }

            /// <summary>Calling convention id.</summary>
            public enum Id : uint
            {
                /// <summary>None or invalid (can't be used).</summary>
                kIdNone = 0,
                /// <summary>X86 `__cdecl` calling convention (used by C runtime and libraries).</summary>
                kIdX86CDecl = 16,
                /// <summary>X86 `__stdcall` calling convention (used mostly by WinAPI).</summary>
                kIdX86StdCall = 17,
                /// <summary>X86 `__thiscall` calling convention (MSVC/Intel).</summary>
                kIdX86MsThisCall = 18,
                /// <summary>X86 `__fastcall` convention (MSVC/Intel).</summary>
                kIdX86MsFastCall = 19,
                /// <summary>X86 `__fastcall` convention (GCC and Clang).</summary>
                kIdX86GccFastCall = 20,
                /// <summary>X86 `regparm(1)` convention (GCC and Clang).</summary>
                kIdX86GccRegParm1 = 21,
                /// <summary>X86 `regparm(2)` convention (GCC and Clang).</summary>
                kIdX86GccRegParm2 = 22,
                /// <summary>X86 `regparm(3)` convention (GCC and Clang).</summary>
                kIdX86GccRegParm3 = 23,
                /// <summary>X86 `regparm(3)` convention (GCC and Clang).</summary>
                kIdX86FastEval2 = 29,
                /// <summary>X86 `regparm(3)` convention (GCC and Clang).</summary>
                kIdX86FastEval3 = 30,
                /// <summary>X86 `regparm(3)` convention (GCC and Clang).</summary>
                kIdX86FastEval4 = 31,
                /// <summary>X64 calling convention defined by WIN64-ABI.</summary>
                /// <remarks>
                /// <para>Links:</para>
                /// <para>*://msdn.microsoft.com/en-us/library/9b372w95.aspx&gt;.</para>
                /// </remarks>
                kIdX86Win64 = 32,
                /// <summary>X64 calling convention used by Unix platforms (SYSV/AMD64-ABI).</summary>
                kIdX86SysV64 = 33,
                /// <summary>X64 calling convention used by Unix platforms (SYSV/AMD64-ABI).</summary>
                kIdX64FastEval2 = 45,
                /// <summary>X64 calling convention used by Unix platforms (SYSV/AMD64-ABI).</summary>
                kIdX64FastEval3 = 46,
                /// <summary>X64 calling convention used by Unix platforms (SYSV/AMD64-ABI).</summary>
                kIdX64FastEval4 = 47,
                /// <summary>Legacy calling convention, floating point arguments are passed via GP registers.</summary>
                kIdArm32SoftFP = 48,
                /// <summary>Modern calling convention, uses VFP registers to pass floating point arguments.</summary>
                kIdArm32HardFP = 49,

                KIdX86Start = 16,

                KIdX86End = 31,

                KIdX64Start = 32,

                KIdX64End = 47,

                KIdArmStart = 48,

                KIdArmEnd = 49,
                kIdHost = 32,
                kIdHostCDecl = 32,
                kIdHostStdCall = 32,
                kIdHostFastCall = 32,
                kIdHostFastEval2 = 45,
                kIdHostFastEval3 = 46,
                kIdHostFastEval4 = 47
            }

            /// <summary>Calling convention algorithm.</summary>
            /// <remarks>
            /// <para>This is AsmJit specific. It basically describes how should AsmJit convert</para>
            /// <para>the function arguments defined by `FuncSignature` into register ids or</para>
            /// <para>stack offsets. The default algorithm is a standard algorithm that assigns</para>
            /// <para>registers first, and then assigns stack. The Win64 algorithm does register</para>
            /// <para>shadowing as defined by `WIN64` calling convention - it applies to 64-bit</para>
            /// <para>calling conventions only.</para>
            /// </remarks>
            public enum Algorithm : uint
            {
                /// <summary>Default algorithm (cross-platform).</summary>
                kAlgorithmDefault = 0,
                /// <summary>WIN64 specific algorithm.</summary>
                kAlgorithmWin64 = 1
            }

            /// <summary>Calling convention flags.</summary>
            [Flags]
            public enum Flags : uint
            {
                /// <summary>Callee is responsible for cleaning up the stack.</summary>
                kFlagCalleePopsStack = 0x1,
                /// <summary>Pass F32 and F64 arguments by VEC128 register.</summary>
                kFlagPassFloatsByVec = 0x2,
                /// <summary>This is a '__vectorcall' calling convention.</summary>
                kFlagVectorCall = 0x4,
                /// <summary>Pass vector arguments indirectly (as a pointer).</summary>
                kFlagIndirectVecArgs = 0x8
            }

            /// <summary>Internal limits of AsmJit/CallConv.</summary>
            [Flags]
            public enum Limits : uint
            {
                kMaxVRegKinds = 4,
                kNumRegArgsPerKind = 8
            }

            /// <summary>Passed registers' order.</summary>
            public unsafe partial struct RegOrder
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed byte id[8];

                    [FieldOffset(0)]
                    internal fixed uint packed[2];

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0RegOrder@CallConv@asmjit@@QEAA@AEBT012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                private RegOrder.__Internal __instance;
                internal RegOrder.__Internal __Instance { get { return __instance; } }

                internal static global::GraphEngine.Jit.Native.Asmjit.CallConv.RegOrder __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.CallConv.RegOrder(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.CallConv.RegOrder __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CallConv.RegOrder.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.CallConv.RegOrder(native, skipVTables);
                }

                private RegOrder(global::GraphEngine.Jit.Native.Asmjit.CallConv.RegOrder.__Internal native, bool skipVTables = false)
                    : this()
                {
                    __instance = native;
                }

                private RegOrder(void* native, bool skipVTables = false) : this()
                {
                    __instance = *(global::GraphEngine.Jit.Native.Asmjit.CallConv.RegOrder.__Internal*) native;
                }

                public RegOrder(global::GraphEngine.Jit.Native.Asmjit.CallConv.RegOrder _0)
                    : this()
                {
                    var ____arg0 = _0.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    fixed (__Internal* __instancePtr = &__instance)
                    {
                        __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CallConv> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CallConv>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.CallConv __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CallConv(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CallConv __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CallConv(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CallConv(global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CallConv(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CallConv()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public CallConv(global::GraphEngine.Jit.Native.Asmjit.CallConv _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CallConv __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint Init(uint ccId)
            {
                var __ret = __Internal.Init((__Instance + __PointerAdjustment), ccId);
                return __ret;
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Get if the calling convention has the given `flag` set.</summary>
            public bool HasFlag(uint flag)
            {
                var __ret = __Internal.HasFlag((__Instance + __PointerAdjustment), flag);
                return __ret;
            }

            /// <summary>Add calling convention flags, see</summary>
            public void AddFlags(uint flag)
            {
                __Internal.AddFlags((__Instance + __PointerAdjustment), flag);
            }

            public byte* GetPassedOrder(uint kind)
            {
                var __ret = __Internal.GetPassedOrder((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            public uint GetPassedRegs(uint kind)
            {
                var __ret = __Internal.GetPassedRegs((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            public void SetPassedPacked(uint kind, uint p0, uint p1)
            {
                __Internal.SetPassedPacked((__Instance + __PointerAdjustment), kind, p0, p1);
            }

            public void SetPassedToNone(uint kind)
            {
                __Internal.SetPassedToNone((__Instance + __PointerAdjustment), kind);
            }

            public void SetPassedOrder(uint kind, uint a0, uint a1, uint a2, uint a3, uint a4, uint a5, uint a6, uint a7)
            {
                __Internal.SetPassedOrder((__Instance + __PointerAdjustment), kind, a0, a1, a2, a3, a4, a5, a6, a7);
            }

            public uint GetPreservedRegs(uint kind)
            {
                var __ret = __Internal.GetPreservedRegs((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            public void SetPreservedRegs(uint kind, uint regs)
            {
                __Internal.SetPreservedRegs((__Instance + __PointerAdjustment), kind, regs);
            }

            public static bool IsX86Family(uint ccId)
            {
                var __ret = __Internal.IsX86Family(ccId);
                return __ret;
            }

            public static bool IsArmFamily(uint ccId)
            {
                var __ret = __Internal.IsArmFamily(ccId);
                return __ret;
            }

            /// <summary>Get calling convention id, see</summary>
            /// <remarks>Set calling convention id, see</remarks>
            public uint id
            {
                get
                {
                    var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetId((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get architecture type.</summary>
            /// <remarks>Set architecture type.</remarks>
            public uint ArchType
            {
                get
                {
                    var __ret = __Internal.GetArchType((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetArchType((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get calling convention algorithm, see</summary>
            /// <remarks>Set calling convention algorithm, see</remarks>
            public uint algorithm
            {
                get
                {
                    var __ret = __Internal.GetAlgorithm((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetAlgorithm((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get calling convention flags, see</summary>
            /// <remarks>Add calling convention flags, see</remarks>
            public uint flags
            {
                get
                {
                    var __ret = __Internal.GetFlags((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetFlags((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get a natural stack alignment.</summary>
            /// <remarks>
            /// <para>Set a natural stack alignment.</para>
            /// <para>This function can be used to override the default stack alignment in case</para>
            /// <para>that you know that it's alignment is different. For example it allows to</para>
            /// <para>implement custom calling conventions that guarantee higher stack alignment.</para>
            /// </remarks>
            public uint NaturalStackAlignment
            {
                get
                {
                    var __ret = __Internal.GetNaturalStackAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetNaturalStackAlignment((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get size of 'SpillZone'.</summary>
            /// <remarks>Set size of 'SpillZone'.</remarks>
            public uint SpillZoneSize
            {
                get
                {
                    var __ret = __Internal.GetSpillZoneSize((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetSpillZoneSize((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get size of 'RedZone'.</summary>
            /// <remarks>Set size of 'RedZone'.</remarks>
            public uint RedZoneSize
            {
                get
                {
                    var __ret = __Internal.GetRedZoneSize((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetRedZoneSize((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get if this calling convention specifies 'SpillZone'.</summary>
            public bool HasSpillZone
            {
                get
                {
                    var __ret = __Internal.HasSpillZone((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if this calling convention specifies 'RedZone'.</summary>
            public bool HasRedZone
            {
                get
                {
                    var __ret = __Internal.HasRedZone((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Function signature.</summary>
        /// <remarks>
        /// <para>Contains information about function return type, count of arguments and</para>
        /// <para>their TypeIds. Function signature is a low level structure which doesn't</para>
        /// <para>contain platform specific or calling convention specific information.</para>
        /// </remarks>
        public unsafe partial class FuncSignature : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal byte _callConv;

                [FieldOffset(1)]
                internal byte _argCount;

                [FieldOffset(2)]
                internal byte _vaIndex;

                [FieldOffset(3)]
                internal byte _ret;

                [FieldOffset(8)]
                internal global::System.IntPtr _args;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncSignature@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@FuncSignature@asmjit@@QEAAXIIPEBEI@Z")]
                internal static extern void Init(global::System.IntPtr instance, uint ccId, uint ret, byte* args, uint argCount);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@FuncSignature@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArg@FuncSignature@asmjit@@QEBAII@Z")]
                internal static extern uint GetArg(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCallConv@FuncSignature@asmjit@@QEBAIXZ")]
                internal static extern uint GetCallConv(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasVarArgs@FuncSignature@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasVarArgs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVAIndex@FuncSignature@asmjit@@QEBAIXZ")]
                internal static extern uint GetVAIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArgCount@FuncSignature@asmjit@@QEBAIXZ")]
                internal static extern uint GetArgCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasRet@FuncSignature@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasRet(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRet@FuncSignature@asmjit@@QEBAIXZ")]
                internal static extern uint GetRet(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArgs@FuncSignature@asmjit@@QEBAPEBEXZ")]
                internal static extern byte* GetArgs(global::System.IntPtr instance);
            }

            public enum KNoVarArgs
            {
                /// <summary>Doesn't have variable number of arguments (`...`).</summary>
                kNoVarArgs = 255
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncSignature> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncSignature>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncSignature __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncSignature(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncSignature __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FuncSignature.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncSignature(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FuncSignature.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncSignature.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.FuncSignature.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private FuncSignature(global::GraphEngine.Jit.Native.Asmjit.FuncSignature.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FuncSignature(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public FuncSignature()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncSignature.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public FuncSignature(global::GraphEngine.Jit.Native.Asmjit.FuncSignature _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncSignature.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.FuncSignature.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.FuncSignature.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.FuncSignature __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Initialize the function signature.</summary>
            public void Init(uint ccId, uint ret, byte* args, uint argCount)
            {
                __Internal.Init((__Instance + __PointerAdjustment), ccId, ret, args, argCount);
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Get the type of the argument at index `i`.</summary>
            public uint GetArg(uint i)
            {
                var __ret = __Internal.GetArg((__Instance + __PointerAdjustment), i);
                return __ret;
            }

            /// <summary>Get the function's calling convention.</summary>
            public uint CallConv
            {
                get
                {
                    var __ret = __Internal.GetCallConv((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the function has variable number of arguments (...).</summary>
            public bool HasVarArgs
            {
                get
                {
                    var __ret = __Internal.HasVarArgs((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the variable arguments (...) index, `kNoVarArgs` if none.</summary>
            public uint VAIndex
            {
                get
                {
                    var __ret = __Internal.GetVAIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the number of function arguments.</summary>
            public uint ArgCount
            {
                get
                {
                    var __ret = __Internal.GetArgCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasRet
            {
                get
                {
                    var __ret = __Internal.HasRet((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the return value type.</summary>
            public uint Ret
            {
                get
                {
                    var __ret = __Internal.GetRet((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the array of function arguments' types.</summary>
            public byte* Args
            {
                get
                {
                    var __ret = __Internal.GetArgs((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Dynamic function signature.</summary>
        public unsafe partial class FuncSignatureX : global::GraphEngine.Jit.Native.Asmjit.FuncSignature, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal byte _callConv;

                [FieldOffset(1)]
                internal byte _argCount;

                [FieldOffset(2)]
                internal byte _vaIndex;

                [FieldOffset(3)]
                internal byte _ret;

                [FieldOffset(8)]
                internal global::System.IntPtr _args;

                [FieldOffset(16)]
                internal fixed byte _builderArgList[16];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncSignatureX@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint ccId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncSignatureX@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setCallConv@FuncSignatureX@asmjit@@QEAAXI@Z")]
                internal static extern void SetCallConv(global::System.IntPtr instance, uint ccId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setRet@FuncSignatureX@asmjit@@QEAAXI@Z")]
                internal static extern void SetRet(global::System.IntPtr instance, uint retType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setArg@FuncSignatureX@asmjit@@QEAAXII@Z")]
                internal static extern void SetArg(global::System.IntPtr instance, uint i, uint type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addArg@FuncSignatureX@asmjit@@QEAAXI@Z")]
                internal static extern void AddArg(global::System.IntPtr instance, uint type);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private FuncSignatureX(global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FuncSignatureX(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public FuncSignatureX(uint ccId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), ccId);
            }

            public FuncSignatureX(global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.FuncSignatureX.__Internal*) _0.__Instance);
            }

            public void SetCallConv(uint ccId)
            {
                __Internal.SetCallConv((__Instance + __PointerAdjustment), ccId);
            }

            /// <summary>Set the return type to `retType`.</summary>
            public void SetRet(uint retType)
            {
                __Internal.SetRet((__Instance + __PointerAdjustment), retType);
            }

            /// <summary>Set the argument at index `i` to the `type`</summary>
            public void SetArg(uint i, uint type)
            {
                __Internal.SetArg((__Instance + __PointerAdjustment), i, type);
            }

            /// <summary>Append an argument of `type` to the function prototype.</summary>
            public void AddArg(uint type)
            {
                __Internal.AddArg((__Instance + __PointerAdjustment), type);
            }
        }

        /// <summary>Function detail - CallConv and expanded FuncSignature.</summary>
        /// <remarks>
        /// <para>Function details is architecture and OS dependent representation of function.</para>
        /// <para>It contains calling convention and expanded function signature so all</para>
        /// <para>arguments have assigned either register type&amp;id or stack address.</para>
        /// </remarks>
        public unsafe partial class FuncDetail : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 232)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.CallConv.__Internal _callConv;

                [FieldOffset(72)]
                internal byte _argCount;

                [FieldOffset(73)]
                internal byte _retCount;

                [FieldOffset(76)]
                internal fixed uint _usedRegs[4];

                [FieldOffset(92)]
                internal uint _argStackSize;

                [FieldOffset(96)]
                internal fixed byte _rets[8];

                [FieldOffset(104)]
                internal fixed byte _args[128];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncDetail@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncDetail@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@FuncDetail@asmjit@@QEAAIAEBUFuncSignature@2@@Z")]
                internal static extern uint Init(global::System.IntPtr instance, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@FuncDetail@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasFlag@FuncDetail@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasFlag(global::System.IntPtr instance, uint ccFlag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRet@FuncDetail@asmjit@@QEAAAEAUValue@12@_K@Z")]
                internal static extern global::System.IntPtr GetRet(global::System.IntPtr instance, ulong index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasArg@FuncDetail@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasArg(global::System.IntPtr instance, ulong index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArg@FuncDetail@asmjit@@QEAAAEAUValue@12@_K@Z")]
                internal static extern global::System.IntPtr GetArg(global::System.IntPtr instance, ulong index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetArg@FuncDetail@asmjit@@QEAAX_K@Z")]
                internal static extern void ResetArg(global::System.IntPtr instance, ulong index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPassedRegs@FuncDetail@asmjit@@QEBAII@Z")]
                internal static extern uint GetPassedRegs(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPreservedRegs@FuncDetail@asmjit@@QEBAII@Z")]
                internal static extern uint GetPreservedRegs(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUsedRegs@FuncDetail@asmjit@@QEBAII@Z")]
                internal static extern uint GetUsedRegs(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addUsedRegs@FuncDetail@asmjit@@QEAAXII@Z")]
                internal static extern void AddUsedRegs(global::System.IntPtr instance, uint kind, uint regs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCallConv@FuncDetail@asmjit@@QEBAAEBUCallConv@2@XZ")]
                internal static extern global::System.IntPtr GetCallConv(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFlags@FuncDetail@asmjit@@QEBAIXZ")]
                internal static extern uint GetFlags(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRetCount@FuncDetail@asmjit@@QEBAIXZ")]
                internal static extern uint GetRetCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArgCount@FuncDetail@asmjit@@QEBAIXZ")]
                internal static extern uint GetArgCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasRet@FuncDetail@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasRet(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArgs@FuncDetail@asmjit@@QEAAPEAUValue@12@XZ")]
                internal static extern global::System.IntPtr GetArgs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasStackArgs@FuncDetail@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasStackArgs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArgStackSize@FuncDetail@asmjit@@QEBAIXZ")]
                internal static extern uint GetArgStackSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getNaturalStackAlignment@FuncDetail@asmjit@@QEBAIXZ")]
                internal static extern uint GetNaturalStackAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSpillZoneSize@FuncDetail@asmjit@@QEBAIXZ")]
                internal static extern uint GetSpillZoneSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRedZoneSize@FuncDetail@asmjit@@QEBAIXZ")]
                internal static extern uint GetRedZoneSize(global::System.IntPtr instance);
            }

            [Flags]
            public enum Limits : uint
            {
                kMaxVRegKinds = 4
            }

            /// <summary>
            /// <para>Argument or return value as defined by `FuncSignature`, but with register</para>
            /// <para>or stack address (and other metadata) assigned.</para>
            /// </summary>
            public unsafe partial class Value : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint _value;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Value@FuncDetail@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?initTypeId@Value@FuncDetail@asmjit@@QEAAXI@Z")]
                    internal static extern void InitTypeId(global::System.IntPtr instance, uint typeId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?initReg@Value@FuncDetail@asmjit@@QEAAXIII@Z")]
                    internal static extern void InitReg(global::System.IntPtr instance, uint typeId, uint regType, uint regId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?initStack@Value@FuncDetail@asmjit@@QEAAXII@Z")]
                    internal static extern void InitStack(global::System.IntPtr instance, uint typeId, uint stackOffset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?reset@Value@FuncDetail@asmjit@@QEAAXXZ")]
                    internal static extern void Reset(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?assignToReg@Value@FuncDetail@asmjit@@QEAAXII@Z")]
                    internal static extern void AssignToReg(global::System.IntPtr instance, uint regType, uint regId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?assignToStack@Value@FuncDetail@asmjit@@QEAAXH@Z")]
                    internal static extern void AssignToStack(global::System.IntPtr instance, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isInitialized@Value@FuncDetail@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsInitialized(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byReg@Value@FuncDetail@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool ByReg(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byStack@Value@FuncDetail@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool ByStack(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isAssigned@Value@FuncDetail@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsAssigned(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isIndirect@Value@FuncDetail@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsIndirect(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypeId@Value@FuncDetail@asmjit@@QEBAIXZ")]
                    internal static extern uint GetTypeId(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getRegType@Value@FuncDetail@asmjit@@QEBAIXZ")]
                    internal static extern uint GetRegType(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getRegId@Value@FuncDetail@asmjit@@QEBAIXZ")]
                    internal static extern uint GetRegId(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getStackOffset@Value@FuncDetail@asmjit@@QEBAHXZ")]
                    internal static extern int GetStackOffset(global::System.IntPtr instance);
                }

                public enum Parts : uint
                {
                    kTypeIdShift = 24,
                    kTypeIdMask = 0xff000000,
                    kRegTypeShift = 8,
                    kRegTypeMask = 0xff00,
                    kRegIdShift = 0,
                    kRegIdMask = 0xff,
                    kStackOffsetShift = 0,
                    kStackOffsetMask = 0xffff,
                    kIsByReg = 0x10000,
                    kIsByStack = 0x20000,
                    kIsIndirect = 0x40000
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Value(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Value(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Value()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Value(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                /// <summary>Initialize this in/out by a given `typeId`.</summary>
                public void InitTypeId(uint typeId)
                {
                    __Internal.InitTypeId((__Instance + __PointerAdjustment), typeId);
                }

                /// <summary>Initialize this in/out by a given `typeId`, `regType`, and `regId`.</summary>
                public void InitReg(uint typeId, uint regType, uint regId)
                {
                    __Internal.InitReg((__Instance + __PointerAdjustment), typeId, regType, regId);
                }

                /// <summary>Initialize this in/out by a given `typeId` and `offset`.</summary>
                public void InitStack(uint typeId, uint stackOffset)
                {
                    __Internal.InitStack((__Instance + __PointerAdjustment), typeId, stackOffset);
                }

                /// <summary>Reset the value to its uninitialized and unassigned state.</summary>
                public void Reset()
                {
                    __Internal.Reset((__Instance + __PointerAdjustment));
                }

                public void AssignToReg(uint regType, uint regId)
                {
                    __Internal.AssignToReg((__Instance + __PointerAdjustment), regType, regId);
                }

                public void AssignToStack(int offset)
                {
                    __Internal.AssignToStack((__Instance + __PointerAdjustment), offset);
                }

                /// <summary>Get if this value is initialized (i.e. contains a valid data).</summary>
                public bool IsInitialized
                {
                    get
                    {
                        var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if this argument is passed by register.</summary>
                public bool ByReg
                {
                    get
                    {
                        var __ret = __Internal.ByReg((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if this argument is passed by stack.</summary>
                public bool ByStack
                {
                    get
                    {
                        var __ret = __Internal.ByStack((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if this argument is passed by register.</summary>
                public bool IsAssigned
                {
                    get
                    {
                        var __ret = __Internal.IsAssigned((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if this argument is passed through a pointer (used by WIN64 to pass XMM|YMM|ZMM).</summary>
                public bool IsIndirect
                {
                    get
                    {
                        var __ret = __Internal.IsIndirect((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get virtual type of this argument or return value.</summary>
                public uint TypeId
                {
                    get
                    {
                        var __ret = __Internal.GetTypeId((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get a register type of the register used to pass the argument or return the value.</summary>
                public uint RegType
                {
                    get
                    {
                        var __ret = __Internal.GetRegType((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get a physical id of the register used to pass the argument or return the value.</summary>
                public uint RegId
                {
                    get
                    {
                        var __ret = __Internal.GetRegId((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get a stack offset of this argument (always positive).</summary>
                public int StackOffset
                {
                    get
                    {
                        var __ret = __Internal.GetStackOffset((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncDetail> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncDetail>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncDetail __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncDetail(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncDetail __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncDetail(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private FuncDetail(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FuncDetail(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public FuncDetail()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public FuncDetail(global::GraphEngine.Jit.Native.Asmjit.FuncDetail other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.FuncDetail __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Initialize this `FuncDetail` to the given signature.</summary>
            public uint Init(global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = sign.__Instance;
                var __ret = __Internal.Init((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Check if a CallConv `flag` is set, see</summary>
            public bool HasFlag(uint ccFlag)
            {
                var __ret = __Internal.HasFlag((__Instance + __PointerAdjustment), ccFlag);
                return __ret;
            }

            /// <summary>Get function return value.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value GetRet(ulong index)
            {
                var __ret = __Internal.GetRet((__Instance + __PointerAdjustment), index);
                global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value) global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__CreateInstance(__ret);
                return __result0;
            }

            public bool HasArg(ulong index)
            {
                var __ret = __Internal.HasArg((__Instance + __PointerAdjustment), index);
                return __ret;
            }

            /// <summary>Get function argument at index `index`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value GetArg(ulong index)
            {
                var __ret = __Internal.GetArg((__Instance + __PointerAdjustment), index);
                global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value) global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__CreateInstance(__ret);
                return __result0;
            }

            public void ResetArg(ulong index)
            {
                __Internal.ResetArg((__Instance + __PointerAdjustment), index);
            }

            public uint GetPassedRegs(uint kind)
            {
                var __ret = __Internal.GetPassedRegs((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            public uint GetPreservedRegs(uint kind)
            {
                var __ret = __Internal.GetPreservedRegs((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            public uint GetUsedRegs(uint kind)
            {
                var __ret = __Internal.GetUsedRegs((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            public void AddUsedRegs(uint kind, uint regs)
            {
                __Internal.AddUsedRegs((__Instance + __PointerAdjustment), kind, regs);
            }

            /// <summary>Get the function's calling convention, see `CallConv`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CallConv CallConv
            {
                get
                {
                    var __ret = __Internal.GetCallConv((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CallConv __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CallConv.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CallConv) global::GraphEngine.Jit.Native.Asmjit.CallConv.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CallConv.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get CallConv flags, see</summary>
            public uint Flags
            {
                get
                {
                    var __ret = __Internal.GetFlags((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get count of function return values.</summary>
            public uint RetCount
            {
                get
                {
                    var __ret = __Internal.GetRetCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the number of function arguments.</summary>
            public uint ArgCount
            {
                get
                {
                    var __ret = __Internal.GetArgCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the function has a return value.</summary>
            public bool HasRet
            {
                get
                {
                    var __ret = __Internal.HasRet((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get function arguments array.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value Args
            {
                get
                {
                    var __ret = __Internal.GetArgs((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value) global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.FuncDetail.Value.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get if the function passes one or more argument by stack.</summary>
            public bool HasStackArgs
            {
                get
                {
                    var __ret = __Internal.HasStackArgs((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get stack size needed for function arguments passed on the stack.</summary>
            public uint ArgStackSize
            {
                get
                {
                    var __ret = __Internal.GetArgStackSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint NaturalStackAlignment
            {
                get
                {
                    var __ret = __Internal.GetNaturalStackAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint SpillZoneSize
            {
                get
                {
                    var __ret = __Internal.GetSpillZoneSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint RedZoneSize
            {
                get
                {
                    var __ret = __Internal.GetRedZoneSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Function-frame information.</summary>
        /// <remarks>
        /// <para>This structure can be used to create a function frame in a cross-platform</para>
        /// <para>way. It contains information about the function's stack to be used and</para>
        /// <para>registers to be saved and restored. Based on this information in can</para>
        /// <para>calculate the optimal layout of a function as</para>
        /// </remarks>
        public unsafe partial class FuncFrameInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint _attributes;

                [FieldOffset(4)]
                internal fixed uint _dirtyRegs[4];

                [FieldOffset(20)]
                internal byte _stackFrameAlignment;

                [FieldOffset(21)]
                internal byte _callFrameAlignment;

                [FieldOffset(22)]
                internal byte _stackArgsRegId;

                [FieldOffset(24)]
                internal uint _stackFrameSize;

                [FieldOffset(28)]
                internal uint _callFrameSize;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncFrameInfo@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncFrameInfo@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAttribute@FuncFrameInfo@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAttribute(global::System.IntPtr instance, uint attr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addAttributes@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void AddAttributes(global::System.IntPtr instance, uint attrs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearAttributes@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void ClearAttributes(global::System.IntPtr instance, uint attrs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?enablePreservedFP@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void EnablePreservedFP(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?disablePreservedFP@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void DisablePreservedFP(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?enableCompactPE@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void EnableCompactPE(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?disableCompactPE@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void DisableCompactPE(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?enableCalls@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void EnableCalls(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?disableCalls@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void DisableCalls(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?enableMmxCleanup@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void EnableMmxCleanup(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?disableMmxCleanup@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void DisableMmxCleanup(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?enableAvxCleanup@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void EnableAvxCleanup(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?disableAvxCleanup@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void DisableAvxCleanup(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?enableAvx@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void EnableAvx(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?disableAvx@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void DisableAvx(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getDirtyRegs@FuncFrameInfo@asmjit@@QEBAII@Z")]
                internal static extern uint GetDirtyRegs(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setDirtyRegs@FuncFrameInfo@asmjit@@QEAAXII@Z")]
                internal static extern void SetDirtyRegs(global::System.IntPtr instance, uint kind, uint regs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addDirtyRegs@FuncFrameInfo@asmjit@@QEAAXII@Z")]
                internal static extern void AddDirtyRegs(global::System.IntPtr instance, uint kind, uint regs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setAllDirty@FuncFrameInfo@asmjit@@QEAAXXZ")]
                internal static extern void SetAllDirty(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setAllDirty@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void SetAllDirty(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?mergeStackFrameSize@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void MergeStackFrameSize(global::System.IntPtr instance, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?mergeCallFrameSize@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void MergeCallFrameSize(global::System.IntPtr instance, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?mergeStackFrameAlignment@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void MergeStackFrameAlignment(global::System.IntPtr instance, uint value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?mergeCallFrameAlignment@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void MergeCallFrameAlignment(global::System.IntPtr instance, uint value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackFrameSize@FuncFrameInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackFrameSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setStackFrameSize@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void SetStackFrameSize(global::System.IntPtr instance, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCallFrameSize@FuncFrameInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetCallFrameSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setCallFrameSize@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void SetCallFrameSize(global::System.IntPtr instance, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackFrameAlignment@FuncFrameInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackFrameAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setStackFrameAlignment@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void SetStackFrameAlignment(global::System.IntPtr instance, uint value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCallFrameAlignment@FuncFrameInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetCallFrameAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setCallFrameAlignment@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void SetCallFrameAlignment(global::System.IntPtr instance, uint value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackArgsRegId@FuncFrameInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackArgsRegId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setStackArgsRegId@FuncFrameInfo@asmjit@@QEAAXI@Z")]
                internal static extern void SetStackArgsRegId(global::System.IntPtr instance, uint regId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAttributes@FuncFrameInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetAttributes(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasPreservedFP@FuncFrameInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasPreservedFP(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasCompactPE@FuncFrameInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasCompactPE(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasCalls@FuncFrameInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasCalls(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasMmxCleanup@FuncFrameInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasMmxCleanup(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAvxCleanup@FuncFrameInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAvxCleanup(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isAvxEnabled@FuncFrameInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAvxEnabled(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasStackArgsRegId@FuncFrameInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasStackArgsRegId(global::System.IntPtr instance);
            }

            [Flags]
            public enum Limits : uint
            {
                kMaxVRegKinds = 4
            }

            /// <summary>Attributes.</summary>
            /// <remarks>
            /// <para>Attributes are designed in a way that all are initially false, and user</para>
            /// <para>or function-frame finalizer sets them when necessary. Architecture-specific</para>
            /// <para>attributes are prefixed with the architecture name.</para>
            /// </remarks>
            [Flags]
            public enum Attributes : uint
            {
                /// <summary>Preserve frame pointer (EBP|RBP).</summary>
                kAttrPreserveFP = 0x1,
                /// <summary>Use smaller, but possibly slower prolog/epilog.</summary>
                kAttrCompactPE = 0x2,
                /// <summary>Function calls other functions (is not leaf).</summary>
                kAttrHasCalls = 0x4,
                /// <summary>Use aligned save/restore of VEC regs.</summary>
                kX86AttrAlignedVecSR = 0x10000,
                /// <summary>Emit EMMS instruction in epilog (X86).</summary>
                kX86AttrMmxCleanup = 0x20000,
                /// <summary>Emit VZEROUPPER instruction in epilog (X86).</summary>
                kX86AttrAvxCleanup = 0x40000,
                /// <summary>Use AVX instead of SSE for all operations (X86).</summary>
                kX86AttrAvxEnabled = 0x80000
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private FuncFrameInfo(global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FuncFrameInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public FuncFrameInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public FuncFrameInfo(global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Check if a frame-info `flag` is set, see</summary>
            public bool HasAttribute(uint attr)
            {
                var __ret = __Internal.HasAttribute((__Instance + __PointerAdjustment), attr);
                return __ret;
            }

            /// <summary>Add `flags` to the frame-info, see</summary>
            public void AddAttributes(uint attrs)
            {
                __Internal.AddAttributes((__Instance + __PointerAdjustment), attrs);
            }

            /// <summary>Clear `flags` from the frame-info, see</summary>
            public void ClearAttributes(uint attrs)
            {
                __Internal.ClearAttributes((__Instance + __PointerAdjustment), attrs);
            }

            /// <summary>Enable preserved frame pointer.</summary>
            public void EnablePreservedFP()
            {
                __Internal.EnablePreservedFP((__Instance + __PointerAdjustment));
            }

            /// <summary>Disable preserved frame pointer.</summary>
            public void DisablePreservedFP()
            {
                __Internal.DisablePreservedFP((__Instance + __PointerAdjustment));
            }

            /// <summary>Enable compact prolog/epilog.</summary>
            public void EnableCompactPE()
            {
                __Internal.EnableCompactPE((__Instance + __PointerAdjustment));
            }

            /// <summary>Disable compact prolog/epilog.</summary>
            public void DisableCompactPE()
            {
                __Internal.DisableCompactPE((__Instance + __PointerAdjustment));
            }

            /// <summary>Set `kFlagHasCalls` to true.</summary>
            public void EnableCalls()
            {
                __Internal.EnableCalls((__Instance + __PointerAdjustment));
            }

            /// <summary>Set `kFlagHasCalls` to false.</summary>
            public void DisableCalls()
            {
                __Internal.DisableCalls((__Instance + __PointerAdjustment));
            }

            /// <summary>Enable MMX cleanup.</summary>
            public void EnableMmxCleanup()
            {
                __Internal.EnableMmxCleanup((__Instance + __PointerAdjustment));
            }

            /// <summary>Disable MMX cleanup.</summary>
            public void DisableMmxCleanup()
            {
                __Internal.DisableMmxCleanup((__Instance + __PointerAdjustment));
            }

            /// <summary>Enable AVX cleanup.</summary>
            public void EnableAvxCleanup()
            {
                __Internal.EnableAvxCleanup((__Instance + __PointerAdjustment));
            }

            /// <summary>Disable AVX cleanup.</summary>
            public void DisableAvxCleanup()
            {
                __Internal.DisableAvxCleanup((__Instance + __PointerAdjustment));
            }

            /// <summary>Enable AVX cleanup.</summary>
            public void EnableAvx()
            {
                __Internal.EnableAvx((__Instance + __PointerAdjustment));
            }

            /// <summary>Disable AVX cleanup.</summary>
            public void DisableAvx()
            {
                __Internal.DisableAvx((__Instance + __PointerAdjustment));
            }

            /// <summary>Get which registers (by `kind`) are saved/restored in prolog/epilog, respectively.</summary>
            public uint GetDirtyRegs(uint kind)
            {
                var __ret = __Internal.GetDirtyRegs((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            /// <summary>Set which registers (by `kind`) are saved/restored in prolog/epilog, respectively.</summary>
            public void SetDirtyRegs(uint kind, uint regs)
            {
                __Internal.SetDirtyRegs((__Instance + __PointerAdjustment), kind, regs);
            }

            /// <summary>Add registers (by `kind`) to saved/restored registers.</summary>
            public void AddDirtyRegs(uint kind, uint regs)
            {
                __Internal.AddDirtyRegs((__Instance + __PointerAdjustment), kind, regs);
            }

            public void SetAllDirty()
            {
                __Internal.SetAllDirty((__Instance + __PointerAdjustment));
            }

            public void SetAllDirty(uint kind)
            {
                __Internal.SetAllDirty((__Instance + __PointerAdjustment), kind);
            }

            public void MergeStackFrameSize(uint size)
            {
                __Internal.MergeStackFrameSize((__Instance + __PointerAdjustment), size);
            }

            public void MergeCallFrameSize(uint size)
            {
                __Internal.MergeCallFrameSize((__Instance + __PointerAdjustment), size);
            }

            public void MergeStackFrameAlignment(uint value)
            {
                __Internal.MergeStackFrameAlignment((__Instance + __PointerAdjustment), value);
            }

            public void MergeCallFrameAlignment(uint value)
            {
                __Internal.MergeCallFrameAlignment((__Instance + __PointerAdjustment), value);
            }

            /// <summary>Get stack-frame size used by the function.</summary>
            public uint StackFrameSize
            {
                get
                {
                    var __ret = __Internal.GetStackFrameSize((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetStackFrameSize((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get call-frame size used by the function.</summary>
            public uint CallFrameSize
            {
                get
                {
                    var __ret = __Internal.GetCallFrameSize((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetCallFrameSize((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get minimum stack-frame alignment required by the function.</summary>
            public uint StackFrameAlignment
            {
                get
                {
                    var __ret = __Internal.GetStackFrameAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetStackFrameAlignment((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get minimum call-frame alignment required by the function.</summary>
            public uint CallFrameAlignment
            {
                get
                {
                    var __ret = __Internal.GetCallFrameAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetCallFrameAlignment((__Instance + __PointerAdjustment), value);
                }
            }

            public uint StackArgsRegId
            {
                get
                {
                    var __ret = __Internal.GetStackArgsRegId((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetStackArgsRegId((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get frame-info flags, see</summary>
            public uint attributes
            {
                get
                {
                    var __ret = __Internal.GetAttributes((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the function preserves frame pointer (EBP|ESP on X86).</summary>
            public bool HasPreservedFP
            {
                get
                {
                    var __ret = __Internal.HasPreservedFP((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the function prolog and epilog should be compacted (as small as possible).</summary>
            public bool HasCompactPE
            {
                get
                {
                    var __ret = __Internal.HasCompactPE((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the function calls other functions.</summary>
            public bool HasCalls
            {
                get
                {
                    var __ret = __Internal.HasCalls((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the function contains MMX cleanup - 'emms' instruction in epilog.</summary>
            public bool HasMmxCleanup
            {
                get
                {
                    var __ret = __Internal.HasMmxCleanup((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the function contains AVX cleanup - 'vzeroupper' instruction in epilog.</summary>
            public bool HasAvxCleanup
            {
                get
                {
                    var __ret = __Internal.HasAvxCleanup((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the function contains AVX cleanup - 'vzeroupper' instruction in epilog.</summary>
            public bool IsAvxEnabled
            {
                get
                {
                    var __ret = __Internal.IsAvxEnabled((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasStackArgsRegId
            {
                get
                {
                    var __ret = __Internal.HasStackArgsRegId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Function-frame layout.</summary>
        /// <remarks>
        /// <para>Function layout is used directly by prolog and epilog insertion helpers. It</para>
        /// <para>contains only information necessary to insert proper prolog and epilog, and</para>
        /// <para>should be always calculated from</para>
        /// <para>FuncFrameInfo specifies how much stack is used, and which registers are dirty.</para>
        /// </remarks>
        public unsafe partial class FuncFrameLayout : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 60)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal byte _stackAlignment;

                [FieldOffset(1)]
                internal byte _stackBaseRegId;

                [FieldOffset(2)]
                internal byte _stackArgsRegId;

                [FieldOffset(4)]
                internal fixed uint _savedRegs[4];

                [FieldOffset(20)]
                internal uint _preservedFP;

                [FieldOffset(20)]
                internal uint _dsaSlotUsed;

                [FieldOffset(20)]
                internal uint _alignedVecSR;

                [FieldOffset(20)]
                internal uint _dynamicAlignment;

                [FieldOffset(20)]
                internal uint _mmxCleanup;

                [FieldOffset(20)]
                internal uint _avxCleanup;

                [FieldOffset(20)]
                internal uint _avxEnabled;

                [FieldOffset(24)]
                internal uint _stackSize;

                [FieldOffset(28)]
                internal uint _stackBaseOffset;

                [FieldOffset(32)]
                internal uint _stackAdjustment;

                [FieldOffset(36)]
                internal uint _stackArgsOffset;

                [FieldOffset(40)]
                internal uint _dsaSlot;

                [FieldOffset(44)]
                internal ushort _calleeStackCleanup;

                [FieldOffset(46)]
                internal ushort _gpStackSize;

                [FieldOffset(48)]
                internal ushort _vecStackSize;

                [FieldOffset(52)]
                internal uint _gpStackOffset;

                [FieldOffset(56)]
                internal uint _vecStackOffset;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncFrameLayout@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@FuncFrameLayout@asmjit@@QEAAIAEBVFuncDetail@2@AEBUFuncFrameInfo@2@@Z")]
                internal static extern uint Init(global::System.IntPtr instance, global::System.IntPtr func, global::System.IntPtr ffi);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@FuncFrameLayout@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSavedRegs@FuncFrameLayout@asmjit@@QEBAII@Z")]
                internal static extern uint GetSavedRegs(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasPreservedFP@FuncFrameLayout@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasPreservedFP(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasDsaSlotUsed@FuncFrameLayout@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDsaSlotUsed(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAlignedVecSR@FuncFrameLayout@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAlignedVecSR(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasDynamicAlignment@FuncFrameLayout@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasDynamicAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasMmxCleanup@FuncFrameLayout@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasMmxCleanup(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAvxCleanup@FuncFrameLayout@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAvxCleanup(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isAvxEnabled@FuncFrameLayout@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAvxEnabled(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackSize@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackAlignment@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackBaseOffset@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackBaseOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGpStackSize@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetGpStackSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVecStackSize@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetVecStackSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGpStackOffset@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetGpStackOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVecStackOffset@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetVecStackOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackArgsRegId@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackArgsRegId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackArgsOffset@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackArgsOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasStackAdjustment@FuncFrameLayout@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasStackAdjustment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackAdjustment@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackAdjustment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasCalleeStackCleanup@FuncFrameLayout@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasCalleeStackCleanup(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCalleeStackCleanup@FuncFrameLayout@asmjit@@QEBAIXZ")]
                internal static extern uint GetCalleeStackCleanup(global::System.IntPtr instance);
            }

            [Flags]
            public enum Limits : uint
            {
                kMaxVRegKinds = 4
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private FuncFrameLayout(global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FuncFrameLayout(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public FuncFrameLayout()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public FuncFrameLayout(global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint Init(global::GraphEngine.Jit.Native.Asmjit.FuncDetail func, global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo ffi)
            {
                if (ReferenceEquals(func, null))
                    throw new global::System.ArgumentNullException("func", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = func.__Instance;
                if (ReferenceEquals(ffi, null))
                    throw new global::System.ArgumentNullException("ffi", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = ffi.__Instance;
                var __ret = __Internal.Init((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            public uint GetSavedRegs(uint kind)
            {
                var __ret = __Internal.GetSavedRegs((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            public bool HasPreservedFP
            {
                get
                {
                    var __ret = __Internal.HasPreservedFP((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasDsaSlotUsed
            {
                get
                {
                    var __ret = __Internal.HasDsaSlotUsed((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasAlignedVecSR
            {
                get
                {
                    var __ret = __Internal.HasAlignedVecSR((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasDynamicAlignment
            {
                get
                {
                    var __ret = __Internal.HasDynamicAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasMmxCleanup
            {
                get
                {
                    var __ret = __Internal.HasMmxCleanup((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasAvxCleanup
            {
                get
                {
                    var __ret = __Internal.HasAvxCleanup((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsAvxEnabled
            {
                get
                {
                    var __ret = __Internal.IsAvxEnabled((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get stack size.</summary>
            public uint StackSize
            {
                get
                {
                    var __ret = __Internal.GetStackSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get stack alignment.</summary>
            public uint StackAlignment
            {
                get
                {
                    var __ret = __Internal.GetStackAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the offset needed to access the function's stack (it skips call-stack).</summary>
            public uint StackBaseOffset
            {
                get
                {
                    var __ret = __Internal.GetStackBaseOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get stack size required to save GP registers.</summary>
            public uint GpStackSize
            {
                get
                {
                    var __ret = __Internal.GetGpStackSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get stack size required to save VEC registers.</summary>
            public uint VecStackSize
            {
                get
                {
                    var __ret = __Internal.GetVecStackSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint GpStackOffset
            {
                get
                {
                    var __ret = __Internal.GetGpStackOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint VecStackOffset
            {
                get
                {
                    var __ret = __Internal.GetVecStackOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint StackArgsRegId
            {
                get
                {
                    var __ret = __Internal.GetStackArgsRegId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint StackArgsOffset
            {
                get
                {
                    var __ret = __Internal.GetStackArgsOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasStackAdjustment
            {
                get
                {
                    var __ret = __Internal.HasStackAdjustment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint StackAdjustment
            {
                get
                {
                    var __ret = __Internal.GetStackAdjustment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasCalleeStackCleanup
            {
                get
                {
                    var __ret = __Internal.HasCalleeStackCleanup((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint CalleeStackCleanup
            {
                get
                {
                    var __ret = __Internal.GetCalleeStackCleanup((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Assign a physical register to each function argument.</summary>
        /// <remarks>
        /// <para>This is used to specify where each function argument should be shuffled</para>
        /// <para>or allocated (in case it's passed by stack).</para>
        /// </remarks>
        public unsafe partial class FuncArgsMapper : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 136)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _funcDetail;

                [FieldOffset(8)]
                internal fixed byte _args[128];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncArgsMapper@asmjit@@QEAA@PEBVFuncDetail@1@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr fd);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncArgsMapper@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@FuncArgsMapper@asmjit@@QEAAXPEBVFuncDetail@2@@Z")]
                internal static extern void Reset(global::System.IntPtr instance, global::System.IntPtr fd);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArg@FuncArgsMapper@asmjit@@QEAAAEAUValue@12@_K@Z")]
                internal static extern global::System.IntPtr GetArg(global::System.IntPtr instance, ulong index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isAssigned@FuncArgsMapper@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAssigned(global::System.IntPtr instance, ulong index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?assign@FuncArgsMapper@asmjit@@QEAAX_KAEBVReg@2@I@Z")]
                internal static extern void Assign(global::System.IntPtr instance, ulong index, global::System.IntPtr reg, uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?assignAll@FuncArgsMapper@asmjit@@QEAAXAEBVReg@2@@Z")]
                internal static extern void AssignAll(global::System.IntPtr instance, global::System.IntPtr a0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?assignAll@FuncArgsMapper@asmjit@@QEAAXAEBVReg@2@0@Z")]
                internal static extern void AssignAll(global::System.IntPtr instance, global::System.IntPtr a0, global::System.IntPtr a1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?assignAll@FuncArgsMapper@asmjit@@QEAAXAEBVReg@2@00@Z")]
                internal static extern void AssignAll(global::System.IntPtr instance, global::System.IntPtr a0, global::System.IntPtr a1, global::System.IntPtr a2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?assignAll@FuncArgsMapper@asmjit@@QEAAXAEBVReg@2@000@Z")]
                internal static extern void AssignAll(global::System.IntPtr instance, global::System.IntPtr a0, global::System.IntPtr a1, global::System.IntPtr a2, global::System.IntPtr a3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?assignAll@FuncArgsMapper@asmjit@@QEAAXAEBVReg@2@0000@Z")]
                internal static extern void AssignAll(global::System.IntPtr instance, global::System.IntPtr a0, global::System.IntPtr a1, global::System.IntPtr a2, global::System.IntPtr a3, global::System.IntPtr a4);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?assignAll@FuncArgsMapper@asmjit@@QEAAXAEBVReg@2@00000@Z")]
                internal static extern void AssignAll(global::System.IntPtr instance, global::System.IntPtr a0, global::System.IntPtr a1, global::System.IntPtr a2, global::System.IntPtr a3, global::System.IntPtr a4, global::System.IntPtr a5);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?assignAll@FuncArgsMapper@asmjit@@QEAAXAEBVReg@2@000000@Z")]
                internal static extern void AssignAll(global::System.IntPtr instance, global::System.IntPtr a0, global::System.IntPtr a1, global::System.IntPtr a2, global::System.IntPtr a3, global::System.IntPtr a4, global::System.IntPtr a5, global::System.IntPtr a6);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?assignAll@FuncArgsMapper@asmjit@@QEAAXAEBVReg@2@0000000@Z")]
                internal static extern void AssignAll(global::System.IntPtr instance, global::System.IntPtr a0, global::System.IntPtr a1, global::System.IntPtr a2, global::System.IntPtr a3, global::System.IntPtr a4, global::System.IntPtr a5, global::System.IntPtr a6, global::System.IntPtr a7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?updateFrameInfo@FuncArgsMapper@asmjit@@QEBAIAEAUFuncFrameInfo@2@@Z")]
                internal static extern uint UpdateFrameInfo(global::System.IntPtr instance, global::System.IntPtr ffi);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFuncDetail@FuncArgsMapper@asmjit@@QEBAPEBVFuncDetail@2@XZ")]
                internal static extern global::System.IntPtr GetFuncDetail(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setFuncDetail@FuncArgsMapper@asmjit@@QEAAXPEBVFuncDetail@2@@Z")]
                internal static extern void SetFuncDetail(global::System.IntPtr instance, global::System.IntPtr fd);
            }

            public unsafe partial class Value : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint _value;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Value@FuncArgsMapper@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?assign@Value@FuncArgsMapper@asmjit@@QEAAXIII@Z")]
                    internal static extern void Assign(global::System.IntPtr instance, uint typeId, uint regType, uint regId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?reset@Value@FuncArgsMapper@asmjit@@QEAAXXZ")]
                    internal static extern void Reset(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isAssigned@Value@FuncArgsMapper@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsAssigned(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypeId@Value@FuncArgsMapper@asmjit@@QEBAIXZ")]
                    internal static extern uint GetTypeId(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getRegType@Value@FuncArgsMapper@asmjit@@QEBAIXZ")]
                    internal static extern uint GetRegType(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getRegId@Value@FuncArgsMapper@asmjit@@QEBAIXZ")]
                    internal static extern uint GetRegId(global::System.IntPtr instance);
                }

                public enum Parts : uint
                {
                    kTypeIdShift = 24,
                    kTypeIdMask = 0xff000000,
                    kRegTypeShift = 8,
                    kRegTypeMask = 0xff00,
                    kRegIdShift = 0,
                    kRegIdMask = 0xff,
                    kIsAssigned = 0x10000
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Value(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Value(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Value()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Value(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                /// <summary>Initialize this in/out by a given `typeId`, `regType`, and `regId`.</summary>
                public void Assign(uint typeId, uint regType, uint regId)
                {
                    __Internal.Assign((__Instance + __PointerAdjustment), typeId, regType, regId);
                }

                /// <summary>Reset the value to its unassigned state.</summary>
                public void Reset()
                {
                    __Internal.Reset((__Instance + __PointerAdjustment));
                }

                /// <summary>Get if this value is initialized (i.e. contains a valid data).</summary>
                public bool IsAssigned
                {
                    get
                    {
                        var __ret = __Internal.IsAssigned((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get virtual type of this argument or return value.</summary>
                public uint TypeId
                {
                    get
                    {
                        var __ret = __Internal.GetTypeId((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get a register type of the register used to pass the argument or return the value.</summary>
                public uint RegType
                {
                    get
                    {
                        var __ret = __Internal.GetRegType((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get a physical id of the register used to pass the argument or return the value.</summary>
                public uint RegId
                {
                    get
                    {
                        var __ret = __Internal.GetRegId((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private FuncArgsMapper(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FuncArgsMapper(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public FuncArgsMapper(global::GraphEngine.Jit.Native.Asmjit.FuncDetail fd)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(fd, null) ? global::System.IntPtr.Zero : fd.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            public FuncArgsMapper(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Reset(global::GraphEngine.Jit.Native.Asmjit.FuncDetail fd)
            {
                var __arg0 = ReferenceEquals(fd, null) ? global::System.IntPtr.Zero : fd.__Instance;
                __Internal.Reset((__Instance + __PointerAdjustment), __arg0);
            }

            public global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value GetArg(ulong index)
            {
                var __ret = __Internal.GetArg((__Instance + __PointerAdjustment), index);
                global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value) global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper.Value.__CreateInstance(__ret);
                return __result0;
            }

            public bool IsAssigned(ulong index)
            {
                var __ret = __Internal.IsAssigned((__Instance + __PointerAdjustment), index);
                return __ret;
            }

            public void Assign(ulong index, global::GraphEngine.Jit.Native.Asmjit.Reg reg, uint typeId)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = reg.__Instance;
                __Internal.Assign((__Instance + __PointerAdjustment), index, __arg1, typeId);
            }

            public void AssignAll(global::GraphEngine.Jit.Native.Asmjit.Reg a0)
            {
                if (ReferenceEquals(a0, null))
                    throw new global::System.ArgumentNullException("a0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = a0.__Instance;
                __Internal.AssignAll((__Instance + __PointerAdjustment), __arg0);
            }

            public void AssignAll(global::GraphEngine.Jit.Native.Asmjit.Reg a0, global::GraphEngine.Jit.Native.Asmjit.Reg a1)
            {
                if (ReferenceEquals(a0, null))
                    throw new global::System.ArgumentNullException("a0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = a0.__Instance;
                if (ReferenceEquals(a1, null))
                    throw new global::System.ArgumentNullException("a1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = a1.__Instance;
                __Internal.AssignAll((__Instance + __PointerAdjustment), __arg0, __arg1);
            }

            public void AssignAll(global::GraphEngine.Jit.Native.Asmjit.Reg a0, global::GraphEngine.Jit.Native.Asmjit.Reg a1, global::GraphEngine.Jit.Native.Asmjit.Reg a2)
            {
                if (ReferenceEquals(a0, null))
                    throw new global::System.ArgumentNullException("a0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = a0.__Instance;
                if (ReferenceEquals(a1, null))
                    throw new global::System.ArgumentNullException("a1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = a1.__Instance;
                if (ReferenceEquals(a2, null))
                    throw new global::System.ArgumentNullException("a2", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = a2.__Instance;
                __Internal.AssignAll((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            }

            public void AssignAll(global::GraphEngine.Jit.Native.Asmjit.Reg a0, global::GraphEngine.Jit.Native.Asmjit.Reg a1, global::GraphEngine.Jit.Native.Asmjit.Reg a2, global::GraphEngine.Jit.Native.Asmjit.Reg a3)
            {
                if (ReferenceEquals(a0, null))
                    throw new global::System.ArgumentNullException("a0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = a0.__Instance;
                if (ReferenceEquals(a1, null))
                    throw new global::System.ArgumentNullException("a1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = a1.__Instance;
                if (ReferenceEquals(a2, null))
                    throw new global::System.ArgumentNullException("a2", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = a2.__Instance;
                if (ReferenceEquals(a3, null))
                    throw new global::System.ArgumentNullException("a3", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = a3.__Instance;
                __Internal.AssignAll((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            }

            public void AssignAll(global::GraphEngine.Jit.Native.Asmjit.Reg a0, global::GraphEngine.Jit.Native.Asmjit.Reg a1, global::GraphEngine.Jit.Native.Asmjit.Reg a2, global::GraphEngine.Jit.Native.Asmjit.Reg a3, global::GraphEngine.Jit.Native.Asmjit.Reg a4)
            {
                if (ReferenceEquals(a0, null))
                    throw new global::System.ArgumentNullException("a0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = a0.__Instance;
                if (ReferenceEquals(a1, null))
                    throw new global::System.ArgumentNullException("a1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = a1.__Instance;
                if (ReferenceEquals(a2, null))
                    throw new global::System.ArgumentNullException("a2", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = a2.__Instance;
                if (ReferenceEquals(a3, null))
                    throw new global::System.ArgumentNullException("a3", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = a3.__Instance;
                if (ReferenceEquals(a4, null))
                    throw new global::System.ArgumentNullException("a4", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = a4.__Instance;
                __Internal.AssignAll((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
            }

            public void AssignAll(global::GraphEngine.Jit.Native.Asmjit.Reg a0, global::GraphEngine.Jit.Native.Asmjit.Reg a1, global::GraphEngine.Jit.Native.Asmjit.Reg a2, global::GraphEngine.Jit.Native.Asmjit.Reg a3, global::GraphEngine.Jit.Native.Asmjit.Reg a4, global::GraphEngine.Jit.Native.Asmjit.Reg a5)
            {
                if (ReferenceEquals(a0, null))
                    throw new global::System.ArgumentNullException("a0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = a0.__Instance;
                if (ReferenceEquals(a1, null))
                    throw new global::System.ArgumentNullException("a1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = a1.__Instance;
                if (ReferenceEquals(a2, null))
                    throw new global::System.ArgumentNullException("a2", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = a2.__Instance;
                if (ReferenceEquals(a3, null))
                    throw new global::System.ArgumentNullException("a3", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = a3.__Instance;
                if (ReferenceEquals(a4, null))
                    throw new global::System.ArgumentNullException("a4", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = a4.__Instance;
                if (ReferenceEquals(a5, null))
                    throw new global::System.ArgumentNullException("a5", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = a5.__Instance;
                __Internal.AssignAll((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
            }

            public void AssignAll(global::GraphEngine.Jit.Native.Asmjit.Reg a0, global::GraphEngine.Jit.Native.Asmjit.Reg a1, global::GraphEngine.Jit.Native.Asmjit.Reg a2, global::GraphEngine.Jit.Native.Asmjit.Reg a3, global::GraphEngine.Jit.Native.Asmjit.Reg a4, global::GraphEngine.Jit.Native.Asmjit.Reg a5, global::GraphEngine.Jit.Native.Asmjit.Reg a6)
            {
                if (ReferenceEquals(a0, null))
                    throw new global::System.ArgumentNullException("a0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = a0.__Instance;
                if (ReferenceEquals(a1, null))
                    throw new global::System.ArgumentNullException("a1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = a1.__Instance;
                if (ReferenceEquals(a2, null))
                    throw new global::System.ArgumentNullException("a2", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = a2.__Instance;
                if (ReferenceEquals(a3, null))
                    throw new global::System.ArgumentNullException("a3", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = a3.__Instance;
                if (ReferenceEquals(a4, null))
                    throw new global::System.ArgumentNullException("a4", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = a4.__Instance;
                if (ReferenceEquals(a5, null))
                    throw new global::System.ArgumentNullException("a5", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = a5.__Instance;
                if (ReferenceEquals(a6, null))
                    throw new global::System.ArgumentNullException("a6", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = a6.__Instance;
                __Internal.AssignAll((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
            }

            public void AssignAll(global::GraphEngine.Jit.Native.Asmjit.Reg a0, global::GraphEngine.Jit.Native.Asmjit.Reg a1, global::GraphEngine.Jit.Native.Asmjit.Reg a2, global::GraphEngine.Jit.Native.Asmjit.Reg a3, global::GraphEngine.Jit.Native.Asmjit.Reg a4, global::GraphEngine.Jit.Native.Asmjit.Reg a5, global::GraphEngine.Jit.Native.Asmjit.Reg a6, global::GraphEngine.Jit.Native.Asmjit.Reg a7)
            {
                if (ReferenceEquals(a0, null))
                    throw new global::System.ArgumentNullException("a0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = a0.__Instance;
                if (ReferenceEquals(a1, null))
                    throw new global::System.ArgumentNullException("a1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = a1.__Instance;
                if (ReferenceEquals(a2, null))
                    throw new global::System.ArgumentNullException("a2", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = a2.__Instance;
                if (ReferenceEquals(a3, null))
                    throw new global::System.ArgumentNullException("a3", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = a3.__Instance;
                if (ReferenceEquals(a4, null))
                    throw new global::System.ArgumentNullException("a4", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = a4.__Instance;
                if (ReferenceEquals(a5, null))
                    throw new global::System.ArgumentNullException("a5", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = a5.__Instance;
                if (ReferenceEquals(a6, null))
                    throw new global::System.ArgumentNullException("a6", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = a6.__Instance;
                if (ReferenceEquals(a7, null))
                    throw new global::System.ArgumentNullException("a7", "Cannot be null because it is a C++ reference (&).");
                var __arg7 = a7.__Instance;
                __Internal.AssignAll((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7);
            }

            /// <summary>Update `FuncFrameInfo` accordingly to FuncArgsMapper.</summary>
            /// <remarks>
            /// <para>This method must be called if you use `FuncArgsMapper` and you plan to</para>
            /// <para>use `FuncUtils::allocArgs()` to remap all arguments after the prolog is</para>
            /// <para>inserted.</para>
            /// </remarks>
            public uint UpdateFrameInfo(global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo ffi)
            {
                if (ReferenceEquals(ffi, null))
                    throw new global::System.ArgumentNullException("ffi", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = ffi.__Instance;
                var __ret = __Internal.UpdateFrameInfo((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public global::GraphEngine.Jit.Native.Asmjit.FuncDetail FuncDetail
            {
                get
                {
                    var __ret = __Internal.GetFuncDetail((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.FuncDetail __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.FuncDetail.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.FuncDetail) global::GraphEngine.Jit.Native.Asmjit.FuncDetail.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__CreateInstance(__ret);
                    return __result0;
                }

                set
                {
                    var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    __Internal.SetFuncDetail((__Instance + __PointerAdjustment), __arg0);
                }
            }
        }

        public unsafe partial class FuncUtils : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FuncUtils@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emitProlog@FuncUtils@asmjit@@SAIPEAVCodeEmitter@2@AEBUFuncFrameLayout@2@@Z")]
                internal static extern uint EmitProlog(global::System.IntPtr emitter, global::System.IntPtr layout);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emitEpilog@FuncUtils@asmjit@@SAIPEAVCodeEmitter@2@AEBUFuncFrameLayout@2@@Z")]
                internal static extern uint EmitEpilog(global::System.IntPtr emitter, global::System.IntPtr layout);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?allocArgs@FuncUtils@asmjit@@SAIPEAVCodeEmitter@2@AEBUFuncFrameLayout@2@AEBVFuncArgsMapper@2@@Z")]
                internal static extern uint AllocArgs(global::System.IntPtr emitter, global::System.IntPtr layout, global::System.IntPtr args);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncUtils> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.FuncUtils>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncUtils __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncUtils(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.FuncUtils __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FuncUtils.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FuncUtils(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FuncUtils.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncUtils.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.FuncUtils.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private FuncUtils(global::GraphEngine.Jit.Native.Asmjit.FuncUtils.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FuncUtils(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public FuncUtils()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncUtils.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public FuncUtils(global::GraphEngine.Jit.Native.Asmjit.FuncUtils _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FuncUtils.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.FuncUtils.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.FuncUtils.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.FuncUtils __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static uint EmitProlog(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter emitter, global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout layout)
            {
                var __arg0 = ReferenceEquals(emitter, null) ? global::System.IntPtr.Zero : emitter.__Instance;
                if (ReferenceEquals(layout, null))
                    throw new global::System.ArgumentNullException("layout", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = layout.__Instance;
                var __ret = __Internal.EmitProlog(__arg0, __arg1);
                return __ret;
            }

            public static uint EmitEpilog(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter emitter, global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout layout)
            {
                var __arg0 = ReferenceEquals(emitter, null) ? global::System.IntPtr.Zero : emitter.__Instance;
                if (ReferenceEquals(layout, null))
                    throw new global::System.ArgumentNullException("layout", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = layout.__Instance;
                var __ret = __Internal.EmitEpilog(__arg0, __arg1);
                return __ret;
            }

            public static uint AllocArgs(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter emitter, global::GraphEngine.Jit.Native.Asmjit.FuncFrameLayout layout, global::GraphEngine.Jit.Native.Asmjit.FuncArgsMapper args)
            {
                var __arg0 = ReferenceEquals(emitter, null) ? global::System.IntPtr.Zero : emitter.__Instance;
                if (ReferenceEquals(layout, null))
                    throw new global::System.ArgumentNullException("layout", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = layout.__Instance;
                if (ReferenceEquals(args, null))
                    throw new global::System.ArgumentNullException("args", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = args.__Instance;
                var __ret = __Internal.AllocArgs(__arg0, __arg1, __arg2);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>\{</summary>
        public unsafe partial class CpuFeatures : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal fixed ulong _bits[2];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CpuFeatures@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CpuFeatures@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@CpuFeatures@asmjit@@QEAAXAEBV12@@Z")]
                internal static extern void Init(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@CpuFeatures@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?has@CpuFeatures@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Has(global::System.IntPtr instance, uint feature);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAll@CpuFeatures@asmjit@@QEBA_NAEBV12@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAll(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?add@CpuFeatures@asmjit@@QEAAAEAV12@I@Z")]
                internal static extern global::System.IntPtr Add(global::System.IntPtr instance, uint feature);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?remove@CpuFeatures@asmjit@@QEAAAEAV12@I@Z")]
                internal static extern global::System.IntPtr Remove(global::System.IntPtr instance, uint feature);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBits@CpuFeatures@asmjit@@QEAAPEA_KXZ")]
                internal static extern ulong* GetBits(global::System.IntPtr instance);
            }

            [Flags]
            public enum _0
            {
                kMaxFeatures = 128,
                kBitWordSize = 64,
                kNumBitWords = 2
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CpuFeatures> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CpuFeatures>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.CpuFeatures __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CpuFeatures(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CpuFeatures __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CpuFeatures(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private CpuFeatures(global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CpuFeatures(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CpuFeatures()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public CpuFeatures(global::GraphEngine.Jit.Native.Asmjit.CpuFeatures other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CpuFeatures __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Init(global::GraphEngine.Jit.Native.Asmjit.CpuFeatures other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Init((__Instance + __PointerAdjustment), __arg0);
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Get if feature `feature` is present.</summary>
            public bool Has(uint feature)
            {
                var __ret = __Internal.Has((__Instance + __PointerAdjustment), feature);
                return __ret;
            }

            /// <summary>Get if all features as defined by `other` are  present.</summary>
            public bool HasAll(global::GraphEngine.Jit.Native.Asmjit.CpuFeatures other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var __ret = __Internal.HasAll((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Add a CPU `feature`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CpuFeatures Add(uint feature)
            {
                var __ret = __Internal.Add((__Instance + __PointerAdjustment), feature);
                global::GraphEngine.Jit.Native.Asmjit.CpuFeatures __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CpuFeatures) global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Remove a CPU `feature`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CpuFeatures Remove(uint feature)
            {
                var __ret = __Internal.Remove((__Instance + __PointerAdjustment), feature);
                global::GraphEngine.Jit.Native.Asmjit.CpuFeatures __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CpuFeatures) global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Get all features as `BitWord` array.</summary>
            public ulong* Bits
            {
                get
                {
                    var __ret = __Internal.GetBits((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>CPU information.</summary>
        public unsafe partial class CpuInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 136)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal _archInfo;

                [FieldOffset(4)]
                internal uint _vendorId;

                [FieldOffset(8)]
                internal uint _family;

                [FieldOffset(12)]
                internal uint _model;

                [FieldOffset(16)]
                internal uint _stepping;

                [FieldOffset(20)]
                internal uint _hwThreadsCount;

                [FieldOffset(24)]
                internal global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__Internal _features;

                [FieldOffset(40)]
                internal fixed sbyte _vendorString[16];

                [FieldOffset(56)]
                internal fixed sbyte _brandString[64];

                [FieldOffset(120)]
                internal global::GraphEngine.Jit.Native.Asmjit.CpuInfo._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CpuInfo@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CpuInfo@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?initArch@CpuInfo@asmjit@@QEAAXII@Z")]
                internal static extern void InitArch(global::System.IntPtr instance, uint archType, uint archMode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@CpuInfo@asmjit@@QEAAXAEBV12@@Z")]
                internal static extern void Init(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@CpuInfo@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?detect@CpuInfo@asmjit@@QEAAXXZ")]
                internal static extern void Detect(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasFeature@CpuInfo@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasFeature(global::System.IntPtr instance, uint feature);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addFeature@CpuInfo@asmjit@@QEAAAEAV12@I@Z")]
                internal static extern global::System.IntPtr AddFeature(global::System.IntPtr instance, uint feature);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchInfo@CpuInfo@asmjit@@QEBAAEBVArchInfo@2@XZ")]
                internal static extern global::System.IntPtr GetArchInfo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchType@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchSubType@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchSubType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVendorId@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetVendorId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFamily@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetFamily(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getModel@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetModel(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStepping@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetStepping(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getHwThreadsCount@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetHwThreadsCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFeatures@CpuInfo@asmjit@@QEBAAEBVCpuFeatures@2@XZ")]
                internal static extern global::System.IntPtr GetFeatures(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVendorString@CpuInfo@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetVendorString(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBrandString@CpuInfo@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetBrandString(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getX86ProcessorType@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetX86ProcessorType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getX86BrandIndex@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetX86BrandIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getX86FlushCacheLineSize@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetX86FlushCacheLineSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getX86MaxLogicalProcessors@CpuInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetX86MaxLogicalProcessors(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getHost@CpuInfo@asmjit@@SAAEBV12@XZ")]
                internal static extern global::System.IntPtr GetHost();
            }

            /// <summary>CPU vendor ID.</summary>
            public enum Vendor : uint
            {
                /// <summary>Generic or unknown.</summary>
                kVendorNone = 0,
                /// <summary>Intel vendor.</summary>
                kVendorIntel = 1,
                /// <summary>AMD vendor.</summary>
                kVendorAMD = 2,
                /// <summary>VIA vendor.</summary>
                kVendorVIA = 3
            }

            /// <summary>ARM/ARM64 CPU features.</summary>
            public enum ArmFeatures : uint
            {
                /// <summary>ARMv6 instruction set.</summary>
                kArmFeatureV6 = 1,
                /// <summary>ARMv7 instruction set.</summary>
                kArmFeatureV7 = 2,
                /// <summary>ARMv8 instruction set.</summary>
                kArmFeatureV8 = 3,
                /// <summary>CPU provides THUMB v1 instruction set (THUMB mode).</summary>
                kArmFeatureTHUMB = 4,
                /// <summary>CPU provides THUMB v2 instruction set (THUMB mode).</summary>
                kArmFeatureTHUMB2 = 5,
                /// <summary>CPU provides VFPv2 instruction set.</summary>
                kArmFeatureVFPv2 = 6,
                /// <summary>CPU provides VFPv3 instruction set.</summary>
                kArmFeatureVFPv3 = 7,
                /// <summary>CPU provides VFPv4 instruction set.</summary>
                kArmFeatureVFPv4 = 8,
                /// <summary>CPU provides 32 VFP-D (64-bit) registers.</summary>
                kArmFeatureVFP_D32 = 9,
                /// <summary>CPU provides EDSP extensions.</summary>
                kArmFeatureEDSP = 10,
                /// <summary>CPU provides 'Advanced SIMD'.</summary>
                kArmFeatureASIMD = 11,
                /// <summary>CPU provides hardware SDIV and UDIV (ARM mode).</summary>
                kArmFeatureIDIVA = 12,
                /// <summary>CPU provides hardware SDIV and UDIV (THUMB mode).</summary>
                kArmFeatureIDIVT = 13,
                /// <summary>CPU provides AES instructions (ARM64 only).</summary>
                kArmFeatureAES = 14,
                /// <summary>CPU provides CRC32 instructions.</summary>
                kArmFeatureCRC32 = 15,
                /// <summary>CPU provides PMULL instructions (ARM64 only).</summary>
                kArmFeaturePMULL = 16,
                /// <summary>CPU provides SHA1 instructions.</summary>
                kArmFeatureSHA1 = 17,
                /// <summary>CPU provides SHA256 instructions.</summary>
                kArmFeatureSHA256 = 18,
                /// <summary>CPU provides 64-bit load/store atomics (ARM64 only).</summary>
                kArmFeatureAtomics64 = 19,
                /// <summary>Count of ARM/ARM64 CPU features.</summary>
                kArmFeaturesCount = 20
            }

            /// <summary>X86/X64 CPU features.</summary>
            public enum X86Features : uint
            {
                /// <summary>CPU is at least I486.</summary>
                kX86FeatureI486 = 1,
                /// <summary>CPU has Not-Execute-Bit.</summary>
                kX86FeatureNX = 2,
                /// <summary>CPU has multi-threading.</summary>
                kX86FeatureMT = 3,
                /// <summary>CPU supports `LOCK MOV CR8` (AMD CPUs).</summary>
                kX86FeatureALTMOVCR8 = 4,
                /// <summary>CPU has CMOV.</summary>
                kX86FeatureCMOV = 5,
                /// <summary>CPU has CMPXCHG8B.</summary>
                kX86FeatureCMPXCHG8B = 6,
                /// <summary>CPU has CMPXCHG16B (x64).</summary>
                kX86FeatureCMPXCHG16B = 7,
                /// <summary>CPU has RDMSR/WRMSR.</summary>
                kX86FeatureMSR = 8,
                /// <summary>CPU has RDTSC.</summary>
                kX86FeatureRDTSC = 9,
                /// <summary>CPU has RDTSCP.</summary>
                kX86FeatureRDTSCP = 10,
                /// <summary>CPU has CLFUSH.</summary>
                kX86FeatureCLFLUSH = 11,
                /// <summary>CPU has CLFUSHOPT.</summary>
                kX86FeatureCLFLUSHOPT = 12,
                /// <summary>CPU has CLWB.</summary>
                kX86FeatureCLWB = 13,
                /// <summary>CPU has CLZERO.</summary>
                kX86FeatureCLZERO = 14,
                /// <summary>CPU has PCOMMIT.</summary>
                kX86FeaturePCOMMIT = 15,
                /// <summary>CPU has PREFETCHW.</summary>
                kX86FeaturePREFETCHW = 16,
                /// <summary>CPU has PREFETCHWT1.</summary>
                kX86FeaturePREFETCHWT1 = 17,
                /// <summary>CPU has LAHF/SAHF.</summary>
                kX86FeatureLAHFSAHF = 18,
                /// <summary>CPU has FXSAVE/FXRSTOR.</summary>
                kX86FeatureFXSR = 19,
                /// <summary>CPU has FXSAVE/FXRSTOR (optimized).</summary>
                kX86FeatureFXSROPT = 20,
                /// <summary>CPU has MMX.</summary>
                kX86FeatureMMX = 21,
                /// <summary>CPU has extended MMX.</summary>
                kX86FeatureMMX2 = 22,
                /// <summary>CPU has 3DNOW.</summary>
                kX86Feature3DNOW = 23,
                /// <summary>CPU has 3DNOW2 (enhanced).</summary>
                kX86Feature3DNOW2 = 24,
                /// <summary>CPU has GEODE extensions (few additions to 3DNOW).</summary>
                kX86FeatureGEODE = 25,
                /// <summary>CPU has SSE.</summary>
                kX86FeatureSSE = 26,
                /// <summary>CPU has SSE2.</summary>
                kX86FeatureSSE2 = 27,
                /// <summary>CPU has SSE3.</summary>
                kX86FeatureSSE3 = 28,
                /// <summary>CPU has SSSE3.</summary>
                kX86FeatureSSSE3 = 29,
                /// <summary>CPU has SSE4.A.</summary>
                kX86FeatureSSE4A = 30,
                /// <summary>CPU has SSE4.1.</summary>
                kX86FeatureSSE4_1 = 31,
                /// <summary>CPU has SSE4.2.</summary>
                kX86FeatureSSE4_2 = 32,
                /// <summary>CPU has Misaligned SSE (MSSE).</summary>
                kX86FeatureMSSE = 33,
                /// <summary>CPU has MONITOR and MWAIT.</summary>
                kX86FeatureMONITOR = 34,
                /// <summary>CPU has MOVBE.</summary>
                kX86FeatureMOVBE = 35,
                /// <summary>CPU has POPCNT.</summary>
                kX86FeaturePOPCNT = 36,
                /// <summary>CPU has LZCNT.</summary>
                kX86FeatureLZCNT = 37,
                /// <summary>CPU has AESNI.</summary>
                kX86FeatureAESNI = 38,
                /// <summary>CPU has PCLMULQDQ.</summary>
                kX86FeaturePCLMULQDQ = 39,
                /// <summary>CPU has RDRAND.</summary>
                kX86FeatureRDRAND = 40,
                /// <summary>CPU has RDSEED.</summary>
                kX86FeatureRDSEED = 41,
                /// <summary>CPU has SMAP (supervisor-mode access prevention).</summary>
                kX86FeatureSMAP = 42,
                /// <summary>CPU has SMEP (supervisor-mode execution prevention).</summary>
                kX86FeatureSMEP = 43,
                /// <summary>CPU has SHA-1 and SHA-256.</summary>
                kX86FeatureSHA = 44,
                /// <summary>CPU has XSAVE support (XSAVE/XRSTOR, XSETBV/XGETBV, and XCR).</summary>
                kX86FeatureXSAVE = 45,
                /// <summary>CPU has XSAVEC support (XSAVEC).</summary>
                kX86FeatureXSAVEC = 46,
                /// <summary>CPU has XSAVES support (XSAVES/XRSTORS).</summary>
                kX86FeatureXSAVES = 47,
                /// <summary>CPU has XSAVEOPT support (XSAVEOPT/XSAVEOPT64).</summary>
                kX86FeatureXSAVEOPT = 48,
                /// <summary>CPU has XSAVE enabled by OS.</summary>
                kX86FeatureOSXSAVE = 49,
                /// <summary>CPU has AVX.</summary>
                kX86FeatureAVX = 50,
                /// <summary>CPU has AVX2.</summary>
                kX86FeatureAVX2 = 51,
                /// <summary>CPU has F16C.</summary>
                kX86FeatureF16C = 52,
                /// <summary>CPU has FMA.</summary>
                kX86FeatureFMA = 53,
                /// <summary>CPU has FMA4.</summary>
                kX86FeatureFMA4 = 54,
                /// <summary>CPU has XOP.</summary>
                kX86FeatureXOP = 55,
                /// <summary>CPU has BMI (bit manipulation instructions #1).</summary>
                kX86FeatureBMI = 56,
                /// <summary>CPU has BMI2 (bit manipulation instructions #2).</summary>
                kX86FeatureBMI2 = 57,
                /// <summary>CPU has ADX (multi-precision add-carry instruction extensions).</summary>
                kX86FeatureADX = 58,
                /// <summary>CPU has TBM (trailing bit manipulation).</summary>
                kX86FeatureTBM = 59,
                /// <summary>CPU has MPX (memory protection extensions).</summary>
                kX86FeatureMPX = 60,
                /// <summary>CPU has HLE.</summary>
                kX86FeatureHLE = 61,
                /// <summary>CPU has RTM.</summary>
                kX86FeatureRTM = 62,
                /// <summary>CPU has TSX.</summary>
                kX86FeatureTSX = 63,
                /// <summary>CPU has ERMS (enhanced REP MOVSB/STOSB).</summary>
                kX86FeatureERMS = 64,
                /// <summary>CPU has FSGSBASE.</summary>
                kX86FeatureFSGSBASE = 65,
                /// <summary>CPU has AVX512-F (foundation).</summary>
                kX86FeatureAVX512F = 66,
                /// <summary>CPU has AVX512-CDI (conflict detection).</summary>
                kX86FeatureAVX512CDI = 67,
                /// <summary>CPU has AVX512-PFI (prefetch instructions).</summary>
                kX86FeatureAVX512PFI = 68,
                /// <summary>CPU has AVX512-ERI (exponential and reciprocal).</summary>
                kX86FeatureAVX512ERI = 69,
                /// <summary>CPU has AVX512-DQ (DWORD/QWORD).</summary>
                kX86FeatureAVX512DQ = 70,
                /// <summary>CPU has AVX512-BW (BYTE/WORD).</summary>
                kX86FeatureAVX512BW = 71,
                /// <summary>CPU has AVX512-VL (vector length extensions).</summary>
                kX86FeatureAVX512VL = 72,
                /// <summary>CPU has AVX512-IFMA (integer fused-multiply-add using 52-bit precision).</summary>
                kX86FeatureAVX512IFMA = 73,
                /// <summary>CPU has AVX512-VBMI (vector byte manipulation).</summary>
                kX86FeatureAVX512VBMI = 74,
                /// <summary>CPU has AVX512-VPOPCNTDQ (VPOPCNT[D|Q] instructions).</summary>
                kX86FeatureAVX512VPOPCNTDQ = 75,
                /// <summary>CPU has AVX512-VNNIW (vector NN instructions word variable precision).</summary>
                kX86FeatureAVX512_4VNNIW = 76,
                /// <summary>CPU has AVX512-FMAPS (FMA packed single).</summary>
                kX86FeatureAVX512_4FMAPS = 77,
                /// <summary>Count of X86/X64 CPU features.</summary>
                kX86FeaturesCount = 78
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal _armData;

                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal _x86Data;
                }
            }

            public unsafe partial class ArmData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ArmData@CpuInfo@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ArmData(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArmData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ArmData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public ArmData(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.CpuInfo.ArmData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class X86Data : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint _processorType;

                    [FieldOffset(4)]
                    internal uint _brandIndex;

                    [FieldOffset(8)]
                    internal uint _flushCacheLineSize;

                    [FieldOffset(12)]
                    internal uint _maxLogicalProcessors;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0X86Data@CpuInfo@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private X86Data(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected X86Data(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public X86Data()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public X86Data(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.CpuInfo.X86Data __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CpuInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CpuInfo>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.CpuInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CpuInfo(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CpuInfo __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CpuInfo(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.CpuInfo.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private CpuInfo(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CpuInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CpuInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public CpuInfo(global::GraphEngine.Jit.Native.Asmjit.CpuInfo other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CpuInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CpuInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Initialize CpuInfo to the given architecture, see</summary>
            public void InitArch(uint archType, uint archMode)
            {
                __Internal.InitArch((__Instance + __PointerAdjustment), archType, archMode);
            }

            public void Init(global::GraphEngine.Jit.Native.Asmjit.CpuInfo other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Init((__Instance + __PointerAdjustment), __arg0);
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            public void Detect()
            {
                __Internal.Detect((__Instance + __PointerAdjustment));
            }

            /// <summary>Get whether CPU has a `feature`.</summary>
            public bool HasFeature(uint feature)
            {
                var __ret = __Internal.HasFeature((__Instance + __PointerAdjustment), feature);
                return __ret;
            }

            /// <summary>Add a CPU `feature`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CpuInfo AddFeature(uint feature)
            {
                var __ret = __Internal.AddFeature((__Instance + __PointerAdjustment), feature);
                global::GraphEngine.Jit.Native.Asmjit.CpuInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CpuInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CpuInfo) global::GraphEngine.Jit.Native.Asmjit.CpuInfo.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CpuInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Get generic architecture information.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.ArchInfo ArchInfo
            {
                get
                {
                    var __ret = __Internal.GetArchInfo((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.ArchInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ArchInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ArchInfo) global::GraphEngine.Jit.Native.Asmjit.ArchInfo.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get CPU architecture type, see</summary>
            public uint ArchType
            {
                get
                {
                    var __ret = __Internal.GetArchType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get CPU architecture sub-type, see</summary>
            public uint ArchSubType
            {
                get
                {
                    var __ret = __Internal.GetArchSubType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get CPU vendor ID.</summary>
            public uint VendorId
            {
                get
                {
                    var __ret = __Internal.GetVendorId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get CPU family ID.</summary>
            public uint Family
            {
                get
                {
                    var __ret = __Internal.GetFamily((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get CPU model ID.</summary>
            public uint Model
            {
                get
                {
                    var __ret = __Internal.GetModel((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get CPU stepping.</summary>
            public uint Stepping
            {
                get
                {
                    var __ret = __Internal.GetStepping((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get number of hardware threads available.</summary>
            public uint HwThreadsCount
            {
                get
                {
                    var __ret = __Internal.GetHwThreadsCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get all CPU features.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CpuFeatures Features
            {
                get
                {
                    var __ret = __Internal.GetFeatures((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CpuFeatures __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CpuFeatures) global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CpuFeatures.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get CPU vendor string.</summary>
            public string VendorString
            {
                get
                {
                    var __ret = __Internal.GetVendorString((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            /// <summary>Get CPU brand string.</summary>
            public string BrandString
            {
                get
                {
                    var __ret = __Internal.GetBrandString((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            /// <summary>Get processor type.</summary>
            public uint X86ProcessorType
            {
                get
                {
                    var __ret = __Internal.GetX86ProcessorType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get brand index.</summary>
            public uint X86BrandIndex
            {
                get
                {
                    var __ret = __Internal.GetX86BrandIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get flush cache line size.</summary>
            public uint X86FlushCacheLineSize
            {
                get
                {
                    var __ret = __Internal.GetX86FlushCacheLineSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get maximum logical processors count.</summary>
            public uint X86MaxLogicalProcessors
            {
                get
                {
                    var __ret = __Internal.GetX86MaxLogicalProcessors((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the host CPU information.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.CpuInfo Host
            {
                get
                {
                    var __ret = __Internal.GetHost();
                    global::GraphEngine.Jit.Native.Asmjit.CpuInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CpuInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CpuInfo) global::GraphEngine.Jit.Native.Asmjit.CpuInfo.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CpuInfo.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Definitions and utilities related to instructions used by all architectures.</summary>
        public unsafe partial class Inst : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Inst@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?validate@Inst@asmjit@@SAIIAEBVDetail@12@PEBUOperand_@2@I@Z")]
                internal static extern uint Validate(uint archType, global::System.IntPtr detail, global::System.IntPtr operands, uint count);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?checkFeatures@Inst@asmjit@@SAIIAEBVDetail@12@PEBUOperand_@2@IAEAVCpuFeatures@2@@Z")]
                internal static extern uint CheckFeatures(uint archType, global::System.IntPtr detail, global::System.IntPtr operands, uint count, global::System.IntPtr @out);
            }

            public enum Id : uint
            {
                /// <summary>Invalid or uninitialized instruction id.</summary>
                kIdNone = 0
            }

            /// <summary>Describes an instruction's jump type, if any.</summary>
            public enum JumpType : uint
            {
                /// <summary>Instruction doesn't jump (regular instruction).</summary>
                kJumpTypeNone = 0,
                /// <summary>Instruction is a unconditional (direct) jump.</summary>
                kJumpTypeDirect = 1,
                /// <summary>Instruction is a conditional jump.</summary>
                kJumpTypeConditional = 2,
                /// <summary>Instruction is a function call.</summary>
                kJumpTypeCall = 3,
                /// <summary>Instruction is a function return.</summary>
                kJumpTypeReturn = 4
            }

            /// <summary>
            /// <para>Instruction id, options, and extraReg packed in a single structure. This</para>
            /// <para>structure exists to simplify analysis and validation API that requires a</para>
            /// <para>lot of information about the instruction to be processed.</para>
            /// </summary>
            public unsafe partial class Detail : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint instId;

                    [FieldOffset(4)]
                    internal uint options;

                    [FieldOffset(8)]
                    internal global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal extraReg;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Detail@Inst@asmjit@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Detail@Inst@asmjit@@QEAA@II@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint instId, uint options);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Detail@Inst@asmjit@@QEAA@IIAEBURegOnly@2@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint instId, uint options, global::System.IntPtr reg);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Detail@Inst@asmjit@@QEAA@IIAEBVReg@2@@Z")]
                    internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, uint instId, uint options, global::System.IntPtr reg);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Detail@Inst@asmjit@@QEAA@AEBV012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasExtraReg@Detail@Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasExtraReg(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Inst.Detail> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Inst.Detail>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.Inst.Detail __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Inst.Detail(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.Inst.Detail __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Inst.Detail(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Detail(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Detail(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Detail()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Detail(uint instId, uint options)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), instId, options);
                }

                public Detail(uint instId, uint options, global::GraphEngine.Jit.Native.Asmjit.RegOnly reg)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(reg, null))
                        throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                    var __arg2 = reg.__Instance;
                    __Internal.ctor((__Instance + __PointerAdjustment), instId, options, __arg2);
                }

                public Detail(uint instId, uint options, global::GraphEngine.Jit.Native.Asmjit.Reg reg)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(reg, null))
                        throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                    var __arg2 = reg.__Instance;
                    __Internal.ctor_1((__Instance + __PointerAdjustment), instId, options, __arg2);
                }

                public Detail(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.Inst.Detail __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool HasExtraReg
                {
                    get
                    {
                        var __ret = __Internal.HasExtraReg((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Inst> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Inst>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.Inst __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Inst(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Inst __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Inst.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Inst(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Inst.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Inst.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.Inst.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Inst(global::GraphEngine.Jit.Native.Asmjit.Inst.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Inst(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Inst()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Inst.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Inst(global::GraphEngine.Jit.Native.Asmjit.Inst _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Inst.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.Inst.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Inst.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.Inst __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Validate the given instruction.</summary>
            public static uint Validate(uint archType, global::GraphEngine.Jit.Native.Asmjit.Inst.Detail detail, global::GraphEngine.Jit.Native.Asmjit.Operand_ operands, uint count)
            {
                if (ReferenceEquals(detail, null))
                    throw new global::System.ArgumentNullException("detail", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = detail.__Instance;
                var __arg2 = ReferenceEquals(operands, null) ? global::System.IntPtr.Zero : operands.__Instance;
                var __ret = __Internal.Validate(archType, __arg1, __arg2, count);
                return __ret;
            }

            /// <summary>Check CPU features required to execute the given instruction.</summary>
            public static uint CheckFeatures(uint archType, global::GraphEngine.Jit.Native.Asmjit.Inst.Detail detail, global::GraphEngine.Jit.Native.Asmjit.Operand_ operands, uint count, global::GraphEngine.Jit.Native.Asmjit.CpuFeatures @out)
            {
                if (ReferenceEquals(detail, null))
                    throw new global::System.ArgumentNullException("detail", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = detail.__Instance;
                var __arg2 = ReferenceEquals(operands, null) ? global::System.IntPtr.Zero : operands.__Instance;
                if (ReferenceEquals(@out, null))
                    throw new global::System.ArgumentNullException("@out", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = @out.__Instance;
                var __ret = __Internal.CheckFeatures(archType, __arg1, __arg2, count, __arg4);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        namespace SmallString
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public unsafe partial struct __Internalc__N_asmjit_S_SmallString__Vk16
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.SmallString._.__Internalc__N_asmjit_S_SmallString__Vk16 _;
            }

            namespace _
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public unsafe partial struct __Internalc__N_asmjit_S_SmallString__Vk16
                {
                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.SmallString._.__.__Internal __;

                    [FieldOffset(0)]
                    internal global::System.IntPtr _external;
                }

                namespace __
                {
                    [StructLayout(LayoutKind.Explicit, Size = 16)]
                    public unsafe partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal uint _length;

                        [FieldOffset(4)]
                        internal fixed sbyte _embedded[12];
                    }
                }

            }

        }

        /// <summary>String builder.</summary>
        /// <remarks>
        /// <para>String builder was designed to be able to build a string using append like</para>
        /// <para>operation to append numbers, other strings, or signle characters. It can</para>
        /// <para>allocate it's own buffer or use a buffer created on the stack.</para>
        /// <para>String builder contains method specific to AsmJit functionality, used for</para>
        /// <para>logging or HTML output.</para>
        /// </remarks>
        public unsafe partial class StringBuilder : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _data;

                [FieldOffset(8)]
                internal ulong _length;

                [FieldOffset(16)]
                internal ulong _capacity;

                [FieldOffset(24)]
                internal ulong _canFree;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0StringBuilder@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0StringBuilder@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1StringBuilder@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?prepare@StringBuilder@asmjit@@QEAAPEADI_K@Z")]
                internal static extern sbyte* Prepare(global::System.IntPtr instance, uint op, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reserve@StringBuilder@asmjit@@QEAAI_K@Z")]
                internal static extern uint Reserve(global::System.IntPtr instance, ulong to);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clear@StringBuilder@asmjit@@QEAAXXZ")]
                internal static extern void Clear(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_opString@StringBuilder@asmjit@@QEAAIIPEBD_K@Z")]
                internal static extern uint OpString(global::System.IntPtr instance, uint op, [MarshalAs(UnmanagedType.LPStr)] string str, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_opChar@StringBuilder@asmjit@@QEAAIID@Z")]
                internal static extern uint OpChar(global::System.IntPtr instance, uint op, sbyte c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_opChars@StringBuilder@asmjit@@QEAAIID_K@Z")]
                internal static extern uint OpChars(global::System.IntPtr instance, uint op, sbyte c, ulong n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_opNumber@StringBuilder@asmjit@@QEAAII_KI0I@Z")]
                internal static extern uint OpNumber(global::System.IntPtr instance, uint op, ulong i, uint @base, ulong width, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_opHex@StringBuilder@asmjit@@QEAAIIPEBX_K@Z")]
                internal static extern uint OpHex(global::System.IntPtr instance, uint op, global::System.IntPtr data, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setString@StringBuilder@asmjit@@QEAAIPEBD_K@Z")]
                internal static extern uint SetString(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string str, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setFormat@StringBuilder@asmjit@@QEAAIPEBDZZ")]
                internal static extern uint SetFormat(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string fmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setChar@StringBuilder@asmjit@@QEAAID@Z")]
                internal static extern uint SetChar(global::System.IntPtr instance, sbyte c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setChars@StringBuilder@asmjit@@QEAAID_K@Z")]
                internal static extern uint SetChars(global::System.IntPtr instance, sbyte c, ulong n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setInt@StringBuilder@asmjit@@QEAAI_KI0I@Z")]
                internal static extern uint SetInt(global::System.IntPtr instance, ulong i, uint @base, ulong width, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setUInt@StringBuilder@asmjit@@QEAAI_KI0I@Z")]
                internal static extern uint SetUInt(global::System.IntPtr instance, ulong i, uint @base, ulong width, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setHex@StringBuilder@asmjit@@QEAAIPEBX_K@Z")]
                internal static extern uint SetHex(global::System.IntPtr instance, global::System.IntPtr data, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?appendString@StringBuilder@asmjit@@QEAAIPEBD_K@Z")]
                internal static extern uint AppendString(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string str, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?appendFormat@StringBuilder@asmjit@@QEAAIPEBDZZ")]
                internal static extern uint AppendFormat(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string fmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?appendChar@StringBuilder@asmjit@@QEAAID@Z")]
                internal static extern uint AppendChar(global::System.IntPtr instance, sbyte c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?appendChars@StringBuilder@asmjit@@QEAAID_K@Z")]
                internal static extern uint AppendChars(global::System.IntPtr instance, sbyte c, ulong n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?appendInt@StringBuilder@asmjit@@QEAAI_JI_KI@Z")]
                internal static extern uint AppendInt(global::System.IntPtr instance, long i, uint @base, ulong width, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?appendUInt@StringBuilder@asmjit@@QEAAI_KI0I@Z")]
                internal static extern uint AppendUInt(global::System.IntPtr instance, ulong i, uint @base, ulong width, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?appendHex@StringBuilder@asmjit@@QEAAIPEBX_K@Z")]
                internal static extern uint AppendHex(global::System.IntPtr instance, global::System.IntPtr data, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?eq@StringBuilder@asmjit@@QEBA_NPEBD_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Eq(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string str, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?eq@StringBuilder@asmjit@@QEBA_NAEBV12@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Eq(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8StringBuilder@asmjit@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9StringBuilder@asmjit@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8StringBuilder@asmjit@@QEBA_NPEBD@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9StringBuilder@asmjit@@QEBA_NPEBD@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCapacity@StringBuilder@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetCapacity(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLength@StringBuilder@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetLength(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getData@StringBuilder@asmjit@@QEAAPEADXZ")]
                internal static extern sbyte* GetData(global::System.IntPtr instance);
            }

            /// <summary>String operation.</summary>
            public enum OpType : uint
            {
                /// <summary>Replace the current string by a given content.</summary>
                kStringOpSet = 0,
                /// <summary>Append a given content to the current string.</summary>
                kStringOpAppend = 1
            }

            /// <summary>String format flags.</summary>
            [Flags]
            public enum StringFormatFlags : uint
            {
                kStringFormatShowSign = 0x1,
                kStringFormatShowSpace = 0x2,
                kStringFormatAlternate = 0x4,
                kStringFormatSigned = 0x80000000
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.StringBuilder> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.StringBuilder>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.StringBuilder __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.StringBuilder(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.StringBuilder __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.StringBuilder.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.StringBuilder(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.StringBuilder.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.StringBuilder.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.StringBuilder.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private StringBuilder(global::GraphEngine.Jit.Native.Asmjit.StringBuilder.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected StringBuilder(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public StringBuilder()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.StringBuilder.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public StringBuilder(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.StringBuilder.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.StringBuilder __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Prepare to set/append.</summary>
            public sbyte* Prepare(uint op, ulong len)
            {
                var __ret = __Internal.Prepare((__Instance + __PointerAdjustment), op, len);
                return __ret;
            }

            /// <summary>Reserve `to` bytes in string builder.</summary>
            public uint Reserve(ulong to)
            {
                var __ret = __Internal.Reserve((__Instance + __PointerAdjustment), to);
                return __ret;
            }

            /// <summary>Clear the content in String builder.</summary>
            public void Clear()
            {
                __Internal.Clear((__Instance + __PointerAdjustment));
            }

            public uint OpString(uint op, string str, ulong len)
            {
                var __ret = __Internal.OpString((__Instance + __PointerAdjustment), op, str, len);
                return __ret;
            }

            public uint OpChar(uint op, sbyte c)
            {
                var __ret = __Internal.OpChar((__Instance + __PointerAdjustment), op, c);
                return __ret;
            }

            public uint OpChars(uint op, sbyte c, ulong n)
            {
                var __ret = __Internal.OpChars((__Instance + __PointerAdjustment), op, c, n);
                return __ret;
            }

            public uint OpNumber(uint op, ulong i, uint @base, ulong width, uint flags)
            {
                var __ret = __Internal.OpNumber((__Instance + __PointerAdjustment), op, i, @base, width, flags);
                return __ret;
            }

            public uint OpHex(uint op, global::System.IntPtr data, ulong len)
            {
                var __ret = __Internal.OpHex((__Instance + __PointerAdjustment), op, data, len);
                return __ret;
            }

            /// <summary>Replace the current string with `str` having `len` characters (or `kInvalidIndex` if it's null terminated).</summary>
            public uint SetString(string str, ulong len)
            {
                var __ret = __Internal.SetString((__Instance + __PointerAdjustment), str, len);
                return __ret;
            }

            /// <summary>Replace the current content by a formatted string `fmt`.</summary>
            public uint SetFormat(string fmt)
            {
                var __ret = __Internal.SetFormat((__Instance + __PointerAdjustment), fmt);
                return __ret;
            }

            /// <summary>Replace the current content by a single `c` character.</summary>
            public uint SetChar(sbyte c)
            {
                var __ret = __Internal.SetChar((__Instance + __PointerAdjustment), c);
                return __ret;
            }

            /// <summary>Replace the current content by `c` character `n` times.</summary>
            public uint SetChars(sbyte c, ulong n)
            {
                var __ret = __Internal.SetChars((__Instance + __PointerAdjustment), c, n);
                return __ret;
            }

            /// <summary>Replace the current content by a formatted integer `i` (signed).</summary>
            public uint SetInt(ulong i, uint @base, ulong width, uint flags)
            {
                var __ret = __Internal.SetInt((__Instance + __PointerAdjustment), i, @base, width, flags);
                return __ret;
            }

            /// <summary>Replace the current content by a formatted integer `i` (unsigned).</summary>
            public uint SetUInt(ulong i, uint @base, ulong width, uint flags)
            {
                var __ret = __Internal.SetUInt((__Instance + __PointerAdjustment), i, @base, width, flags);
                return __ret;
            }

            /// <summary>Replace the current content by the given `data` converted to a HEX string.</summary>
            public uint SetHex(global::System.IntPtr data, ulong len)
            {
                var __ret = __Internal.SetHex((__Instance + __PointerAdjustment), data, len);
                return __ret;
            }

            /// <summary>Append string `str` having `len` characters (or `kInvalidIndex` if it's null terminated).</summary>
            public uint AppendString(string str, ulong len)
            {
                var __ret = __Internal.AppendString((__Instance + __PointerAdjustment), str, len);
                return __ret;
            }

            /// <summary>Append a formatted string `fmt`.</summary>
            public uint AppendFormat(string fmt)
            {
                var __ret = __Internal.AppendFormat((__Instance + __PointerAdjustment), fmt);
                return __ret;
            }

            /// <summary>Append a single `c` character.</summary>
            public uint AppendChar(sbyte c)
            {
                var __ret = __Internal.AppendChar((__Instance + __PointerAdjustment), c);
                return __ret;
            }

            /// <summary>Append `c` character `n` times.</summary>
            public uint AppendChars(sbyte c, ulong n)
            {
                var __ret = __Internal.AppendChars((__Instance + __PointerAdjustment), c, n);
                return __ret;
            }

            /// <summary>Append `i`.</summary>
            public uint AppendInt(long i, uint @base, ulong width, uint flags)
            {
                var __ret = __Internal.AppendInt((__Instance + __PointerAdjustment), i, @base, width, flags);
                return __ret;
            }

            /// <summary>Append `i`.</summary>
            public uint AppendUInt(ulong i, uint @base, ulong width, uint flags)
            {
                var __ret = __Internal.AppendUInt((__Instance + __PointerAdjustment), i, @base, width, flags);
                return __ret;
            }

            /// <summary>Append the given `data` converted to a HEX string.</summary>
            public uint AppendHex(global::System.IntPtr data, ulong len)
            {
                var __ret = __Internal.AppendHex((__Instance + __PointerAdjustment), data, len);
                return __ret;
            }

            /// <summary>Check for equality with other `str` of length `len`.</summary>
            public bool Eq(string str, ulong len)
            {
                var __ret = __Internal.Eq((__Instance + __PointerAdjustment), str, len);
                return __ret;
            }

            /// <summary>Check for equality with `other`.</summary>
            public bool Eq(global::GraphEngine.Jit.Native.Asmjit.StringBuilder other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                var __ret = __Internal.Eq((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public static bool operator ==(global::GraphEngine.Jit.Native.Asmjit.StringBuilder __op, global::GraphEngine.Jit.Native.Asmjit.StringBuilder other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return __opNull && otherNull;
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::GraphEngine.Jit.Native.Asmjit.StringBuilder;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(global::GraphEngine.Jit.Native.Asmjit.StringBuilder.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::GraphEngine.Jit.Native.Asmjit.StringBuilder __op, global::GraphEngine.Jit.Native.Asmjit.StringBuilder other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return !(__opNull && otherNull);
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return __ret;
            }

            public static bool operator ==(global::GraphEngine.Jit.Native.Asmjit.StringBuilder __op, string str)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool strNull = ReferenceEquals(str, null);
                if (__opNull || strNull)
                    return __opNull && strNull;
                var __arg0 = __op.__Instance;
                var __ret = __Internal.OperatorEqualEqual(__arg0, str);
                return __ret;
            }

            public static bool operator !=(global::GraphEngine.Jit.Native.Asmjit.StringBuilder __op, string str)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool strNull = ReferenceEquals(str, null);
                if (__opNull || strNull)
                    return !(__opNull && strNull);
                var __arg0 = __op.__Instance;
                var __ret = __Internal.OperatorExclaimEqual(__arg0, str);
                return __ret;
            }

            /// <summary>Get string builder capacity.</summary>
            public ulong Capacity
            {
                get
                {
                    var __ret = __Internal.GetCapacity((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get length.</summary>
            public ulong Length
            {
                get
                {
                    var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get null-terminated string data.</summary>
            public sbyte* Data
            {
                get
                {
                    var __ret = __Internal.GetData((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Abstract logging interface and helpers.</summary>
        /// <remarks>
        /// <para>This class can be inherited and reimplemented to fit into your logging</para>
        /// <para>subsystem. When reimplementing use `Logger::_log()` method to log into</para>
        /// <para>a custom stream.</para>
        /// <para>There are two</para>
        /// <para>-</para>
        /// <para>-</para>
        /// </remarks>
        public unsafe abstract partial class Logger : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_Logger;

                [FieldOffset(8)]
                internal uint _options;

                [FieldOffset(12)]
                internal fixed sbyte _indentation[12];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Logger@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1Logger@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?log@Logger@asmjit@@QEAAIPEBD_K@Z")]
                internal static extern uint log(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string str, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?log@Logger@asmjit@@QEAAIAEBVStringBuilder@2@@Z")]
                internal static extern uint Log(global::System.IntPtr instance, global::System.IntPtr str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?logf@Logger@asmjit@@QEAAIPEBDZZ")]
                internal static extern uint Logf(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string fmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?logBinary@Logger@asmjit@@QEAAIPEBX_K@Z")]
                internal static extern uint LogBinary(global::System.IntPtr instance, global::System.IntPtr data, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasOption@Logger@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasOption(global::System.IntPtr instance, uint option);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addOptions@Logger@asmjit@@QEAAXI@Z")]
                internal static extern void AddOptions(global::System.IntPtr instance, uint options);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearOptions@Logger@asmjit@@QEAAXI@Z")]
                internal static extern void ClearOptions(global::System.IntPtr instance, uint options);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetIndentation@Logger@asmjit@@QEAAXXZ")]
                internal static extern void ResetIndentation(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getIndentation@Logger@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetIndentation(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setIndentation@Logger@asmjit@@QEAAXPEBD@Z")]
                internal static extern void SetIndentation(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string indentation);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOptions@Logger@asmjit@@QEBAIXZ")]
                internal static extern uint GetOptions(global::System.IntPtr instance);
            }

            /// <summary>Logger options.</summary>
            [Flags]
            public enum Options : uint
            {
                kOptionBinaryForm = 0x1,
                /// <summary>Output instructions also in binary form.</summary>
                kOptionImmExtended = 0x2,
                /// <summary>Output a meaning of some immediates.</summary>
                kOptionHexImmediate = 0x4,
                /// <summary>Output constants in hexadecimal form.</summary>
                kOptionHexDisplacement = 0x8
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Logger> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Logger>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.Logger __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.LoggerInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Logger __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Logger.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.LoggerInternal(native, skipVTables);
            }

            protected Logger(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a `Logger` instance.</summary>
            protected Logger()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Logger.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.Logger");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.Logger __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.Logger.__Internal*) __Instance)->vfptr_Logger = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Log `str` - must be reimplemented.</summary>
            public abstract uint Log(string str, ulong len);

            /// <summary>Log a string `str`, which is either null terminated or having `len` length.</summary>
            public uint log(string str, ulong len)
            {
                var __ret = __Internal.log((__Instance + __PointerAdjustment), str, len);
                return __ret;
            }

            /// <summary>Log a content of a `StringBuilder` `str`.</summary>
            public uint Log(global::GraphEngine.Jit.Native.Asmjit.StringBuilder str)
            {
                if (ReferenceEquals(str, null))
                    throw new global::System.ArgumentNullException("str", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = str.__Instance;
                var __ret = __Internal.Log((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Format the message by using `sprintf()` and then send to `log()`.</summary>
            public uint Logf(string fmt)
            {
                var __ret = __Internal.Logf((__Instance + __PointerAdjustment), fmt);
                return __ret;
            }

            /// <summary>Log binary data.</summary>
            public uint LogBinary(global::System.IntPtr data, ulong size)
            {
                var __ret = __Internal.LogBinary((__Instance + __PointerAdjustment), data, size);
                return __ret;
            }

            /// <summary>Get the given logger option.</summary>
            public bool HasOption(uint option)
            {
                var __ret = __Internal.HasOption((__Instance + __PointerAdjustment), option);
                return __ret;
            }

            public void AddOptions(uint options)
            {
                __Internal.AddOptions((__Instance + __PointerAdjustment), options);
            }

            public void ClearOptions(uint options)
            {
                __Internal.ClearOptions((__Instance + __PointerAdjustment), options);
            }

            /// <summary>Reset indentation.</summary>
            public void ResetIndentation()
            {
                __Internal.ResetIndentation((__Instance + __PointerAdjustment));
            }

            /// <summary>Get indentation.</summary>
            /// <remarks>Set indentation.</remarks>
            public string Indentation
            {
                get
                {
                    var __ret = __Internal.GetIndentation((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }

                set
                {
                    __Internal.SetIndentation((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get all logger options as a single integer.</summary>
            public uint options
            {
                get
                {
                    var __ret = __Internal.GetOptions((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~Logger() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Logger) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error _log(const char* str, size_t len) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong _LogDelegateInstance;

            private static uint _LogDelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string str, ulong len)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Logger) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Log(str, len);
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _LogDelegateInstance += _LogDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LogDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        /// <summary>Logger that can log to a `FILE*` stream.</summary>
        public unsafe partial class FileLogger : global::GraphEngine.Jit.Native.Asmjit.Logger, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_Logger;

                [FieldOffset(8)]
                internal uint _options;

                [FieldOffset(12)]
                internal fixed sbyte _indentation[12];

                [FieldOffset(24)]
                internal global::System.IntPtr _stream;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0FileLogger@asmjit@@QEAA@PEAU_iobuf@@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr stream);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStream@FileLogger@asmjit@@QEBAPEAU_iobuf@@XZ")]
                internal static extern global::System.IntPtr GetStream(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setStream@FileLogger@asmjit@@QEAAXPEAU_iobuf@@@Z")]
                internal static extern void SetStream(global::System.IntPtr instance, global::System.IntPtr stream);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.FileLogger __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FileLogger(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.FileLogger __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.FileLogger.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.FileLogger(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.FileLogger.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FileLogger.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.FileLogger.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private FileLogger(global::GraphEngine.Jit.Native.Asmjit.FileLogger.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FileLogger(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a new `FileLogger` that logs to a `FILE` stream.</summary>
            public FileLogger(global::System.IntPtr stream)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.FileLogger.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), stream);
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.FileLogger");
            }

            public override uint Log(string buf, ulong len)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___LogDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong));
                var __ret = ___LogDelegate((__Instance + __PointerAdjustment), buf, len);
                return __ret;
            }

            /// <summary>Get the logging out put stream or null.</summary>
            /// <remarks>
            /// <para>Set the logging output stream to `stream` or null.</para>
            /// <para>NOTE: If the `stream` is null it will disable logging, but it won't</para>
            /// <para>stop calling `log()` unless the logger is detached from the</para>
            /// </remarks>
            public global::System.IntPtr Stream
            {
                get
                {
                    var __ret = __Internal.GetStream((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetStream((__Instance + __PointerAdjustment), value);
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~FileLogger() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.FileLogger) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error _log(const char* buf, size_t len = Globals::kInvalidIndex) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong _LogDelegateInstance;

            private static uint _LogDelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string buf, ulong len)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.FileLogger) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Log(buf, len);
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _LogDelegateInstance += _LogDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LogDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        /// <summary>Logger that stores everything in an internal string buffer.</summary>
        public unsafe partial class StringLogger : global::GraphEngine.Jit.Native.Asmjit.Logger, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_Logger;

                [FieldOffset(8)]
                internal uint _options;

                [FieldOffset(12)]
                internal fixed sbyte _indentation[12];

                [FieldOffset(24)]
                internal global::GraphEngine.Jit.Native.Asmjit.StringBuilder.__Internal _stringBuilder;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0StringLogger@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearString@StringLogger@asmjit@@QEAAXXZ")]
                internal static extern void ClearString(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getString@StringLogger@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetString(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLength@StringLogger@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetLength(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.StringLogger __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.StringLogger(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.StringLogger __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.StringLogger.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.StringLogger(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.StringLogger.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.StringLogger.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.StringLogger.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private StringLogger(global::GraphEngine.Jit.Native.Asmjit.StringLogger.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected StringLogger(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create new `StringLogger`.</summary>
            public StringLogger()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.StringLogger.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.StringLogger");
            }

            /// <summary>Clear the resulting string.</summary>
            public void ClearString()
            {
                __Internal.ClearString((__Instance + __PointerAdjustment));
            }

            public override uint Log(string buf, ulong len)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___LogDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong));
                var __ret = ___LogDelegate((__Instance + __PointerAdjustment), buf, len);
                return __ret;
            }

            /// <summary>Get `char*` pointer which represents the resulting string.</summary>
            /// <remarks>The pointer is owned by `StringLogger`, it can't be modified or freed.</remarks>
            public string String
            {
                get
                {
                    var __ret = __Internal.GetString((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            /// <summary>Get the length of the string returned by `getString()`.</summary>
            public ulong Length
            {
                get
                {
                    var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~StringLogger() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.StringLogger) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error _log(const char* buf, size_t len = Globals::kInvalidIndex) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong _LogDelegateInstance;

            private static uint _LogDelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string buf, ulong len)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.StringLogger) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Log(buf, len);
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _LogDelegateInstance += _LogDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LogDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        public unsafe partial class Logging : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Logging@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?formatRegister@Logging@asmjit@@SAIAEAVStringBuilder@2@IPEBVCodeEmitter@2@III@Z")]
                internal static extern uint FormatRegister(global::System.IntPtr sb, uint logOptions, global::System.IntPtr emitter, uint archType, uint regType, uint regId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?formatLabel@Logging@asmjit@@SAIAEAVStringBuilder@2@IPEBVCodeEmitter@2@I@Z")]
                internal static extern uint FormatLabel(global::System.IntPtr sb, uint logOptions, global::System.IntPtr emitter, uint labelId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?formatOperand@Logging@asmjit@@SAIAEAVStringBuilder@2@IPEBVCodeEmitter@2@IAEBUOperand_@2@@Z")]
                internal static extern uint FormatOperand(global::System.IntPtr sb, uint logOptions, global::System.IntPtr emitter, uint archType, global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?formatInstruction@Logging@asmjit@@SAIAEAVStringBuilder@2@IPEBVCodeEmitter@2@IAEBVDetail@Inst@2@PEBUOperand_@2@I@Z")]
                internal static extern uint FormatInstruction(global::System.IntPtr sb, uint logOptions, global::System.IntPtr emitter, uint archType, global::System.IntPtr detail, global::System.IntPtr opArray, uint opCount);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?formatNode@Logging@asmjit@@SAIAEAVStringBuilder@2@IPEBVCodeBuilder@2@PEBVCBNode@2@@Z")]
                internal static extern uint FormatNode(global::System.IntPtr sb, uint logOptions, global::System.IntPtr cb, global::System.IntPtr node_);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Logging> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Logging>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.Logging __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Logging(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Logging __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Logging.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Logging(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Logging.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Logging.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.Logging.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Logging(global::GraphEngine.Jit.Native.Asmjit.Logging.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Logging(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Logging()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Logging.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Logging(global::GraphEngine.Jit.Native.Asmjit.Logging _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Logging.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.Logging.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Logging.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.Logging __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static uint FormatRegister(global::GraphEngine.Jit.Native.Asmjit.StringBuilder sb, uint logOptions, global::GraphEngine.Jit.Native.Asmjit.CodeEmitter emitter, uint archType, uint regType, uint regId)
            {
                if (ReferenceEquals(sb, null))
                    throw new global::System.ArgumentNullException("sb", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = sb.__Instance;
                var __arg2 = ReferenceEquals(emitter, null) ? global::System.IntPtr.Zero : emitter.__Instance;
                var __ret = __Internal.FormatRegister(__arg0, logOptions, __arg2, archType, regType, regId);
                return __ret;
            }

            public static uint FormatLabel(global::GraphEngine.Jit.Native.Asmjit.StringBuilder sb, uint logOptions, global::GraphEngine.Jit.Native.Asmjit.CodeEmitter emitter, uint labelId)
            {
                if (ReferenceEquals(sb, null))
                    throw new global::System.ArgumentNullException("sb", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = sb.__Instance;
                var __arg2 = ReferenceEquals(emitter, null) ? global::System.IntPtr.Zero : emitter.__Instance;
                var __ret = __Internal.FormatLabel(__arg0, logOptions, __arg2, labelId);
                return __ret;
            }

            public static uint FormatOperand(global::GraphEngine.Jit.Native.Asmjit.StringBuilder sb, uint logOptions, global::GraphEngine.Jit.Native.Asmjit.CodeEmitter emitter, uint archType, global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(sb, null))
                    throw new global::System.ArgumentNullException("sb", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = sb.__Instance;
                var __arg2 = ReferenceEquals(emitter, null) ? global::System.IntPtr.Zero : emitter.__Instance;
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = op.__Instance;
                var __ret = __Internal.FormatOperand(__arg0, logOptions, __arg2, archType, __arg4);
                return __ret;
            }

            public static uint FormatInstruction(global::GraphEngine.Jit.Native.Asmjit.StringBuilder sb, uint logOptions, global::GraphEngine.Jit.Native.Asmjit.CodeEmitter emitter, uint archType, global::GraphEngine.Jit.Native.Asmjit.Inst.Detail detail, global::GraphEngine.Jit.Native.Asmjit.Operand_ opArray, uint opCount)
            {
                if (ReferenceEquals(sb, null))
                    throw new global::System.ArgumentNullException("sb", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = sb.__Instance;
                var __arg2 = ReferenceEquals(emitter, null) ? global::System.IntPtr.Zero : emitter.__Instance;
                if (ReferenceEquals(detail, null))
                    throw new global::System.ArgumentNullException("detail", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = detail.__Instance;
                var __arg5 = ReferenceEquals(opArray, null) ? global::System.IntPtr.Zero : opArray.__Instance;
                var __ret = __Internal.FormatInstruction(__arg0, logOptions, __arg2, archType, __arg4, __arg5, opCount);
                return __ret;
            }

            public static uint FormatNode(global::GraphEngine.Jit.Native.Asmjit.StringBuilder sb, uint logOptions, global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, global::GraphEngine.Jit.Native.Asmjit.CBNode node_)
            {
                if (ReferenceEquals(sb, null))
                    throw new global::System.ArgumentNullException("sb", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = sb.__Instance;
                var __arg2 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                var __arg3 = ReferenceEquals(node_, null) ? global::System.IntPtr.Zero : node_.__Instance;
                var __ret = __Internal.FormatNode(__arg0, logOptions, __arg2, __arg3);
                return __ret;
            }
        }

        public unsafe partial class LoggerInternal : global::GraphEngine.Jit.Native.Asmjit.Logger, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Logger.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Logger.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.Logger.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal LoggerInternal(global::GraphEngine.Jit.Native.Asmjit.Logger.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal LoggerInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Log `str` - must be reimplemented.</summary>
            public override uint Log(string str, ulong len)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___LogDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong));
                var __ret = ___LogDelegate((__Instance + __PointerAdjustment), str, len);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>64-bit data useful for creating SIMD constants.</summary>
        public unsafe partial struct Data64
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal fixed sbyte sb[8];

                [FieldOffset(0)]
                internal fixed byte ub[8];

                [FieldOffset(0)]
                internal fixed short sw[4];

                [FieldOffset(0)]
                internal fixed ushort uw[4];

                [FieldOffset(0)]
                internal fixed int sd[2];

                [FieldOffset(0)]
                internal fixed uint ud[2];

                [FieldOffset(0)]
                internal fixed long sq[1];

                [FieldOffset(0)]
                internal fixed ulong uq[1];

                [FieldOffset(0)]
                internal fixed float sf[2];

                [FieldOffset(0)]
                internal fixed double df[1];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Data64@asmjit@@QEAA@AEBT01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI8@Data64@asmjit@@SA?AT12@C@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromI8(sbyte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU8@Data64@asmjit@@SA?AT12@E@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromU8(byte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI8@Data64@asmjit@@SA?AT12@CCCCCCCC@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromI8(sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU8@Data64@asmjit@@SA?AT12@EEEEEEEE@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromU8(byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI16@Data64@asmjit@@SA?AT12@F@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromI16(short x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU16@Data64@asmjit@@SA?AT12@G@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromU16(ushort x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI16@Data64@asmjit@@SA?AT12@FFFF@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromI16(short x0, short x1, short x2, short x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU16@Data64@asmjit@@SA?AT12@GGGG@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromU16(ushort x0, ushort x1, ushort x2, ushort x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI32@Data64@asmjit@@SA?AT12@H@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromI32(int x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU32@Data64@asmjit@@SA?AT12@I@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromU32(uint x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI32@Data64@asmjit@@SA?AT12@HH@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromI32(int x0, int x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU32@Data64@asmjit@@SA?AT12@II@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromU32(uint x0, uint x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI64@Data64@asmjit@@SA?AT12@_J@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromI64(long x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU64@Data64@asmjit@@SA?AT12@_K@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromU64(ulong x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF32@Data64@asmjit@@SA?AT12@M@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromF32(float x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF32@Data64@asmjit@@SA?AT12@MM@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromF32(float x0, float x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF64@Data64@asmjit@@SA?AT12@N@Z")]
                internal static extern global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal FromF64(double x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI8@Data64@asmjit@@QEAAXC@Z")]
                internal static extern void SetI8(global::System.IntPtr instance, sbyte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU8@Data64@asmjit@@QEAAXE@Z")]
                internal static extern void SetU8(global::System.IntPtr instance, byte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI8@Data64@asmjit@@QEAAXCCCCCCCC@Z")]
                internal static extern void SetI8(global::System.IntPtr instance, sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU8@Data64@asmjit@@QEAAXEEEEEEEE@Z")]
                internal static extern void SetU8(global::System.IntPtr instance, byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI16@Data64@asmjit@@QEAAXF@Z")]
                internal static extern void SetI16(global::System.IntPtr instance, short x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU16@Data64@asmjit@@QEAAXG@Z")]
                internal static extern void SetU16(global::System.IntPtr instance, ushort x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI16@Data64@asmjit@@QEAAXFFFF@Z")]
                internal static extern void SetI16(global::System.IntPtr instance, short x0, short x1, short x2, short x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU16@Data64@asmjit@@QEAAXGGGG@Z")]
                internal static extern void SetU16(global::System.IntPtr instance, ushort x0, ushort x1, ushort x2, ushort x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI32@Data64@asmjit@@QEAAXH@Z")]
                internal static extern void SetI32(global::System.IntPtr instance, int x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU32@Data64@asmjit@@QEAAXI@Z")]
                internal static extern void SetU32(global::System.IntPtr instance, uint x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI32@Data64@asmjit@@QEAAXHH@Z")]
                internal static extern void SetI32(global::System.IntPtr instance, int x0, int x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU32@Data64@asmjit@@QEAAXII@Z")]
                internal static extern void SetU32(global::System.IntPtr instance, uint x0, uint x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI64@Data64@asmjit@@QEAAX_J@Z")]
                internal static extern void SetI64(global::System.IntPtr instance, long x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU64@Data64@asmjit@@QEAAX_K@Z")]
                internal static extern void SetU64(global::System.IntPtr instance, ulong x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF32@Data64@asmjit@@QEAAXM@Z")]
                internal static extern void SetF32(global::System.IntPtr instance, float x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF32@Data64@asmjit@@QEAAXMM@Z")]
                internal static extern void SetF32(global::System.IntPtr instance, float x0, float x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF64@Data64@asmjit@@QEAAXN@Z")]
                internal static extern void SetF64(global::System.IntPtr instance, double x0);
            }

            private Data64.__Internal __instance;
            internal Data64.__Internal __Instance { get { return __instance; } }

            internal static global::GraphEngine.Jit.Native.Asmjit.Data64 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Data64(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Data64 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Data64(native, skipVTables);
            }

            private Data64(global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Data64(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::GraphEngine.Jit.Native.Asmjit.Data64.__Internal*) native;
            }

            public Data64(global::GraphEngine.Jit.Native.Asmjit.Data64 _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Set all eight 8-bit signed integers.</summary>
            public void SetI8(sbyte x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI8(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all eight 8-bit unsigned integers.</summary>
            public void SetU8(byte x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU8(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all eight 8-bit signed integers.</summary>
            public void SetI8(sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI8(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7);
                }
            }

            /// <summary>Set all eight 8-bit unsigned integers.</summary>
            public void SetU8(byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU8(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7);
                }
            }

            /// <summary>Set all four 16-bit signed integers.</summary>
            public void SetI16(short x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI16(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all four 16-bit unsigned integers.</summary>
            public void SetU16(ushort x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU16(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all four 16-bit signed integers.</summary>
            public void SetI16(short x0, short x1, short x2, short x3)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI16(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3);
                }
            }

            /// <summary>Set all four 16-bit unsigned integers.</summary>
            public void SetU16(ushort x0, ushort x1, ushort x2, ushort x3)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU16(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3);
                }
            }

            /// <summary>Set all two 32-bit signed integers.</summary>
            public void SetI32(int x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI32(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all two 32-bit unsigned integers.</summary>
            public void SetU32(uint x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU32(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all two 32-bit signed integers.</summary>
            public void SetI32(int x0, int x1)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI32(new global::System.IntPtr(__instancePtr), x0, x1);
                }
            }

            /// <summary>Set all two 32-bit unsigned integers.</summary>
            public void SetU32(uint x0, uint x1)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU32(new global::System.IntPtr(__instancePtr), x0, x1);
                }
            }

            /// <summary>Set 64-bit signed integer.</summary>
            public void SetI64(long x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI64(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set 64-bit unsigned integer.</summary>
            public void SetU64(ulong x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU64(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all two SP-FP values.</summary>
            public void SetF32(float x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF32(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all two SP-FP values.</summary>
            public void SetF32(float x0, float x1)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF32(new global::System.IntPtr(__instancePtr), x0, x1);
                }
            }

            /// <summary>Set all two SP-FP values.</summary>
            public void SetF64(double x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF64(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all eight 8-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromI8(sbyte x0)
            {
                var __ret = __Internal.FromI8(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 8-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromU8(byte x0)
            {
                var __ret = __Internal.FromU8(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 8-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromI8(sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7)
            {
                var __ret = __Internal.FromI8(x0, x1, x2, x3, x4, x5, x6, x7);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 8-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromU8(byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7)
            {
                var __ret = __Internal.FromU8(x0, x1, x2, x3, x4, x5, x6, x7);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all four 16-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromI16(short x0)
            {
                var __ret = __Internal.FromI16(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all four 16-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromU16(ushort x0)
            {
                var __ret = __Internal.FromU16(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all four 16-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromI16(short x0, short x1, short x2, short x3)
            {
                var __ret = __Internal.FromI16(x0, x1, x2, x3);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all four 16-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromU16(ushort x0, ushort x1, ushort x2, ushort x3)
            {
                var __ret = __Internal.FromU16(x0, x1, x2, x3);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all two 32-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromI32(int x0)
            {
                var __ret = __Internal.FromI32(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all two 32-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromU32(uint x0)
            {
                var __ret = __Internal.FromU32(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all two 32-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromI32(int x0, int x1)
            {
                var __ret = __Internal.FromI32(x0, x1);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all two 32-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromU32(uint x0, uint x1)
            {
                var __ret = __Internal.FromU32(x0, x1);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set 64-bit signed integer.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromI64(long x0)
            {
                var __ret = __Internal.FromI64(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set 64-bit unsigned integer.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromU64(ulong x0)
            {
                var __ret = __Internal.FromU64(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all two SP-FP values.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromF32(float x0)
            {
                var __ret = __Internal.FromF32(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all two SP-FP values.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromF32(float x0, float x1)
            {
                var __ret = __Internal.FromF32(x0, x1);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }

            /// <summary>Set all two SP-FP values.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data64 FromF64(double x0)
            {
                var __ret = __Internal.FromF64(x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data64.__CreateInstance(__ret);
            }
        }

        /// <summary>128-bit data useful for creating SIMD constants.</summary>
        public unsafe partial struct Data128
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal fixed sbyte sb[16];

                [FieldOffset(0)]
                internal fixed byte ub[16];

                [FieldOffset(0)]
                internal fixed short sw[8];

                [FieldOffset(0)]
                internal fixed ushort uw[8];

                [FieldOffset(0)]
                internal fixed int sd[4];

                [FieldOffset(0)]
                internal fixed uint ud[4];

                [FieldOffset(0)]
                internal fixed long sq[2];

                [FieldOffset(0)]
                internal fixed ulong uq[2];

                [FieldOffset(0)]
                internal fixed float sf[4];

                [FieldOffset(0)]
                internal fixed double df[2];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Data128@asmjit@@QEAA@AEBT01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI8@Data128@asmjit@@SA?AT12@C@Z")]
                internal static extern void FromI8(global::System.IntPtr @return, sbyte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU8@Data128@asmjit@@SA?AT12@E@Z")]
                internal static extern void FromU8(global::System.IntPtr @return, byte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI8@Data128@asmjit@@SA?AT12@CCCCCCCCCCCCCCCC@Z")]
                internal static extern void FromI8(global::System.IntPtr @return, sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7, sbyte x8, sbyte x9, sbyte x10, sbyte x11, sbyte x12, sbyte x13, sbyte x14, sbyte x15);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU8@Data128@asmjit@@SA?AT12@EEEEEEEEEEEEEEEE@Z")]
                internal static extern void FromU8(global::System.IntPtr @return, byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7, byte x8, byte x9, byte x10, byte x11, byte x12, byte x13, byte x14, byte x15);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI16@Data128@asmjit@@SA?AT12@F@Z")]
                internal static extern void FromI16(global::System.IntPtr @return, short x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU16@Data128@asmjit@@SA?AT12@G@Z")]
                internal static extern void FromU16(global::System.IntPtr @return, ushort x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI16@Data128@asmjit@@SA?AT12@FFFFFFFF@Z")]
                internal static extern void FromI16(global::System.IntPtr @return, short x0, short x1, short x2, short x3, short x4, short x5, short x6, short x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU16@Data128@asmjit@@SA?AT12@GGGGGGGG@Z")]
                internal static extern void FromU16(global::System.IntPtr @return, ushort x0, ushort x1, ushort x2, ushort x3, ushort x4, ushort x5, ushort x6, ushort x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI32@Data128@asmjit@@SA?AT12@H@Z")]
                internal static extern void FromI32(global::System.IntPtr @return, int x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU32@Data128@asmjit@@SA?AT12@I@Z")]
                internal static extern void FromU32(global::System.IntPtr @return, uint x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI32@Data128@asmjit@@SA?AT12@HHHH@Z")]
                internal static extern void FromI32(global::System.IntPtr @return, int x0, int x1, int x2, int x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU32@Data128@asmjit@@SA?AT12@IIII@Z")]
                internal static extern void FromU32(global::System.IntPtr @return, uint x0, uint x1, uint x2, uint x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI64@Data128@asmjit@@SA?AT12@_J@Z")]
                internal static extern void FromI64(global::System.IntPtr @return, long x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU64@Data128@asmjit@@SA?AT12@_K@Z")]
                internal static extern void FromU64(global::System.IntPtr @return, ulong x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI64@Data128@asmjit@@SA?AT12@_J0@Z")]
                internal static extern void FromI64(global::System.IntPtr @return, long x0, long x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU64@Data128@asmjit@@SA?AT12@_K0@Z")]
                internal static extern void FromU64(global::System.IntPtr @return, ulong x0, ulong x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF32@Data128@asmjit@@SA?AT12@M@Z")]
                internal static extern void FromF32(global::System.IntPtr @return, float x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF32@Data128@asmjit@@SA?AT12@MMMM@Z")]
                internal static extern void FromF32(global::System.IntPtr @return, float x0, float x1, float x2, float x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF64@Data128@asmjit@@SA?AT12@N@Z")]
                internal static extern void FromF64(global::System.IntPtr @return, double x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF64@Data128@asmjit@@SA?AT12@NN@Z")]
                internal static extern void FromF64(global::System.IntPtr @return, double x0, double x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI8@Data128@asmjit@@QEAAXC@Z")]
                internal static extern void SetI8(global::System.IntPtr instance, sbyte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU8@Data128@asmjit@@QEAAXE@Z")]
                internal static extern void SetU8(global::System.IntPtr instance, byte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI8@Data128@asmjit@@QEAAXCCCCCCCCCCCCCCCC@Z")]
                internal static extern void SetI8(global::System.IntPtr instance, sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7, sbyte x8, sbyte x9, sbyte x10, sbyte x11, sbyte x12, sbyte x13, sbyte x14, sbyte x15);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU8@Data128@asmjit@@QEAAXEEEEEEEEEEEEEEEE@Z")]
                internal static extern void SetU8(global::System.IntPtr instance, byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7, byte x8, byte x9, byte x10, byte x11, byte x12, byte x13, byte x14, byte x15);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI16@Data128@asmjit@@QEAAXF@Z")]
                internal static extern void SetI16(global::System.IntPtr instance, short x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU16@Data128@asmjit@@QEAAXG@Z")]
                internal static extern void SetU16(global::System.IntPtr instance, ushort x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI16@Data128@asmjit@@QEAAXFFFFFFFF@Z")]
                internal static extern void SetI16(global::System.IntPtr instance, short x0, short x1, short x2, short x3, short x4, short x5, short x6, short x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU16@Data128@asmjit@@QEAAXGGGGGGGG@Z")]
                internal static extern void SetU16(global::System.IntPtr instance, ushort x0, ushort x1, ushort x2, ushort x3, ushort x4, ushort x5, ushort x6, ushort x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI32@Data128@asmjit@@QEAAXH@Z")]
                internal static extern void SetI32(global::System.IntPtr instance, int x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU32@Data128@asmjit@@QEAAXI@Z")]
                internal static extern void SetU32(global::System.IntPtr instance, uint x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI32@Data128@asmjit@@QEAAXHHHH@Z")]
                internal static extern void SetI32(global::System.IntPtr instance, int x0, int x1, int x2, int x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU32@Data128@asmjit@@QEAAXIIII@Z")]
                internal static extern void SetU32(global::System.IntPtr instance, uint x0, uint x1, uint x2, uint x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI64@Data128@asmjit@@QEAAX_J@Z")]
                internal static extern void SetI64(global::System.IntPtr instance, long x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU64@Data128@asmjit@@QEAAX_K@Z")]
                internal static extern void SetU64(global::System.IntPtr instance, ulong x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI64@Data128@asmjit@@QEAAX_J0@Z")]
                internal static extern void SetI64(global::System.IntPtr instance, long x0, long x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU64@Data128@asmjit@@QEAAX_K0@Z")]
                internal static extern void SetU64(global::System.IntPtr instance, ulong x0, ulong x1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF32@Data128@asmjit@@QEAAXM@Z")]
                internal static extern void SetF32(global::System.IntPtr instance, float x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF32@Data128@asmjit@@QEAAXMMMM@Z")]
                internal static extern void SetF32(global::System.IntPtr instance, float x0, float x1, float x2, float x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF64@Data128@asmjit@@QEAAXN@Z")]
                internal static extern void SetF64(global::System.IntPtr instance, double x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF64@Data128@asmjit@@QEAAXNN@Z")]
                internal static extern void SetF64(global::System.IntPtr instance, double x0, double x1);
            }

            private Data128.__Internal __instance;
            internal Data128.__Internal __Instance { get { return __instance; } }

            internal static global::GraphEngine.Jit.Native.Asmjit.Data128 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Data128(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Data128 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Data128(native, skipVTables);
            }

            private Data128(global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Data128(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal*) native;
            }

            public Data128(global::GraphEngine.Jit.Native.Asmjit.Data128 _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Set all sixteen 8-bit signed integers.</summary>
            public void SetI8(sbyte x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI8(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all sixteen 8-bit unsigned integers.</summary>
            public void SetU8(byte x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU8(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all sixteen 8-bit signed integers.</summary>
            public void SetI8(sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7, sbyte x8, sbyte x9, sbyte x10, sbyte x11, sbyte x12, sbyte x13, sbyte x14, sbyte x15)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI8(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
                }
            }

            /// <summary>Set all sixteen 8-bit unsigned integers.</summary>
            public void SetU8(byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7, byte x8, byte x9, byte x10, byte x11, byte x12, byte x13, byte x14, byte x15)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU8(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
                }
            }

            /// <summary>Set all eight 16-bit signed integers.</summary>
            public void SetI16(short x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI16(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all eight 16-bit unsigned integers.</summary>
            public void SetU16(ushort x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU16(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all eight 16-bit signed integers.</summary>
            public void SetI16(short x0, short x1, short x2, short x3, short x4, short x5, short x6, short x7)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI16(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7);
                }
            }

            /// <summary>Set all eight 16-bit unsigned integers.</summary>
            public void SetU16(ushort x0, ushort x1, ushort x2, ushort x3, ushort x4, ushort x5, ushort x6, ushort x7)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU16(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7);
                }
            }

            /// <summary>Set all four 32-bit signed integers.</summary>
            public void SetI32(int x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI32(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all four 32-bit unsigned integers.</summary>
            public void SetU32(uint x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU32(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all four 32-bit signed integers.</summary>
            public void SetI32(int x0, int x1, int x2, int x3)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI32(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3);
                }
            }

            /// <summary>Set all four 32-bit unsigned integers.</summary>
            public void SetU32(uint x0, uint x1, uint x2, uint x3)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU32(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3);
                }
            }

            /// <summary>Set all two 64-bit signed integers.</summary>
            public void SetI64(long x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI64(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all two 64-bit unsigned integers.</summary>
            public void SetU64(ulong x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU64(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all two 64-bit signed integers.</summary>
            public void SetI64(long x0, long x1)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI64(new global::System.IntPtr(__instancePtr), x0, x1);
                }
            }

            /// <summary>Set all two 64-bit unsigned integers.</summary>
            public void SetU64(ulong x0, ulong x1)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU64(new global::System.IntPtr(__instancePtr), x0, x1);
                }
            }

            /// <summary>Set all four SP-FP floats.</summary>
            public void SetF32(float x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF32(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all four SP-FP floats.</summary>
            public void SetF32(float x0, float x1, float x2, float x3)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF32(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3);
                }
            }

            /// <summary>Set all two DP-FP floats.</summary>
            public void SetF64(double x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF64(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all two DP-FP floats.</summary>
            public void SetF64(double x0, double x1)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF64(new global::System.IntPtr(__instancePtr), x0, x1);
                }
            }

            /// <summary>Set all sixteen 8-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromI8(sbyte x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromI8(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all sixteen 8-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromU8(byte x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromU8(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all sixteen 8-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromI8(sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7, sbyte x8, sbyte x9, sbyte x10, sbyte x11, sbyte x12, sbyte x13, sbyte x14, sbyte x15)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromI8(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all sixteen 8-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromU8(byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7, byte x8, byte x9, byte x10, byte x11, byte x12, byte x13, byte x14, byte x15)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromU8(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 16-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromI16(short x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromI16(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 16-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromU16(ushort x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromU16(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 16-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromI16(short x0, short x1, short x2, short x3, short x4, short x5, short x6, short x7)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromI16(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 16-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromU16(ushort x0, ushort x1, ushort x2, ushort x3, ushort x4, ushort x5, ushort x6, ushort x7)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromU16(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all four 32-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromI32(int x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromI32(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all four 32-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromU32(uint x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromU32(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all four 32-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromI32(int x0, int x1, int x2, int x3)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromI32(new IntPtr(&__ret), x0, x1, x2, x3);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all four 32-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromU32(uint x0, uint x1, uint x2, uint x3)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromU32(new IntPtr(&__ret), x0, x1, x2, x3);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all two 64-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromI64(long x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromI64(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all two 64-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromU64(ulong x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromU64(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all two 64-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromI64(long x0, long x1)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromI64(new IntPtr(&__ret), x0, x1);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all two 64-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromU64(ulong x0, ulong x1)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromU64(new IntPtr(&__ret), x0, x1);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all four SP-FP floats.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromF32(float x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromF32(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all four SP-FP floats.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromF32(float x0, float x1, float x2, float x3)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromF32(new IntPtr(&__ret), x0, x1, x2, x3);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all two DP-FP floats.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromF64(double x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromF64(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }

            /// <summary>Set all two DP-FP floats.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data128 FromF64(double x0, double x1)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data128.__Internal();
                __Internal.FromF64(new IntPtr(&__ret), x0, x1);
                return global::GraphEngine.Jit.Native.Asmjit.Data128.__CreateInstance(__ret);
            }
        }

        /// <summary>256-bit data useful for creating SIMD constants.</summary>
        public unsafe partial struct Data256
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal fixed sbyte sb[32];

                [FieldOffset(0)]
                internal fixed byte ub[32];

                [FieldOffset(0)]
                internal fixed short sw[16];

                [FieldOffset(0)]
                internal fixed ushort uw[16];

                [FieldOffset(0)]
                internal fixed int sd[8];

                [FieldOffset(0)]
                internal fixed uint ud[8];

                [FieldOffset(0)]
                internal fixed long sq[4];

                [FieldOffset(0)]
                internal fixed ulong uq[4];

                [FieldOffset(0)]
                internal fixed float sf[8];

                [FieldOffset(0)]
                internal fixed double df[4];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Data256@asmjit@@QEAA@AEBT01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI8@Data256@asmjit@@SA?AT12@C@Z")]
                internal static extern void FromI8(global::System.IntPtr @return, sbyte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU8@Data256@asmjit@@SA?AT12@E@Z")]
                internal static extern void FromU8(global::System.IntPtr @return, byte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI8@Data256@asmjit@@SA?AT12@CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC@Z")]
                internal static extern void FromI8(global::System.IntPtr @return, sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7, sbyte x8, sbyte x9, sbyte x10, sbyte x11, sbyte x12, sbyte x13, sbyte x14, sbyte x15, sbyte x16, sbyte x17, sbyte x18, sbyte x19, sbyte x20, sbyte x21, sbyte x22, sbyte x23, sbyte x24, sbyte x25, sbyte x26, sbyte x27, sbyte x28, sbyte x29, sbyte x30, sbyte x31);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU8@Data256@asmjit@@SA?AT12@EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE@Z")]
                internal static extern void FromU8(global::System.IntPtr @return, byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7, byte x8, byte x9, byte x10, byte x11, byte x12, byte x13, byte x14, byte x15, byte x16, byte x17, byte x18, byte x19, byte x20, byte x21, byte x22, byte x23, byte x24, byte x25, byte x26, byte x27, byte x28, byte x29, byte x30, byte x31);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI16@Data256@asmjit@@SA?AT12@F@Z")]
                internal static extern void FromI16(global::System.IntPtr @return, short x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU16@Data256@asmjit@@SA?AT12@G@Z")]
                internal static extern void FromU16(global::System.IntPtr @return, ushort x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI16@Data256@asmjit@@SA?AT12@FFFFFFFFFFFFFFFF@Z")]
                internal static extern void FromI16(global::System.IntPtr @return, short x0, short x1, short x2, short x3, short x4, short x5, short x6, short x7, short x8, short x9, short x10, short x11, short x12, short x13, short x14, short x15);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU16@Data256@asmjit@@SA?AT12@GGGGGGGGGGGGGGGG@Z")]
                internal static extern void FromU16(global::System.IntPtr @return, ushort x0, ushort x1, ushort x2, ushort x3, ushort x4, ushort x5, ushort x6, ushort x7, ushort x8, ushort x9, ushort x10, ushort x11, ushort x12, ushort x13, ushort x14, ushort x15);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI32@Data256@asmjit@@SA?AT12@H@Z")]
                internal static extern void FromI32(global::System.IntPtr @return, int x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU32@Data256@asmjit@@SA?AT12@I@Z")]
                internal static extern void FromU32(global::System.IntPtr @return, uint x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI32@Data256@asmjit@@SA?AT12@HHHHHHHH@Z")]
                internal static extern void FromI32(global::System.IntPtr @return, int x0, int x1, int x2, int x3, int x4, int x5, int x6, int x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU32@Data256@asmjit@@SA?AT12@IIIIIIII@Z")]
                internal static extern void FromU32(global::System.IntPtr @return, uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI64@Data256@asmjit@@SA?AT12@_J@Z")]
                internal static extern void FromI64(global::System.IntPtr @return, long x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU64@Data256@asmjit@@SA?AT12@_K@Z")]
                internal static extern void FromU64(global::System.IntPtr @return, ulong x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromI64@Data256@asmjit@@SA?AT12@_J000@Z")]
                internal static extern void FromI64(global::System.IntPtr @return, long x0, long x1, long x2, long x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromU64@Data256@asmjit@@SA?AT12@_K000@Z")]
                internal static extern void FromU64(global::System.IntPtr @return, ulong x0, ulong x1, ulong x2, ulong x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF32@Data256@asmjit@@SA?AT12@M@Z")]
                internal static extern void FromF32(global::System.IntPtr @return, float x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF32@Data256@asmjit@@SA?AT12@MMMMMMMM@Z")]
                internal static extern void FromF32(global::System.IntPtr @return, float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF64@Data256@asmjit@@SA?AT12@N@Z")]
                internal static extern void FromF64(global::System.IntPtr @return, double x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromF64@Data256@asmjit@@SA?AT12@NNNN@Z")]
                internal static extern void FromF64(global::System.IntPtr @return, double x0, double x1, double x2, double x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI8@Data256@asmjit@@QEAAXC@Z")]
                internal static extern void SetI8(global::System.IntPtr instance, sbyte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU8@Data256@asmjit@@QEAAXE@Z")]
                internal static extern void SetU8(global::System.IntPtr instance, byte x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI8@Data256@asmjit@@QEAAXCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC@Z")]
                internal static extern void SetI8(global::System.IntPtr instance, sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7, sbyte x8, sbyte x9, sbyte x10, sbyte x11, sbyte x12, sbyte x13, sbyte x14, sbyte x15, sbyte x16, sbyte x17, sbyte x18, sbyte x19, sbyte x20, sbyte x21, sbyte x22, sbyte x23, sbyte x24, sbyte x25, sbyte x26, sbyte x27, sbyte x28, sbyte x29, sbyte x30, sbyte x31);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU8@Data256@asmjit@@QEAAXEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE@Z")]
                internal static extern void SetU8(global::System.IntPtr instance, byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7, byte x8, byte x9, byte x10, byte x11, byte x12, byte x13, byte x14, byte x15, byte x16, byte x17, byte x18, byte x19, byte x20, byte x21, byte x22, byte x23, byte x24, byte x25, byte x26, byte x27, byte x28, byte x29, byte x30, byte x31);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI16@Data256@asmjit@@QEAAXF@Z")]
                internal static extern void SetI16(global::System.IntPtr instance, short x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU16@Data256@asmjit@@QEAAXG@Z")]
                internal static extern void SetU16(global::System.IntPtr instance, ushort x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI16@Data256@asmjit@@QEAAXFFFFFFFFFFFFFFFF@Z")]
                internal static extern void SetI16(global::System.IntPtr instance, short x0, short x1, short x2, short x3, short x4, short x5, short x6, short x7, short x8, short x9, short x10, short x11, short x12, short x13, short x14, short x15);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU16@Data256@asmjit@@QEAAXGGGGGGGGGGGGGGGG@Z")]
                internal static extern void SetU16(global::System.IntPtr instance, ushort x0, ushort x1, ushort x2, ushort x3, ushort x4, ushort x5, ushort x6, ushort x7, ushort x8, ushort x9, ushort x10, ushort x11, ushort x12, ushort x13, ushort x14, ushort x15);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI32@Data256@asmjit@@QEAAXH@Z")]
                internal static extern void SetI32(global::System.IntPtr instance, int x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU32@Data256@asmjit@@QEAAXI@Z")]
                internal static extern void SetU32(global::System.IntPtr instance, uint x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI32@Data256@asmjit@@QEAAXHHHHHHHH@Z")]
                internal static extern void SetI32(global::System.IntPtr instance, int x0, int x1, int x2, int x3, int x4, int x5, int x6, int x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU32@Data256@asmjit@@QEAAXIIIIIIII@Z")]
                internal static extern void SetU32(global::System.IntPtr instance, uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI64@Data256@asmjit@@QEAAX_J@Z")]
                internal static extern void SetI64(global::System.IntPtr instance, long x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU64@Data256@asmjit@@QEAAX_K@Z")]
                internal static extern void SetU64(global::System.IntPtr instance, ulong x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setI64@Data256@asmjit@@QEAAX_J000@Z")]
                internal static extern void SetI64(global::System.IntPtr instance, long x0, long x1, long x2, long x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setU64@Data256@asmjit@@QEAAX_K000@Z")]
                internal static extern void SetU64(global::System.IntPtr instance, ulong x0, ulong x1, ulong x2, ulong x3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF32@Data256@asmjit@@QEAAXM@Z")]
                internal static extern void SetF32(global::System.IntPtr instance, float x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF32@Data256@asmjit@@QEAAXMMMMMMMM@Z")]
                internal static extern void SetF32(global::System.IntPtr instance, float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF64@Data256@asmjit@@QEAAXN@Z")]
                internal static extern void SetF64(global::System.IntPtr instance, double x0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setF64@Data256@asmjit@@QEAAXNNNN@Z")]
                internal static extern void SetF64(global::System.IntPtr instance, double x0, double x1, double x2, double x3);
            }

            private Data256.__Internal __instance;
            internal Data256.__Internal __Instance { get { return __instance; } }

            internal static global::GraphEngine.Jit.Native.Asmjit.Data256 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Data256(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Data256 __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Data256(native, skipVTables);
            }

            private Data256(global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Data256(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal*) native;
            }

            public Data256(global::GraphEngine.Jit.Native.Asmjit.Data256 _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Set all thirty two 8-bit signed integers.</summary>
            public void SetI8(sbyte x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI8(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all thirty two 8-bit unsigned integers.</summary>
            public void SetU8(byte x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU8(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all thirty two 8-bit signed integers.</summary>
            public void SetI8(sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7, sbyte x8, sbyte x9, sbyte x10, sbyte x11, sbyte x12, sbyte x13, sbyte x14, sbyte x15, sbyte x16, sbyte x17, sbyte x18, sbyte x19, sbyte x20, sbyte x21, sbyte x22, sbyte x23, sbyte x24, sbyte x25, sbyte x26, sbyte x27, sbyte x28, sbyte x29, sbyte x30, sbyte x31)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI8(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31);
                }
            }

            /// <summary>Set all thirty two 8-bit unsigned integers.</summary>
            public void SetU8(byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7, byte x8, byte x9, byte x10, byte x11, byte x12, byte x13, byte x14, byte x15, byte x16, byte x17, byte x18, byte x19, byte x20, byte x21, byte x22, byte x23, byte x24, byte x25, byte x26, byte x27, byte x28, byte x29, byte x30, byte x31)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU8(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31);
                }
            }

            /// <summary>Set all sixteen 16-bit signed integers.</summary>
            public void SetI16(short x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI16(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all eight 16-bit unsigned integers.</summary>
            public void SetU16(ushort x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU16(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all sixteen 16-bit signed integers.</summary>
            public void SetI16(short x0, short x1, short x2, short x3, short x4, short x5, short x6, short x7, short x8, short x9, short x10, short x11, short x12, short x13, short x14, short x15)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI16(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
                }
            }

            /// <summary>Set all sixteen 16-bit unsigned integers.</summary>
            public void SetU16(ushort x0, ushort x1, ushort x2, ushort x3, ushort x4, ushort x5, ushort x6, ushort x7, ushort x8, ushort x9, ushort x10, ushort x11, ushort x12, ushort x13, ushort x14, ushort x15)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU16(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
                }
            }

            /// <summary>Set all eight 32-bit signed integers.</summary>
            public void SetI32(int x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI32(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all eight 32-bit unsigned integers.</summary>
            public void SetU32(uint x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU32(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all eight 32-bit signed integers.</summary>
            public void SetI32(int x0, int x1, int x2, int x3, int x4, int x5, int x6, int x7)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI32(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7);
                }
            }

            /// <summary>Set all eight 32-bit unsigned integers.</summary>
            public void SetU32(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU32(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7);
                }
            }

            /// <summary>Set all four 64-bit signed integers.</summary>
            public void SetI64(long x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI64(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all four 64-bit unsigned integers.</summary>
            public void SetU64(ulong x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU64(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all four 64-bit signed integers.</summary>
            public void SetI64(long x0, long x1, long x2, long x3)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetI64(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3);
                }
            }

            /// <summary>Set all four 64-bit unsigned integers.</summary>
            public void SetU64(ulong x0, ulong x1, ulong x2, ulong x3)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetU64(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3);
                }
            }

            /// <summary>Set all eight SP-FP floats.</summary>
            public void SetF32(float x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF32(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all eight SP-FP floats.</summary>
            public void SetF32(float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF32(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3, x4, x5, x6, x7);
                }
            }

            /// <summary>Set all four DP-FP floats.</summary>
            public void SetF64(double x0)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF64(new global::System.IntPtr(__instancePtr), x0);
                }
            }

            /// <summary>Set all four DP-FP floats.</summary>
            public void SetF64(double x0, double x1, double x2, double x3)
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.SetF64(new global::System.IntPtr(__instancePtr), x0, x1, x2, x3);
                }
            }

            /// <summary>Set all thirty two 8-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromI8(sbyte x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromI8(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all thirty two 8-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromU8(byte x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromU8(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all thirty two 8-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromI8(sbyte x0, sbyte x1, sbyte x2, sbyte x3, sbyte x4, sbyte x5, sbyte x6, sbyte x7, sbyte x8, sbyte x9, sbyte x10, sbyte x11, sbyte x12, sbyte x13, sbyte x14, sbyte x15, sbyte x16, sbyte x17, sbyte x18, sbyte x19, sbyte x20, sbyte x21, sbyte x22, sbyte x23, sbyte x24, sbyte x25, sbyte x26, sbyte x27, sbyte x28, sbyte x29, sbyte x30, sbyte x31)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromI8(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all thirty two 8-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromU8(byte x0, byte x1, byte x2, byte x3, byte x4, byte x5, byte x6, byte x7, byte x8, byte x9, byte x10, byte x11, byte x12, byte x13, byte x14, byte x15, byte x16, byte x17, byte x18, byte x19, byte x20, byte x21, byte x22, byte x23, byte x24, byte x25, byte x26, byte x27, byte x28, byte x29, byte x30, byte x31)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromU8(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all sixteen 16-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromI16(short x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromI16(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all sixteen 16-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromU16(ushort x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromU16(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all sixteen 16-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromI16(short x0, short x1, short x2, short x3, short x4, short x5, short x6, short x7, short x8, short x9, short x10, short x11, short x12, short x13, short x14, short x15)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromI16(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all sixteen 16-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromU16(ushort x0, ushort x1, ushort x2, ushort x3, ushort x4, ushort x5, ushort x6, ushort x7, ushort x8, ushort x9, ushort x10, ushort x11, ushort x12, ushort x13, ushort x14, ushort x15)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromU16(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 32-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromI32(int x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromI32(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 32-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromU32(uint x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromU32(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 32-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromI32(int x0, int x1, int x2, int x3, int x4, int x5, int x6, int x7)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromI32(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all eight 32-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromU32(uint x0, uint x1, uint x2, uint x3, uint x4, uint x5, uint x6, uint x7)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromU32(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all four 64-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromI64(long x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromI64(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all four 64-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromU64(ulong x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromU64(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all four 64-bit signed integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromI64(long x0, long x1, long x2, long x3)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromI64(new IntPtr(&__ret), x0, x1, x2, x3);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all four 64-bit unsigned integers.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromU64(ulong x0, ulong x1, ulong x2, ulong x3)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromU64(new IntPtr(&__ret), x0, x1, x2, x3);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all eight SP-FP floats.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromF32(float x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromF32(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all eight SP-FP floats.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromF32(float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromF32(new IntPtr(&__ret), x0, x1, x2, x3, x4, x5, x6, x7);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all four DP-FP floats.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromF64(double x0)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromF64(new IntPtr(&__ret), x0);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }

            /// <summary>Set all four DP-FP floats.</summary>
            public static global::GraphEngine.Jit.Native.Asmjit.Data256 FromF64(double x0, double x1, double x2, double x3)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Data256.__Internal();
                __Internal.FromF64(new IntPtr(&__ret), x0, x1, x2, x3);
                return global::GraphEngine.Jit.Native.Asmjit.Data256.__CreateInstance(__ret);
            }
        }
    }

    namespace Asmjit
    {
        namespace ZoneVector
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public unsafe partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _data;

                [FieldOffset(8)]
                internal ulong _length;

                [FieldOffset(16)]
                internal ulong _capacity;
            }
        }

        namespace ZoneHash
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public unsafe partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _heap;

                [FieldOffset(8)]
                internal ulong _size;

                [FieldOffset(16)]
                internal uint _bucketsCount;

                [FieldOffset(20)]
                internal uint _bucketsGrow;

                [FieldOffset(24)]
                internal global::System.IntPtr _data;

                [FieldOffset(32)]
                internal fixed long _embedded[1];
            }
        }

        /// <summary>Memory zone.</summary>
        /// <remarks>
        /// <para>Zone is an incremental memory allocator that allocates memory by simply</para>
        /// <para>incrementing a pointer. It allocates blocks of memory by using standard</para>
        /// <para>C `malloc`, but divides these blocks into smaller segments requested by</para>
        /// <para>calling `Zone::alloc()` and friends.</para>
        /// <para>Zone has no function to release the allocated memory. It has to be released</para>
        /// <para>all at once by calling `reset()`. If you need a more friendly allocator that</para>
        /// <para>also supports `release()`, consider using</para>
        /// </remarks>
        public unsafe partial class Zone : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _ptr;

                [FieldOffset(8)]
                internal global::System.IntPtr _end;

                [FieldOffset(16)]
                internal global::System.IntPtr _block;

                [FieldOffset(24)]
                internal uint _blockSize;

                [FieldOffset(28)]
                internal uint _blockAlignmentShift;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Zone@asmjit@@QEAA@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint blockSize, uint blockAlignment);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Zone@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1Zone@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@Zone@asmjit@@QEAAX_N@Z")]
                internal static extern void Reset(global::System.IntPtr instance, bool releaseMemory);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?alloc@Zone@asmjit@@QEAAPEAX_K@Z")]
                internal static extern global::System.IntPtr Alloc(global::System.IntPtr instance, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?allocNoCheck@Zone@asmjit@@QEAAPEAX_K@Z")]
                internal static extern global::System.IntPtr AllocNoCheck(global::System.IntPtr instance, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?allocZeroed@Zone@asmjit@@QEAAPEAX_K@Z")]
                internal static extern global::System.IntPtr AllocZeroed(global::System.IntPtr instance, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_alloc@Zone@asmjit@@QEAAPEAX_K@Z")]
                internal static extern global::System.IntPtr _alloc(global::System.IntPtr instance, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?dup@Zone@asmjit@@QEAAPEAXPEBX_K_N@Z")]
                internal static extern global::System.IntPtr Dup(global::System.IntPtr instance, global::System.IntPtr data, ulong size, bool nullTerminate);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?sformat@Zone@asmjit@@QEAAPEADPEBDZZ")]
                internal static extern sbyte* Sformat(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCursor@Zone@asmjit@@QEAAPEAEXZ")]
                internal static extern byte* GetCursor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setCursor@Zone@asmjit@@QEAAXPEAE@Z")]
                internal static extern void SetCursor(global::System.IntPtr instance, byte* p);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBlockSize@Zone@asmjit@@QEBAIXZ")]
                internal static extern uint GetBlockSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBlockAlignment@Zone@asmjit@@QEBAIXZ")]
                internal static extern uint GetBlockAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRemainingSize@Zone@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetRemainingSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getEnd@Zone@asmjit@@QEAAPEAEXZ")]
                internal static extern byte* GetEnd(global::System.IntPtr instance);
            }

            [Flags]
            public enum KZoneOverhead
            {
                /// <summary>Zone allocator overhead.</summary>
                kZoneOverhead = 64
            }

            /// <summary>A single block of memory.</summary>
            public unsafe partial class Block : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr prev;

                    [FieldOffset(8)]
                    internal global::System.IntPtr next;

                    [FieldOffset(16)]
                    internal ulong size;

                    [FieldOffset(24)]
                    internal fixed byte data[8];

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Block@Zone@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Zone.Block> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Zone.Block>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.Zone.Block __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Zone.Block(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.Zone.Block __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Zone.Block.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.Zone.Block(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Zone.Block.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Zone.Block.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.Zone.Block.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Block(global::GraphEngine.Jit.Native.Asmjit.Zone.Block.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Block(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Block()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Zone.Block.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Block(global::GraphEngine.Jit.Native.Asmjit.Zone.Block _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Zone.Block.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.Zone.Block.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Zone.Block.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.Zone.Block __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Zone> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Zone>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.Zone __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Zone(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Zone __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Zone(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Zone(global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Zone(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new instance of `Zone` allocator.</summary>
            /// <remarks>
            /// <para>The `blockSize` parameter describes the default size of the block. If the</para>
            /// <para>`size` parameter passed to `alloc()` is greater than the default size</para>
            /// <para>`Zone` will allocate and use a larger block, but it will not change the</para>
            /// <para>default `blockSize`.</para>
            /// <para>It's not required, but it's good practice to set `blockSize` to a</para>
            /// <para>reasonable value that depends on the usage of `Zone`. Greater block sizes</para>
            /// <para>are generally safer and perform better than unreasonably low values.</para>
            /// </remarks>
            public Zone(uint blockSize, uint blockAlignment)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), blockSize, blockAlignment);
            }

            public Zone(global::GraphEngine.Jit.Native.Asmjit.Zone _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.Zone __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Reset the `Zone` invalidating all blocks allocated.</summary>
            /// <remarks>If `releaseMemory` is true all buffers will be released to the system.</remarks>
            public void Reset(bool releaseMemory)
            {
                __Internal.Reset((__Instance + __PointerAdjustment), releaseMemory);
            }

            /// <summary>
            /// <para>if (!obj) {</para>
            /// <para>// Handle out of memory error.</para>
            /// <para>}</para>
            /// </summary>
            /// <remarks>
            /// <para>// Placement `new` and `delete` operators can be used to instantiate it.</para>
            /// <para>new(obj) Object();</para>
            /// <para>// ... lifetime of your objects ...</para>
            /// <para>// To destroy the instance (if required).</para>
            /// <para>obj-&gt;~Object();</para>
            /// <para>// Reset or destroy `Zone`.</para>
            /// <para>zone.reset();</para>
            /// <para>~~~</para>
            /// </remarks>
            public global::System.IntPtr Alloc(ulong size)
            {
                var __ret = __Internal.Alloc((__Instance + __PointerAdjustment), size);
                return __ret;
            }

            /// <summary>Allocate `size` bytes without any checks.</summary>
            /// <remarks>
            /// <para>Can only be called if `getRemainingSize()` returns size at least equal</para>
            /// <para>to `size`.</para>
            /// </remarks>
            public global::System.IntPtr AllocNoCheck(ulong size)
            {
                var __ret = __Internal.AllocNoCheck((__Instance + __PointerAdjustment), size);
                return __ret;
            }

            /// <summary>Allocate `size` bytes of zeroed memory.</summary>
            /// <remarks>See</remarks>
            public global::System.IntPtr AllocZeroed(ulong size)
            {
                var __ret = __Internal.AllocZeroed((__Instance + __PointerAdjustment), size);
                return __ret;
            }


            public global::System.IntPtr _alloc(ulong size)
            {
                var __ret = __Internal._alloc((__Instance + __PointerAdjustment), size);
                return __ret;
            }

            /// <summary>Helper to duplicate data.</summary>
            public global::System.IntPtr Dup(global::System.IntPtr data, ulong size, bool nullTerminate)
            {
                var __ret = __Internal.Dup((__Instance + __PointerAdjustment), data, size, nullTerminate);
                return __ret;
            }

            /// <summary>Helper to duplicate formatted string, maximum length is 256 bytes.</summary>
            public sbyte* Sformat(string str)
            {
                var __ret = __Internal.Sformat((__Instance + __PointerAdjustment), str);
                return __ret;
            }

            /// <summary>Get the current zone cursor (dangerous).</summary>
            /// <remarks>
            /// <para>This is a function that can be used to get exclusive access to the current</para>
            /// <para>block's memory buffer.</para>
            /// <para>Set the current zone cursor to `p` (must match the current block).</para>
            /// <para>This is a counterpart of `getZoneCursor()`.</para>
            /// </remarks>
            public byte* Cursor
            {
                get
                {
                    var __ret = __Internal.GetCursor((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetCursor((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get the default block size.</summary>
            public uint BlockSize
            {
                get
                {
                    var __ret = __Internal.GetBlockSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the default block alignment.</summary>
            public uint BlockAlignment
            {
                get
                {
                    var __ret = __Internal.GetBlockAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get remaining size of the current block.</summary>
            public ulong RemainingSize
            {
                get
                {
                    var __ret = __Internal.GetRemainingSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the end of the current zone block, only useful if you use `getCursor()`.</summary>
            public byte* End
            {
                get
                {
                    var __ret = __Internal.GetEnd((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Zone-based memory allocator that uses an existing</summary>
        /// <remarks>
        /// <para>a `release()` functionality on top of it. It uses</para>
        /// <para>that can be pooled, and uses libc `malloc()` for chunks that are large.</para>
        /// <para>The advantage of ZoneHeap is that it can allocate small chunks of memory</para>
        /// <para>really fast, and these chunks, when released, will be reused by consecutive</para>
        /// <para>calls to `alloc()`. Also, since ZoneHeap uses</para>
        /// <para>ZoneHeap is used by AsmJit containers to make containers having only</para>
        /// <para>few elements fast (and lightweight) and to allow them to grow and use</para>
        /// <para>dynamic blocks when require more storage.</para>
        /// </remarks>
        public unsafe partial class ZoneHeap : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 96)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _zone;

                [FieldOffset(8)]
                internal fixed long _slots[10];

                [FieldOffset(88)]
                internal global::System.IntPtr _dynamicBlocks;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ZoneHeap@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ZoneHeap@asmjit@@QEAA@PEAVZone@1@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr zone);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1ZoneHeap@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@ZoneHeap@asmjit@@QEAAXPEAVZone@2@@Z")]
                internal static extern void Init(global::System.IntPtr instance, global::System.IntPtr zone);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@ZoneHeap@asmjit@@QEAAXPEAVZone@2@@Z")]
                internal static extern void Reset(global::System.IntPtr instance, global::System.IntPtr zone);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_getSlotIndex@ZoneHeap@asmjit@@SA_N_KAEAI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetSlotIndex(ulong size, uint* slot);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_getSlotIndex@ZoneHeap@asmjit@@SA_N_KAEAIAEA_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetSlotIndex(ulong size, uint* slot, ulong* allocatedSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_alloc@ZoneHeap@asmjit@@QEAAPEAX_KAEA_K@Z")]
                internal static extern global::System.IntPtr Alloc(global::System.IntPtr instance, ulong size, ulong* allocatedSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_allocZeroed@ZoneHeap@asmjit@@QEAAPEAX_KAEA_K@Z")]
                internal static extern global::System.IntPtr AllocZeroed(global::System.IntPtr instance, ulong size, ulong* allocatedSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_releaseDynamic@ZoneHeap@asmjit@@QEAAXPEAX_K@Z")]
                internal static extern void ReleaseDynamic(global::System.IntPtr instance, global::System.IntPtr p, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?alloc@ZoneHeap@asmjit@@QEAAPEAX_K@Z")]
                internal static extern global::System.IntPtr Alloc(global::System.IntPtr instance, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?alloc@ZoneHeap@asmjit@@QEAAPEAX_KAEA_K@Z")]
                internal static extern global::System.IntPtr alloc(global::System.IntPtr instance, ulong size, ulong* allocatedSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?allocZeroed@ZoneHeap@asmjit@@QEAAPEAX_K@Z")]
                internal static extern global::System.IntPtr AllocZeroed(global::System.IntPtr instance, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?allocZeroed@ZoneHeap@asmjit@@QEAAPEAX_KAEA_K@Z")]
                internal static extern global::System.IntPtr allocZeroed(global::System.IntPtr instance, ulong size, ulong* allocatedSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?release@ZoneHeap@asmjit@@QEAAXPEAX_K@Z")]
                internal static extern void Release(global::System.IntPtr instance, global::System.IntPtr p, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInitialized@ZoneHeap@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInitialized(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getZone@ZoneHeap@asmjit@@QEBAPEAVZone@2@XZ")]
                internal static extern global::System.IntPtr GetZone(global::System.IntPtr instance);
            }

            public enum _0
            {
                /// <summary>How many bytes per a low granularity pool (has to be at least 16).</summary>
                kLoGranularity = 32,
                /// <summary>Number of slots of a low granularity pool.</summary>
                kLoCount = 4,
                /// <summary>Maximum size of a block that can be allocated in a low granularity pool.</summary>
                kLoMaxSize = 128,
                /// <summary>How many bytes per a high granularity pool.</summary>
                kHiGranularity = 64,
                /// <summary>Number of slots of a high granularity pool.</summary>
                kHiCount = 6,
                /// <summary>Maximum size of a block that can be allocated in a high granularity pool.</summary>
                kHiMaxSize = 512,
                /// <summary>Alignment of every pointer returned by `alloc()`.</summary>
                kBlockAlignment = 32
            }

            /// <summary>Single-linked list used to store unused chunks.</summary>
            public unsafe partial class Slot : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr next;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Slot@ZoneHeap@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Slot(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Slot(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Slot()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Slot(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.Slot __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            /// <summary>
            /// <para>A block of memory that has been allocated dynamically and is not part of</para>
            /// <para>block-list used by the allocator. This is used to keep track of all these</para>
            /// <para>blocks so they can be freed by `reset()` if not freed explicitly.</para>
            /// </summary>
            public unsafe partial class DynamicBlock : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr prev;

                    [FieldOffset(8)]
                    internal global::System.IntPtr next;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DynamicBlock@ZoneHeap@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private DynamicBlock(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DynamicBlock(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DynamicBlock()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public DynamicBlock(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.DynamicBlock __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHeap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHeap>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHeap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneHeap(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHeap __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneHeap(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ZoneHeap(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ZoneHeap(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `ZoneHeap`.</summary>
            /// <remarks>NOTE: To use it, you must first `init()` it.</remarks>
            public ZoneHeap()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            /// <summary>Create a new `ZoneHeap` initialized to use `zone`.</summary>
            public ZoneHeap(global::GraphEngine.Jit.Native.Asmjit.Zone zone)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(zone, null) ? global::System.IntPtr.Zero : zone.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ZoneHeap __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Convenience method to initialize the `ZoneHeap` with `zone`.</summary>
            /// <remarks>It's the same as calling `reset(zone)`.</remarks>
            public void Init(global::GraphEngine.Jit.Native.Asmjit.Zone zone)
            {
                var __arg0 = ReferenceEquals(zone, null) ? global::System.IntPtr.Zero : zone.__Instance;
                __Internal.Init((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>
            /// <para>Reset this `ZoneHeap` and also forget about the current `Zone` which</para>
            /// <para>is attached (if any). Reset optionally attaches a new `zone` passed, or</para>
            /// <para>keeps the `ZoneHeap` in an uninitialized state, if `zone` is null.</para>
            /// </summary>
            public void Reset(global::GraphEngine.Jit.Native.Asmjit.Zone zone)
            {
                var __arg0 = ReferenceEquals(zone, null) ? global::System.IntPtr.Zero : zone.__Instance;
                __Internal.Reset((__Instance + __PointerAdjustment), __arg0);
            }

            public global::System.IntPtr Alloc(ulong size, ref ulong allocatedSize)
            {
                fixed (ulong* __refParamPtr1 = &allocatedSize)
                {
                    var __arg1 = __refParamPtr1;
                    var __ret = __Internal.Alloc((__Instance + __PointerAdjustment), size, __arg1);
                    return __ret;
                }
            }

            public global::System.IntPtr AllocZeroed(ulong size, ref ulong allocatedSize)
            {
                fixed (ulong* __refParamPtr1 = &allocatedSize)
                {
                    var __arg1 = __refParamPtr1;
                    var __ret = __Internal.AllocZeroed((__Instance + __PointerAdjustment), size, __arg1);
                    return __ret;
                }
            }

            public void ReleaseDynamic(global::System.IntPtr p, ulong size)
            {
                __Internal.ReleaseDynamic((__Instance + __PointerAdjustment), p, size);
            }

            /// <summary>Allocate `size` bytes of memory, ideally from an available pool.</summary>
            /// <remarks>NOTE: `size` can't be zero, it will assert in debug mode in such case.</remarks>
            public global::System.IntPtr Alloc(ulong size)
            {
                var __ret = __Internal.Alloc((__Instance + __PointerAdjustment), size);
                return __ret;
            }

            /// <summary>
            /// <para>Like `alloc(size)`, but provides a second argument `allocatedSize` that</para>
            /// <para>provides a way to know how big the block returned actually is. This is</para>
            /// <para>useful for containers to prevent growing too early.</para>
            /// </summary>
            public global::System.IntPtr alloc(ulong size, ref ulong allocatedSize)
            {
                fixed (ulong* __refParamPtr1 = &allocatedSize)
                {
                    var __arg1 = __refParamPtr1;
                    var __ret = __Internal.alloc((__Instance + __PointerAdjustment), size, __arg1);
                    return __ret;
                }
            }

            /// <summary>Like `alloc(size)`, but returns zeroed memory.</summary>
            public global::System.IntPtr AllocZeroed(ulong size)
            {
                var __ret = __Internal.AllocZeroed((__Instance + __PointerAdjustment), size);
                return __ret;
            }

            /// <summary>Like `alloc(size, allocatedSize)`, but returns zeroed memory.</summary>
            public global::System.IntPtr allocZeroed(ulong size, ref ulong allocatedSize)
            {
                fixed (ulong* __refParamPtr1 = &allocatedSize)
                {
                    var __arg1 = __refParamPtr1;
                    var __ret = __Internal.allocZeroed((__Instance + __PointerAdjustment), size, __arg1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Release the memory previously allocated by `alloc()`. The `size` argument</para>
            /// <para>has to be the same as used to call `alloc()` or `allocatedSize` returned</para>
            /// <para>by `alloc()`.</para>
            /// </summary>
            public void Release(global::System.IntPtr p, ulong size)
            {
                __Internal.Release((__Instance + __PointerAdjustment), p, size);
            }

            /// <summary>
            /// <para>Get the slot index to be used for `size`. Returns `true` if a valid slot</para>
            /// <para>has been written to `slot` and `allocatedSize` has been filled with slot</para>
            /// <para>exact size (`allocatedSize` can be equal or slightly greater than `size`).</para>
            /// </summary>
            public static bool GetSlotIndex(ulong size, ref uint slot)
            {
                fixed (uint* __refParamPtr1 = &slot)
                {
                    var __arg1 = __refParamPtr1;
                    var __ret = __Internal.GetSlotIndex(size, __arg1);
                    return __ret;
                }
            }


            public static bool GetSlotIndex(ulong size, ref uint slot, ref ulong allocatedSize)
            {
                fixed (uint* __refParamPtr1 = &slot)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (ulong* __refParamPtr2 = &allocatedSize)
                    {
                        var __arg2 = __refParamPtr2;
                        var __ret = __Internal.GetSlotIndex(size, __arg1, __arg2);
                        return __ret;
                    }
                }
            }

            /// <summary>Get if the `ZoneHeap` is initialized (i.e. has `Zone`).</summary>
            public bool IsInitialized
            {
                get
                {
                    var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the `Zone` the `ZoneHeap` is using, or null if it's not initialized.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Zone Zone
            {
                get
                {
                    var __ret = __Internal.GetZone((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.Zone __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.Zone.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.Zone) global::GraphEngine.Jit.Native.Asmjit.Zone.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.Zone.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }


        public unsafe partial class ZoneVectorBase : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _data;

                [FieldOffset(8)]
                internal ulong _length;

                [FieldOffset(16)]
                internal ulong _capacity;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ZoneVectorBase@asmjit@@IEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clear@ZoneVectorBase@asmjit@@QEAAXXZ")]
                internal static extern void Clear(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@ZoneVectorBase@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?truncate@ZoneVectorBase@asmjit@@QEAAX_K@Z")]
                internal static extern void Truncate(global::System.IntPtr instance, ulong n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_release@ZoneVectorBase@asmjit@@IEAAXPEAVZoneHeap@2@_K@Z")]
                internal static extern void Release(global::System.IntPtr instance, global::System.IntPtr heap, ulong sizeOfT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_grow@ZoneVectorBase@asmjit@@IEAAIPEAVZoneHeap@2@_K1@Z")]
                internal static extern uint Grow(global::System.IntPtr instance, global::System.IntPtr heap, ulong sizeOfT, ulong n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_resize@ZoneVectorBase@asmjit@@IEAAIPEAVZoneHeap@2@_K1@Z")]
                internal static extern uint Resize(global::System.IntPtr instance, global::System.IntPtr heap, ulong sizeOfT, ulong n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_reserve@ZoneVectorBase@asmjit@@IEAAIPEAVZoneHeap@2@_K1@Z")]
                internal static extern uint Reserve(global::System.IntPtr instance, global::System.IntPtr heap, ulong sizeOfT, ulong n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isEmpty@ZoneVectorBase@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEmpty(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLength@ZoneVectorBase@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetLength(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCapacity@ZoneVectorBase@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetCapacity(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ZoneVectorBase(global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ZoneVectorBase(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new instance of `ZoneVectorBase`.</summary>
            protected ZoneVectorBase()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ZoneVectorBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Makes the vector empty (won't change the capacity or data pointer).</summary>
            public void Clear()
            {
                __Internal.Clear((__Instance + __PointerAdjustment));
            }

            /// <summary>Reset the vector data and set its `length` to zero.</summary>
            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Truncate the vector to at most `n` items.</summary>
            public void Truncate(ulong n)
            {
                __Internal.Truncate((__Instance + __PointerAdjustment), n);
            }

            protected void Release(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap, ulong sizeOfT)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                __Internal.Release((__Instance + __PointerAdjustment), __arg0, sizeOfT);
            }

            protected uint Grow(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap, ulong sizeOfT, ulong n)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                var __ret = __Internal.Grow((__Instance + __PointerAdjustment), __arg0, sizeOfT, n);
                return __ret;
            }

            protected uint Resize(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap, ulong sizeOfT, ulong n)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                var __ret = __Internal.Resize((__Instance + __PointerAdjustment), __arg0, sizeOfT, n);
                return __ret;
            }

            protected uint Reserve(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap, ulong sizeOfT, ulong n)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                var __ret = __Internal.Reserve((__Instance + __PointerAdjustment), __arg0, sizeOfT, n);
                return __ret;
            }

            /// <summary>Get if the vector is empty.</summary>
            public bool IsEmpty
            {
                get
                {
                    var __ret = __Internal.IsEmpty((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get vector length.</summary>
            public ulong Length
            {
                get
                {
                    var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get vector capacity.</summary>
            public ulong Capacity
            {
                get
                {
                    var __ret = __Internal.GetCapacity((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        public unsafe partial class ZoneBitVector : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _data;

                [FieldOffset(8)]
                internal ulong _length;

                [FieldOffset(16)]
                internal ulong _capacity;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ZoneBitVector@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_wordsPerBits@ZoneBitVector@asmjit@@SA_K_K@Z")]
                internal static extern ulong WordsPerBits(ulong nBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_patternFromBit@ZoneBitVector@asmjit@@SA_K_N@Z")]
                internal static extern ulong PatternFromBit(bool bit);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clear@ZoneBitVector@asmjit@@QEAAXXZ")]
                internal static extern void Clear(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@ZoneBitVector@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?truncate@ZoneBitVector@asmjit@@QEAAX_K@Z")]
                internal static extern void Truncate(global::System.IntPtr instance, ulong newLength);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAt@ZoneBitVector@asmjit@@QEBA_N_K@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetAt(global::System.IntPtr instance, ulong index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setAt@ZoneBitVector@asmjit@@QEAAX_K_N@Z")]
                internal static extern void SetAt(global::System.IntPtr instance, ulong index, bool value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?toggleAt@ZoneBitVector@asmjit@@QEAAX_K@Z")]
                internal static extern void ToggleAt(global::System.IntPtr instance, ulong index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?append@ZoneBitVector@asmjit@@QEAAIPEAVZoneHeap@2@_N@Z")]
                internal static extern uint Append(global::System.IntPtr instance, global::System.IntPtr heap, bool value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fill@ZoneBitVector@asmjit@@QEAAI_K0_N@Z")]
                internal static extern uint Fill(global::System.IntPtr instance, ulong fromIndex, ulong toIndex, bool value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?and_@ZoneBitVector@asmjit@@QEAAXAEBV12@@Z")]
                internal static extern void And(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNot@ZoneBitVector@asmjit@@QEAAXAEBV12@@Z")]
                internal static extern void AndNot(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?or_@ZoneBitVector@asmjit@@QEAAXAEBV12@@Z")]
                internal static extern void Or(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_clearUnusedBits@ZoneBitVector@asmjit@@QEAAXXZ")]
                internal static extern void ClearUnusedBits(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?release@ZoneBitVector@asmjit@@QEAAXPEAVZoneHeap@2@@Z")]
                internal static extern void Release(global::System.IntPtr instance, global::System.IntPtr heap);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resize@ZoneBitVector@asmjit@@QEAAIPEAVZoneHeap@2@_K_N@Z")]
                internal static extern uint Resize(global::System.IntPtr instance, global::System.IntPtr heap, ulong newLength, bool newBitsValue);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_resize@ZoneBitVector@asmjit@@QEAAIPEAVZoneHeap@2@_K1_N@Z")]
                internal static extern uint Resize(global::System.IntPtr instance, global::System.IntPtr heap, ulong newLength, ulong idealCapacity, bool newBitsValue);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_append@ZoneBitVector@asmjit@@QEAAIPEAVZoneHeap@2@_N@Z")]
                internal static extern uint _append(global::System.IntPtr instance, global::System.IntPtr heap, bool value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isEmpty@ZoneBitVector@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEmpty(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLength@ZoneBitVector@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetLength(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCapacity@ZoneBitVector@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetCapacity(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getData@ZoneBitVector@asmjit@@QEAAPEA_KXZ")]
                internal static extern ulong* GetData(global::System.IntPtr instance);
            }

            [Flags]
            public enum KBitsPerWord
            {
                kBitsPerWord = 64
            }

            /// <summary>Storage used to store a pack of bits (should by compatible with a machine word).</summary>
            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ZoneBitVector(global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ZoneBitVector(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ZoneBitVector()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Clear()
            {
                __Internal.Clear((__Instance + __PointerAdjustment));
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            public void Truncate(ulong newLength)
            {
                __Internal.Truncate((__Instance + __PointerAdjustment), newLength);
            }

            public bool GetAt(ulong index)
            {
                var __ret = __Internal.GetAt((__Instance + __PointerAdjustment), index);
                return __ret;
            }

            public void SetAt(ulong index, bool value)
            {
                __Internal.SetAt((__Instance + __PointerAdjustment), index, value);
            }

            public void ToggleAt(ulong index)
            {
                __Internal.ToggleAt((__Instance + __PointerAdjustment), index);
            }

            public uint Append(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap, bool value)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                var __ret = __Internal.Append((__Instance + __PointerAdjustment), __arg0, value);
                return __ret;
            }

            public uint Fill(ulong fromIndex, ulong toIndex, bool value)
            {
                var __ret = __Internal.Fill((__Instance + __PointerAdjustment), fromIndex, toIndex, value);
                return __ret;
            }

            public void And(global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.And((__Instance + __PointerAdjustment), __arg0);
            }

            public void AndNot(global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.AndNot((__Instance + __PointerAdjustment), __arg0);
            }

            public void Or(global::GraphEngine.Jit.Native.Asmjit.ZoneBitVector other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Or((__Instance + __PointerAdjustment), __arg0);
            }

            public void ClearUnusedBits()
            {
                __Internal.ClearUnusedBits((__Instance + __PointerAdjustment));
            }

            public void Release(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                __Internal.Release((__Instance + __PointerAdjustment), __arg0);
            }

            public uint Resize(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap, ulong newLength, bool newBitsValue)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                var __ret = __Internal.Resize((__Instance + __PointerAdjustment), __arg0, newLength, newBitsValue);
                return __ret;
            }

            public uint Resize(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap, ulong newLength, ulong idealCapacity, bool newBitsValue)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                var __ret = __Internal.Resize((__Instance + __PointerAdjustment), __arg0, newLength, idealCapacity, newBitsValue);
                return __ret;
            }

            public uint _append(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap, bool value)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                var __ret = __Internal._append((__Instance + __PointerAdjustment), __arg0, value);
                return __ret;
            }

            public static ulong WordsPerBits(ulong nBits)
            {
                var __ret = __Internal.WordsPerBits(nBits);
                return __ret;
            }

            public static ulong PatternFromBit(bool bit)
            {
                var __ret = __Internal.PatternFromBit(bit);
                return __ret;
            }

            /// <summary>Get if the bit-vector is empty (has no bits).</summary>
            public bool IsEmpty
            {
                get
                {
                    var __ret = __Internal.IsEmpty((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a length of this bit-vector (in bits).</summary>
            public ulong Length
            {
                get
                {
                    var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a capacity of this bit-vector (in bits).</summary>
            public ulong Capacity
            {
                get
                {
                    var __ret = __Internal.GetCapacity((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get data.</summary>
            public ulong* Data
            {
                get
                {
                    var __ret = __Internal.GetData((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        public unsafe partial class ZoneStackBase : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _heap;

                [FieldOffset(8)]
                internal fixed long _block[2];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ZoneStackBase@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ZoneStackBase@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1ZoneStackBase@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_init@ZoneStackBase@asmjit@@QEAAIPEAVZoneHeap@2@_K@Z")]
                internal static extern uint Init(global::System.IntPtr instance, global::System.IntPtr heap, ulong middleIndex);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@ZoneStackBase@asmjit@@QEAAIXZ")]
                internal static extern uint Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_prepareBlock@ZoneStackBase@asmjit@@QEAAII_K@Z")]
                internal static extern uint PrepareBlock(global::System.IntPtr instance, uint side, ulong initialIndex);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_cleanupBlock@ZoneStackBase@asmjit@@QEAAXI_K@Z")]
                internal static extern void CleanupBlock(global::System.IntPtr instance, uint side, ulong middleIndex);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInitialized@ZoneStackBase@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInitialized(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getHeap@ZoneStackBase@asmjit@@QEBAPEAVZoneHeap@2@XZ")]
                internal static extern global::System.IntPtr GetHeap(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isEmpty@ZoneStackBase@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEmpty(global::System.IntPtr instance);
            }

            public enum Side
            {
                kSideLeft = 0,
                kSideRight = 1
            }

            [Flags]
            public enum KBlockSize
            {
                kBlockSize = 512
            }

            public unsafe partial class Block : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed long _link[2];

                    [FieldOffset(16)]
                    internal global::System.IntPtr _start;

                    [FieldOffset(24)]
                    internal global::System.IntPtr _end;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Block@ZoneStackBase@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getPrev@Block@ZoneStackBase@asmjit@@QEBAPEAU123@XZ")]
                    internal static extern global::System.IntPtr GetPrev(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setPrev@Block@ZoneStackBase@asmjit@@QEAAXPEAU123@@Z")]
                    internal static extern void SetPrev(global::System.IntPtr instance, global::System.IntPtr block);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getNext@Block@ZoneStackBase@asmjit@@QEBAPEAU123@XZ")]
                    internal static extern global::System.IntPtr GetNext(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setNext@Block@ZoneStackBase@asmjit@@QEAAXPEAU123@@Z")]
                    internal static extern void SetNext(global::System.IntPtr instance, global::System.IntPtr block);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isEmpty@Block@ZoneStackBase@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsEmpty(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Block(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Block(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Block()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Block(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block Prev
                {
                    get
                    {
                        var __ret = __Internal.GetPrev((__Instance + __PointerAdjustment));
                        global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block __result0;
                        if (__ret == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.NativeToManagedMap.ContainsKey(__ret))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block) global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.NativeToManagedMap[__ret];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__CreateInstance(__ret);
                        return __result0;
                    }

                    set
                    {
                        var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                        __Internal.SetPrev((__Instance + __PointerAdjustment), __arg0);
                    }
                }

                public global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block Next
                {
                    get
                    {
                        var __ret = __Internal.GetNext((__Instance + __PointerAdjustment));
                        global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block __result0;
                        if (__ret == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.NativeToManagedMap.ContainsKey(__ret))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block) global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.NativeToManagedMap[__ret];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.Block.__CreateInstance(__ret);
                        return __result0;
                    }

                    set
                    {
                        var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                        __Internal.SetNext((__Instance + __PointerAdjustment), __arg0);
                    }
                }

                public bool IsEmpty
                {
                    get
                    {
                        var __ret = __Internal.IsEmpty((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ZoneStackBase(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ZoneStackBase(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ZoneStackBase()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public ZoneStackBase(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ZoneStackBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint Init(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap, ulong middleIndex)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                var __ret = __Internal.Init((__Instance + __PointerAdjustment), __arg0, middleIndex);
                return __ret;
            }

            public uint Reset()
            {
                var __ret = __Internal.Reset((__Instance + __PointerAdjustment));
                return __ret;
            }

            public uint PrepareBlock(uint side, ulong initialIndex)
            {
                var __ret = __Internal.PrepareBlock((__Instance + __PointerAdjustment), side, initialIndex);
                return __ret;
            }

            public void CleanupBlock(uint side, ulong middleIndex)
            {
                __Internal.CleanupBlock((__Instance + __PointerAdjustment), side, middleIndex);
            }

            public bool IsInitialized
            {
                get
                {
                    var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a `ZoneHeap` attached to this container.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.ZoneHeap Heap
            {
                get
                {
                    var __ret = __Internal.GetHeap((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.ZoneHeap __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ZoneHeap) global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public bool IsEmpty
            {
                get
                {
                    var __ret = __Internal.IsEmpty((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Node used by</summary>
        /// <remarks>
        /// <para>You must provide function `bool eq(const Key&amp;key)` in order to make</para>
        /// <para>`ZoneHash::get()` working.</para>
        /// </remarks>
        public unsafe partial class ZoneHashNode : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _hashNext;

                [FieldOffset(8)]
                internal uint _hVal;

                [FieldOffset(12)]
                internal uint _customData;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ZoneHashNode@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint hVal);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ZoneHashNode@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ZoneHashNode(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ZoneHashNode(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ZoneHashNode(uint hVal)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), hVal);
            }

            public ZoneHashNode(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class ZoneHashBase : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _heap;

                [FieldOffset(8)]
                internal ulong _size;

                [FieldOffset(16)]
                internal uint _bucketsCount;

                [FieldOffset(20)]
                internal uint _bucketsGrow;

                [FieldOffset(24)]
                internal global::System.IntPtr _data;

                [FieldOffset(32)]
                internal fixed long _embedded[1];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ZoneHashBase@asmjit@@QEAA@PEAVZoneHeap@1@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr heap);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1ZoneHashBase@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@ZoneHashBase@asmjit@@QEAAXPEAVZoneHeap@2@@Z")]
                internal static extern void Reset(global::System.IntPtr instance, global::System.IntPtr heap);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_rehash@ZoneHashBase@asmjit@@QEAAXI@Z")]
                internal static extern void Rehash(global::System.IntPtr instance, uint newCount);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_put@ZoneHashBase@asmjit@@QEAAPEAVZoneHashNode@2@PEAV32@@Z")]
                internal static extern global::System.IntPtr Put(global::System.IntPtr instance, global::System.IntPtr node);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_del@ZoneHashBase@asmjit@@QEAAPEAVZoneHashNode@2@PEAV32@@Z")]
                internal static extern global::System.IntPtr Del(global::System.IntPtr instance, global::System.IntPtr node);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInitialized@ZoneHashBase@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInitialized(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getHeap@ZoneHashBase@asmjit@@QEBAPEAVZoneHeap@2@XZ")]
                internal static extern global::System.IntPtr GetHeap(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSize@ZoneHashBase@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetSize(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ZoneHashBase(global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ZoneHashBase(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ZoneHashBase(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ZoneHashBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Reset(global::GraphEngine.Jit.Native.Asmjit.ZoneHeap heap)
            {
                var __arg0 = ReferenceEquals(heap, null) ? global::System.IntPtr.Zero : heap.__Instance;
                __Internal.Reset((__Instance + __PointerAdjustment), __arg0);
            }

            public void Rehash(uint newCount)
            {
                __Internal.Rehash((__Instance + __PointerAdjustment), newCount);
            }

            public global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode Put(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode node)
            {
                var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var __ret = __Internal.Put((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode) global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__CreateInstance(__ret);
                return __result0;
            }

            public global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode Del(global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode node)
            {
                var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var __ret = __Internal.Del((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode) global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode.__CreateInstance(__ret);
                return __result0;
            }

            public bool IsInitialized
            {
                get
                {
                    var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a `ZoneHeap` attached to this container.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.ZoneHeap Heap
            {
                get
                {
                    var __ret = __Internal.GetHeap((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.ZoneHeap __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ZoneHeap) global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public ulong Size
            {
                get
                {
                    var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Align mode.</summary>
        public enum AlignMode : uint
        {
            /// <summary>Align executable code.</summary>
            kAlignCode = 0,
            /// <summary>Align non-executable code.</summary>
            kAlignData = 1,
            /// <summary>Align by a sequence of zeros.</summary>
            kAlignZero = 2,
            /// <summary>Count of alignment modes.</summary>
            kAlignCount = 3
        }

        /// <summary>
        /// <para>Error handler can be used to override the default behavior of error handling</para>
        /// <para>available to all classes that inherit</para>
        /// </summary>
        public unsafe abstract partial class ErrorHandler : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_ErrorHandler;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ErrorHandler@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ErrorHandler@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1ErrorHandler@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ErrorHandler> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ErrorHandler>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ErrorHandler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ErrorHandlerInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ErrorHandler __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ErrorHandlerInternal(native, skipVTables);
            }

            protected ErrorHandler(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a new `ErrorHandler` instance.</summary>
            protected ErrorHandler()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.ErrorHandler");
            }

            protected ErrorHandler(global::GraphEngine.Jit.Native.Asmjit.ErrorHandler _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.ErrorHandler");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ErrorHandler __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.__Internal*) __Instance)->vfptr_ErrorHandler = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Error handler (abstract).</summary>
            /// <remarks>
            /// <para>Error handler is called after an error happened and before it's propagated</para>
            /// <para>to the caller. There are multiple ways how the error handler can be used:</para>
            /// <para>1. Returning `true` or `false` from `handleError()`. If `true` is returned</para>
            /// <para>it means that the error was reported and AsmJit can continue execution.</para>
            /// <para>The reported error still be propagated to the caller, but won't put the</para>
            /// <para>CodeEmitter into an error state (it won't set last-error). However,</para>
            /// <para>returning `false` means that the error cannot be handled - in such case</para>
            /// <para>it stores the error, which can be then retrieved by using `getLastError()`.</para>
            /// <para>Returning `false` is the default behavior when no error handler is present.</para>
            /// <para>To put the assembler into a non-error state again a `resetLastError()` must</para>
            /// <para>be called.</para>
            /// <para>2. Throwing an exception. AsmJit doesn't use exceptions and is completely</para>
            /// <para>exception-safe, but you can throw exception from your error handler if</para>
            /// <para>this way is the preferred way of handling errors in your project. Throwing</para>
            /// <para>an exception acts virtually as returning `true` as AsmJit won't be able</para>
            /// <para>to store the error because the exception changes execution path.</para>
            /// <para>3. Using plain old C's `setjmp()` and `longjmp()`. Asmjit always puts</para>
            /// <para>`CodeEmitter` to a consistent state before calling the `handleError()`</para>
            /// <para>so `longjmp()` can be used without any issues to cancel the code</para>
            /// <para>generation if an error occurred. There is no difference between</para>
            /// <para>exceptions and longjmp() from AsmJit's perspective.</para>
            /// </remarks>
            public abstract bool HandleError(uint err, string message, global::GraphEngine.Jit.Native.Asmjit.CodeEmitter origin);

            #region Virtual table interop

            // ASMJIT_API virtual ~ErrorHandler() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.ErrorHandler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // bool handleError(Error err, const char* message, CodeEmitter* origin) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_bool_IntPtr_uint_string_IntPtr _HandleErrorDelegateInstance;

            private static bool _HandleErrorDelegateHook(global::System.IntPtr instance, uint err, [MarshalAs(UnmanagedType.LPStr)] string message, global::System.IntPtr origin)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.ErrorHandler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __result2;
                if (origin == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.NativeToManagedMap.ContainsKey(origin))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.NativeToManagedMap[origin];
                else __result2 = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__CreateInstance(origin, skipVTables: true);
                var __ret = __target.HandleError(err, message, __result2);
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _HandleErrorDelegateInstance += _HandleErrorDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_HandleErrorDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        /// <summary>
        /// <para>Basic information about a code (or target). It describes its architecture,</para>
        /// <para>code generation mode (or optimization level), and base address.</para>
        /// </summary>
        public unsafe partial class CodeInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__Internal _archInfo;

                [FieldOffset(4)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo._.__Internal _;

                [FieldOffset(8)]
                internal ulong _baseAddress;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CodeInfo@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CodeInfo@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CodeInfo@asmjit@@QEAA@II_K@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint archType, uint archMode, ulong baseAddress);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@CodeInfo@asmjit@@QEAAXAEBV12@@Z")]
                internal static extern void Init(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@CodeInfo@asmjit@@QEAAXII_K@Z")]
                internal static extern void Init(global::System.IntPtr instance, uint archType, uint archMode, ulong baseAddress);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@CodeInfo@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setStackAlignment@CodeInfo@asmjit@@QEAAXE@Z")]
                internal static extern void SetStackAlignment(global::System.IntPtr instance, byte sa);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetBaseAddress@CodeInfo@asmjit@@QEAAXXZ")]
                internal static extern void ResetBaseAddress(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8CodeInfo@asmjit@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9CodeInfo@asmjit@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCdeclCallConv@CodeInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetCdeclCallConv(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setCdeclCallConv@CodeInfo@asmjit@@QEAAXI@Z")]
                internal static extern void SetCdeclCallConv(global::System.IntPtr instance, uint cc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStdCallConv@CodeInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetStdCallConv(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setStdCallConv@CodeInfo@asmjit@@QEAAXI@Z")]
                internal static extern void SetStdCallConv(global::System.IntPtr instance, uint cc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFastCallConv@CodeInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetFastCallConv(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setFastCallConv@CodeInfo@asmjit@@QEAAXI@Z")]
                internal static extern void SetFastCallConv(global::System.IntPtr instance, uint cc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBaseAddress@CodeInfo@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetBaseAddress(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setBaseAddress@CodeInfo@asmjit@@QEAAX_K@Z")]
                internal static extern void SetBaseAddress(global::System.IntPtr instance, ulong p);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInitialized@CodeInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInitialized(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchInfo@CodeInfo@asmjit@@QEBAAEBVArchInfo@2@XZ")]
                internal static extern global::System.IntPtr GetArchInfo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchType@CodeInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchSubType@CodeInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchSubType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGpSize@CodeInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetGpSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGpCount@CodeInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetGpCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getStackAlignment@CodeInfo@asmjit@@QEBAIXZ")]
                internal static extern uint GetStackAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasBaseAddress@CodeInfo@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasBaseAddress(global::System.IntPtr instance);
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo._.__.__Internal __;

                    [FieldOffset(0)]
                    internal uint _packedMiscInfo;
                }

                public unsafe partial class __
                {
                    [StructLayout(LayoutKind.Explicit, Size = 4)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal byte _stackAlignment;

                        [FieldOffset(1)]
                        internal byte _cdeclCallConv;

                        [FieldOffset(2)]
                        internal byte _stdCallConv;

                        [FieldOffset(3)]
                        internal byte _fastCallConv;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CodeInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CodeInfo>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeInfo(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeInfo __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeInfo(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private CodeInfo(global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CodeInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CodeInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public CodeInfo(global::GraphEngine.Jit.Native.Asmjit.CodeInfo other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public CodeInfo(uint archType, uint archMode, ulong baseAddress)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), archType, archMode, baseAddress);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CodeInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Init(global::GraphEngine.Jit.Native.Asmjit.CodeInfo other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Init((__Instance + __PointerAdjustment), __arg0);
            }

            public void Init(uint archType, uint archMode, ulong baseAddress)
            {
                __Internal.Init((__Instance + __PointerAdjustment), archType, archMode, baseAddress);
            }

            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Set a natural stack alignment that must be honored.</summary>
            public void SetStackAlignment(byte sa)
            {
                __Internal.SetStackAlignment((__Instance + __PointerAdjustment), sa);
            }

            public void ResetBaseAddress()
            {
                __Internal.ResetBaseAddress((__Instance + __PointerAdjustment));
            }

            public static bool operator ==(global::GraphEngine.Jit.Native.Asmjit.CodeInfo __op, global::GraphEngine.Jit.Native.Asmjit.CodeInfo other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return __opNull && otherNull;
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::GraphEngine.Jit.Native.Asmjit.CodeInfo;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::GraphEngine.Jit.Native.Asmjit.CodeInfo __op, global::GraphEngine.Jit.Native.Asmjit.CodeInfo other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return !(__opNull && otherNull);
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return __ret;
            }

            public uint CdeclCallConv
            {
                get
                {
                    var __ret = __Internal.GetCdeclCallConv((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetCdeclCallConv((__Instance + __PointerAdjustment), value);
                }
            }

            public uint StdCallConv
            {
                get
                {
                    var __ret = __Internal.GetStdCallConv((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetStdCallConv((__Instance + __PointerAdjustment), value);
                }
            }

            public uint FastCallConv
            {
                get
                {
                    var __ret = __Internal.GetFastCallConv((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetFastCallConv((__Instance + __PointerAdjustment), value);
                }
            }

            public ulong BaseAddress
            {
                get
                {
                    var __ret = __Internal.GetBaseAddress((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetBaseAddress((__Instance + __PointerAdjustment), value);
                }
            }

            public bool IsInitialized
            {
                get
                {
                    var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get architecture information, see</summary>
            public global::GraphEngine.Jit.Native.Asmjit.ArchInfo ArchInfo
            {
                get
                {
                    var __ret = __Internal.GetArchInfo((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.ArchInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ArchInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ArchInfo) global::GraphEngine.Jit.Native.Asmjit.ArchInfo.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get architecture type, see</summary>
            public uint ArchType
            {
                get
                {
                    var __ret = __Internal.GetArchType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get architecture sub-type, see</summary>
            public uint ArchSubType
            {
                get
                {
                    var __ret = __Internal.GetArchSubType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a size of a GP register of the architecture the code is using.</summary>
            public uint GpSize
            {
                get
                {
                    var __ret = __Internal.GetGpSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get number of GP registers available of the architecture the code is using.</summary>
            public uint GpCount
            {
                get
                {
                    var __ret = __Internal.GetGpCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a natural stack alignment that must be honored (or 0 if not known).</summary>
            public uint StackAlignment
            {
                get
                {
                    var __ret = __Internal.GetStackAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasBaseAddress
            {
                get
                {
                    var __ret = __Internal.HasBaseAddress((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Code or data buffer.</summary>
        public unsafe partial class CodeBuffer : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _data;

                [FieldOffset(8)]
                internal ulong _length;

                [FieldOffset(16)]
                internal ulong _capacity;

                [FieldOffset(24)]
                internal byte _isExternal;

                [FieldOffset(25)]
                internal byte _isFixedSize;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CodeBuffer@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasData@CodeBuffer@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasData(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getData@CodeBuffer@asmjit@@QEAAPEAEXZ")]
                internal static extern byte* GetData(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLength@CodeBuffer@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetLength(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCapacity@CodeBuffer@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetCapacity(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isExternal@CodeBuffer@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsExternal(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isFixedSize@CodeBuffer@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFixedSize(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CodeBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CodeBuffer>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeBuffer(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeBuffer __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeBuffer(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CodeBuffer(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CodeBuffer(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CodeBuffer()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public CodeBuffer(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CodeBuffer __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public bool HasData
            {
                get
                {
                    var __ret = __Internal.HasData((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public byte* Data
            {
                get
                {
                    var __ret = __Internal.GetData((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public ulong Length
            {
                get
                {
                    var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public ulong Capacity
            {
                get
                {
                    var __ret = __Internal.GetCapacity((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsExternal
            {
                get
                {
                    var __ret = __Internal.IsExternal((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsFixedSize
            {
                get
                {
                    var __ret = __Internal.IsFixedSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Section entry.</summary>
        public unsafe partial class SectionEntry : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 88)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint _id;

                [FieldOffset(4)]
                internal uint _flags;

                [FieldOffset(8)]
                internal uint _alignment;

                [FieldOffset(12)]
                internal uint _virtualSize;

                [FieldOffset(16)]
                internal global::GraphEngine.Jit.Native.Asmjit.SectionEntry._.__Internal _;

                [FieldOffset(56)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__Internal _buffer;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0SectionEntry@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_setDefaultName@SectionEntry@asmjit@@QEAAXDDDDDDDD@Z")]
                internal static extern void SetDefaultName(global::System.IntPtr instance, sbyte c0, sbyte c1, sbyte c2, sbyte c3, sbyte c4, sbyte c5, sbyte c6, sbyte c7);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasFlag@SectionEntry@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasFlag(global::System.IntPtr instance, uint flag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addFlags@SectionEntry@asmjit@@QEAAXI@Z")]
                internal static extern void AddFlags(global::System.IntPtr instance, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearFlags@SectionEntry@asmjit@@QEAAXI@Z")]
                internal static extern void ClearFlags(global::System.IntPtr instance, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setVirtualSize@SectionEntry@asmjit@@QEAAXI@Z")]
                internal static extern void SetVirtualSize(global::System.IntPtr instance, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAlignment@SectionEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setAlignment@SectionEntry@asmjit@@QEAAXI@Z")]
                internal static extern void SetAlignment(global::System.IntPtr instance, uint alignment);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getId@SectionEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getName@SectionEntry@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetName(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFlags@SectionEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetFlags(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPhysicalSize@SectionEntry@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetPhysicalSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVirtualSize@SectionEntry@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetVirtualSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBuffer@SectionEntry@asmjit@@QEAAAEAUCodeBuffer@2@XZ")]
                internal static extern global::System.IntPtr GetBuffer(global::System.IntPtr instance);
            }

            public enum Id : uint
            {
                /// <summary>Invalid section id.</summary>
                kInvalidId = 0xffffffff
            }

            /// <summary>Section flags.</summary>
            [Flags]
            public enum Flags : uint
            {
                /// <summary>Executable (.text sections).</summary>
                kFlagExec = 0x1,
                /// <summary>Read-only (.text and .data sections).</summary>
                kFlagConst = 0x2,
                /// <summary>Zero initialized by the loader (BSS).</summary>
                kFlagZero = 0x4,
                /// <summary>Info / comment flag.</summary>
                kFlagInfo = 0x8,
                /// <summary>Section created implicitly (can be deleted by the Runtime).</summary>
                kFlagImplicit = 0x80000000
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 36)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed sbyte _name[36];

                    [FieldOffset(0)]
                    internal fixed uint _nameAsU32[9];
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.SectionEntry> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.SectionEntry>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.SectionEntry __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.SectionEntry(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.SectionEntry __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.SectionEntry(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private SectionEntry(global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SectionEntry(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public SectionEntry()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public SectionEntry(global::GraphEngine.Jit.Native.Asmjit.SectionEntry _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.SectionEntry __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetDefaultName(sbyte c0, sbyte c1, sbyte c2, sbyte c3, sbyte c4, sbyte c5, sbyte c6, sbyte c7)
            {
                __Internal.SetDefaultName((__Instance + __PointerAdjustment), c0, c1, c2, c3, c4, c5, c6, c7);
            }

            public bool HasFlag(uint flag)
            {
                var __ret = __Internal.HasFlag((__Instance + __PointerAdjustment), flag);
                return __ret;
            }

            public void AddFlags(uint flags)
            {
                __Internal.AddFlags((__Instance + __PointerAdjustment), flags);
            }

            public void ClearFlags(uint flags)
            {
                __Internal.ClearFlags((__Instance + __PointerAdjustment), flags);
            }

            public void SetVirtualSize(uint size)
            {
                __Internal.SetVirtualSize((__Instance + __PointerAdjustment), size);
            }

            public uint Alignment
            {
                get
                {
                    var __ret = __Internal.GetAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetAlignment((__Instance + __PointerAdjustment), value);
                }
            }

            public uint id
            {
                get
                {
                    var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public string Name
            {
                get
                {
                    var __ret = __Internal.GetName((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            public uint flags
            {
                get
                {
                    var __ret = __Internal.GetFlags((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public ulong PhysicalSize
            {
                get
                {
                    var __ret = __Internal.GetPhysicalSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public ulong VirtualSize
            {
                get
                {
                    var __ret = __Internal.GetVirtualSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.CodeBuffer Buffer
            {
                get
                {
                    var __ret = __Internal.GetBuffer((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CodeBuffer __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeBuffer) global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeBuffer.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        /// <summary>Data structure used to link labels.</summary>
        public unsafe partial class LabelLink : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr prev;

                [FieldOffset(8)]
                internal uint sectionId;

                [FieldOffset(12)]
                internal uint relocId;

                [FieldOffset(16)]
                internal ulong offset;

                [FieldOffset(24)]
                internal long rel;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0LabelLink@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.LabelLink> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.LabelLink>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.LabelLink __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.LabelLink(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.LabelLink __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.LabelLink.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.LabelLink(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.LabelLink.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.LabelLink.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.LabelLink.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private LabelLink(global::GraphEngine.Jit.Native.Asmjit.LabelLink.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected LabelLink(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public LabelLink()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.LabelLink.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public LabelLink(global::GraphEngine.Jit.Native.Asmjit.LabelLink _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.LabelLink.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.LabelLink.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.LabelLink.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.LabelLink __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Label entry.</summary>
        /// <remarks>
        /// <para>Contains the following properties:</para>
        /// <para>* Label id - This is the only thing that is set to the `Label` operand.</para>
        /// <para>* Label name - Optional, used mostly to create executables and libraries.</para>
        /// <para>* Label type - Type of the label, default `Label::kTypeAnonymous`.</para>
        /// <para>* Label parent id - Derived from many assemblers that allow to define a</para>
        /// <para>local label that falls under a global label. This allows to define</para>
        /// <para>many labels of the same name that have different parent (global) label.</para>
        /// <para>* Offset - offset of the label bound by `Assembler`.</para>
        /// <para>* Links - single-linked list that contains locations of code that has</para>
        /// <para>to be patched when the label gets bound. Every use of unbound label</para>
        /// <para>adds one link to `_links` list.</para>
        /// <para>* HVal - Hash value of label's name and optionally parentId.</para>
        /// <para>* HashNext - Hash-table implementation detail.</para>
        /// </remarks>
        public unsafe partial class LabelEntry : global::GraphEngine.Jit.Native.Asmjit.ZoneHashNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _hashNext;

                [FieldOffset(8)]
                internal uint _hVal;

                [FieldOffset(12)]
                internal uint _customData;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _flags;

                [FieldOffset(18)]
                internal ushort _reserved16;

                [FieldOffset(20)]
                internal uint _parentId;

                [FieldOffset(24)]
                internal uint _sectionId;

                [FieldOffset(28)]
                internal uint _reserved32;

                [FieldOffset(32)]
                internal long _offset;

                [FieldOffset(40)]
                internal global::System.IntPtr _links;

                [FieldOffset(48)]
                internal global::GraphEngine.Jit.Native.Asmjit.SmallString.__Internalc__N_asmjit_S_SmallString__Vk16 _name;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0LabelEntry@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0LabelEntry@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_setId@LabelEntry@asmjit@@QEAAXI@Z")]
                internal static extern void SetId(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getId@LabelEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getType@LabelEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFlags@LabelEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetFlags(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasParent@LabelEntry@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasParent(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getParentId@LabelEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetParentId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSectionId@LabelEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetSectionId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasName@LabelEntry@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasName(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getName@LabelEntry@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetName(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getNameLength@LabelEntry@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetNameLength(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isBound@LabelEntry@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsBound(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOffset@LabelEntry@asmjit@@QEBA_JXZ")]
                internal static extern long GetOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getHVal@LabelEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetHVal(global::System.IntPtr instance);
            }

            [Flags]
            public enum KNameBytes
            {
                kNameBytes = 16
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.LabelEntry __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.LabelEntry(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.LabelEntry __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.LabelEntry(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private LabelEntry(global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected LabelEntry(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public LabelEntry()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public LabelEntry(global::GraphEngine.Jit.Native.Asmjit.LabelEntry _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__Internal*) _0.__Instance);
            }

            /// <summary>Set label id (internal, used only by</summary>
            public void SetId(uint id)
            {
                __Internal.SetId((__Instance + __PointerAdjustment), id);
            }

            /// <summary>Get label id.</summary>
            public uint Id
            {
                get
                {
                    var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get label type, see</summary>
            public uint Type
            {
                get
                {
                    var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get label flags, returns 0 at the moment.</summary>
            public uint Flags
            {
                get
                {
                    var __ret = __Internal.GetFlags((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasParent
            {
                get
                {
                    var __ret = __Internal.HasParent((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get label's parent id.</summary>
            public uint ParentId
            {
                get
                {
                    var __ret = __Internal.GetParentId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get label's section id where it's bound to (or `SectionEntry::kInvalidId` if it's not bound yet).</summary>
            public uint SectionId
            {
                get
                {
                    var __ret = __Internal.GetSectionId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the label has name.</summary>
            public bool HasName
            {
                get
                {
                    var __ret = __Internal.HasName((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the label's name.</summary>
            /// <remarks>
            /// <para>NOTE: Local labels will return their local name without their parent</para>
            /// <para>part, for example &quot;.L1&quot;.</para>
            /// </remarks>
            public string Name
            {
                get
                {
                    var __ret = __Internal.GetName((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            /// <summary>Get length of label's name.</summary>
            /// <remarks>
            /// <para>NOTE: Label name is always null terminated, so you can use `strlen()` to</para>
            /// <para>get it, however, it's also cached in `LabelEntry`, so if you want to know</para>
            /// <para>the length the easiest way is to use `LabelEntry::getNameLength()`.</para>
            /// </remarks>
            public ulong NameLength
            {
                get
                {
                    var __ret = __Internal.GetNameLength((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the label is bound.</summary>
            public bool IsBound
            {
                get
                {
                    var __ret = __Internal.IsBound((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the label offset (only useful if the label is bound).</summary>
            public long Offset
            {
                get
                {
                    var __ret = __Internal.GetOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the hash-value of label's name and its parent label (if any).</summary>
            /// <remarks>
            /// <para>Label hash is calculated as `HASH(Name) ^ ParentId`. The hash function</para>
            /// <para>is implemented in `Utils::hashString()` and `Utils::hashRound()`.</para>
            /// </remarks>
            public uint HVal
            {
                get
                {
                    var __ret = __Internal.GetHVal((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Relocation entry.</summary>
        public unsafe partial class RelocEntry : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint _id;

                [FieldOffset(4)]
                internal byte _type;

                [FieldOffset(5)]
                internal byte _size;

                [FieldOffset(6)]
                internal fixed byte _reserved[2];

                [FieldOffset(8)]
                internal uint _sourceSectionId;

                [FieldOffset(12)]
                internal uint _targetSectionId;

                [FieldOffset(16)]
                internal ulong _sourceOffset;

                [FieldOffset(24)]
                internal ulong _data;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0RelocEntry@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getId@RelocEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getType@RelocEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSize@RelocEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSourceSectionId@RelocEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetSourceSectionId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getTargetSectionId@RelocEntry@asmjit@@QEBAIXZ")]
                internal static extern uint GetTargetSectionId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSourceOffset@RelocEntry@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetSourceOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getData@RelocEntry@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetData(global::System.IntPtr instance);
            }

            public enum Id : uint
            {
                /// <summary>Invalid relocation id.</summary>
                kInvalidId = 0xffffffff
            }

            /// <summary>Relocation type.</summary>
            public enum Type : uint
            {
                /// <summary>Deleted entry (no relocation).</summary>
                kTypeNone = 0,
                /// <summary>Relocate absolute to absolute.</summary>
                kTypeAbsToAbs = 1,
                /// <summary>Relocate relative to absolute.</summary>
                kTypeRelToAbs = 2,
                /// <summary>Relocate absolute to relative.</summary>
                kTypeAbsToRel = 3,
                /// <summary>Relocate absolute to relative or use trampoline.</summary>
                kTypeTrampoline = 4
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RelocEntry> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RelocEntry>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.RelocEntry __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RelocEntry(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.RelocEntry __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RelocEntry(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private RelocEntry(global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RelocEntry(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public RelocEntry()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public RelocEntry(global::GraphEngine.Jit.Native.Asmjit.RelocEntry _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.RelocEntry __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint id
            {
                get
                {
                    var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint type
            {
                get
                {
                    var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint Size
            {
                get
                {
                    var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint SourceSectionId
            {
                get
                {
                    var __ret = __Internal.GetSourceSectionId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint TargetSectionId
            {
                get
                {
                    var __ret = __Internal.GetTargetSectionId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public ulong SourceOffset
            {
                get
                {
                    var __ret = __Internal.GetSourceOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public ulong Data
            {
                get
                {
                    var __ret = __Internal.GetData((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Contains basic information about the target architecture plus its settings,</para>
        /// <para>and holds code&amp;data (including sections, labels, and relocation information).</para>
        /// <para>CodeHolder can store both binary and intermediate representation of assembly,</para>
        /// <para>which can be generated by</para>
        /// </summary>
        /// <remarks>
        /// <para>NOTE: CodeHolder has ability to attach an</para>
        /// <para>error handler is not triggered by CodeHolder itself, it's only used by the</para>
        /// <para>attached code generators.</para>
        /// </remarks>
        public unsafe partial class CodeHolder : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 336)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(16)]
                internal uint _globalHints;

                [FieldOffset(20)]
                internal uint _globalOptions;

                [FieldOffset(24)]
                internal global::System.IntPtr _emitters;

                [FieldOffset(32)]
                internal global::System.IntPtr _cgAsm;

                [FieldOffset(40)]
                internal global::System.IntPtr _logger;

                [FieldOffset(48)]
                internal global::System.IntPtr _errorHandler;

                [FieldOffset(56)]
                internal uint _unresolvedLabelsCount;

                [FieldOffset(60)]
                internal uint _trampolinesSize;

                [FieldOffset(64)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _baseZone;

                [FieldOffset(96)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _dataZone;

                [FieldOffset(128)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal _baseHeap;

                [FieldOffset(224)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _sections;

                [FieldOffset(248)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _labels;

                [FieldOffset(272)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _relocations;

                [FieldOffset(296)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneHash.__Internal _namedLabels;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CodeHolder@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CodeHolder@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?init@CodeHolder@asmjit@@QEAAIAEBVCodeInfo@2@@Z")]
                internal static extern uint Init(global::System.IntPtr instance, global::System.IntPtr info);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@CodeHolder@asmjit@@QEAAX_N@Z")]
                internal static extern void Reset(global::System.IntPtr instance, bool releaseMemory);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?attach@CodeHolder@asmjit@@QEAAIPEAVCodeEmitter@2@@Z")]
                internal static extern uint Attach(global::System.IntPtr instance, global::System.IntPtr emitter);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?detach@CodeHolder@asmjit@@QEAAIPEAVCodeEmitter@2@@Z")]
                internal static extern uint Detach(global::System.IntPtr instance, global::System.IntPtr emitter);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?sync@CodeHolder@asmjit@@QEAAXXZ")]
                internal static extern void Sync(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetLogger@CodeHolder@asmjit@@QEAAXXZ")]
                internal static extern void ResetLogger(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setErrorHandler@CodeHolder@asmjit@@QEAAIPEAVErrorHandler@2@@Z")]
                internal static extern uint SetErrorHandler(global::System.IntPtr instance, global::System.IntPtr handler);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetErrorHandler@CodeHolder@asmjit@@QEAAXXZ")]
                internal static extern void ResetErrorHandler(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSectionEntry@CodeHolder@asmjit@@QEBAPEAVSectionEntry@2@_K@Z")]
                internal static extern global::System.IntPtr GetSectionEntry(global::System.IntPtr instance, ulong index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?growBuffer@CodeHolder@asmjit@@QEAAIPEAUCodeBuffer@2@_K@Z")]
                internal static extern uint GrowBuffer(global::System.IntPtr instance, global::System.IntPtr cb, ulong n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reserveBuffer@CodeHolder@asmjit@@QEAAIPEAUCodeBuffer@2@_K@Z")]
                internal static extern uint ReserveBuffer(global::System.IntPtr instance, global::System.IntPtr cb, ulong n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newLabelId@CodeHolder@asmjit@@QEAAIAEAI@Z")]
                internal static extern uint NewLabelId(global::System.IntPtr instance, uint* idOut);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newNamedLabelId@CodeHolder@asmjit@@QEAAIAEAIPEBD_KII@Z")]
                internal static extern uint NewNamedLabelId(global::System.IntPtr instance, uint* idOut, [MarshalAs(UnmanagedType.LPStr)] string name, ulong nameLength, uint type, uint parentId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLabelIdByName@CodeHolder@asmjit@@QEAAIPEBD_KI@Z")]
                internal static extern uint GetLabelIdByName(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name, ulong nameLength, uint parentId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newLabelLink@CodeHolder@asmjit@@QEAAPEAULabelLink@2@PEAVLabelEntry@2@I_K_J@Z")]
                internal static extern global::System.IntPtr NewLabelLink(global::System.IntPtr instance, global::System.IntPtr le, uint sectionId, ulong offset, long rel);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isLabelValid@CodeHolder@asmjit@@QEBA_NAEBVLabel@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLabelValid(global::System.IntPtr instance, global::System.IntPtr label);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isLabelValid@CodeHolder@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLabelValid(global::System.IntPtr instance, uint labelId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isLabelBound@CodeHolder@asmjit@@QEBA_NAEBVLabel@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLabelBound(global::System.IntPtr instance, global::System.IntPtr label);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isLabelBound@CodeHolder@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLabelBound(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLabelOffset@CodeHolder@asmjit@@QEBA_JAEBVLabel@2@@Z")]
                internal static extern long GetLabelOffset(global::System.IntPtr instance, global::System.IntPtr label);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLabelOffset@CodeHolder@asmjit@@QEBA_JI@Z")]
                internal static extern long GetLabelOffset(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLabelEntry@CodeHolder@asmjit@@QEBAPEAVLabelEntry@2@AEBVLabel@2@@Z")]
                internal static extern global::System.IntPtr GetLabelEntry(global::System.IntPtr instance, global::System.IntPtr label);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLabelEntry@CodeHolder@asmjit@@QEBAPEAVLabelEntry@2@I@Z")]
                internal static extern global::System.IntPtr GetLabelEntry(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newRelocEntry@CodeHolder@asmjit@@QEAAIPEAPEAURelocEntry@2@II@Z")]
                internal static extern uint NewRelocEntry(global::System.IntPtr instance, global::System.IntPtr dst, uint type, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRelocEntry@CodeHolder@asmjit@@QEBAPEAURelocEntry@2@I@Z")]
                internal static extern global::System.IntPtr GetRelocEntry(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?relocate@CodeHolder@asmjit@@QEBA_KPEAX_K@Z")]
                internal static extern ulong Relocate(global::System.IntPtr instance, global::System.IntPtr dst, ulong baseAddress);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLogger@CodeHolder@asmjit@@QEBAPEAVLogger@2@XZ")]
                internal static extern global::System.IntPtr GetLogger(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setLogger@CodeHolder@asmjit@@QEAAXPEAVLogger@2@@Z")]
                internal static extern void SetLogger(global::System.IntPtr instance, global::System.IntPtr logger);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInitialized@CodeHolder@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInitialized(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCodeInfo@CodeHolder@asmjit@@QEBAAEBVCodeInfo@2@XZ")]
                internal static extern global::System.IntPtr GetCodeInfo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchInfo@CodeHolder@asmjit@@QEBAAEBVArchInfo@2@XZ")]
                internal static extern global::System.IntPtr GetArchInfo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchType@CodeHolder@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchSubType@CodeHolder@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchSubType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasBaseAddress@CodeHolder@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasBaseAddress(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBaseAddress@CodeHolder@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetBaseAddress(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGlobalHints@CodeHolder@asmjit@@QEBAIXZ")]
                internal static extern uint GetGlobalHints(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGlobalOptions@CodeHolder@asmjit@@QEBAIXZ")]
                internal static extern uint GetGlobalOptions(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCodeSize@CodeHolder@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetCodeSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getTrampolinesSize@CodeHolder@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetTrampolinesSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasLogger@CodeHolder@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasLogger(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasErrorHandler@CodeHolder@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasErrorHandler(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getErrorHandler@CodeHolder@asmjit@@QEBAPEAVErrorHandler@2@XZ")]
                internal static extern global::System.IntPtr GetErrorHandler(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLabelsCount@CodeHolder@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetLabelsCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUnresolvedLabelsCount@CodeHolder@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetUnresolvedLabelsCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasRelocations@CodeHolder@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasRelocations(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CodeHolder> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CodeHolder>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeHolder __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeHolder(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeHolder __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeHolder(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CodeHolder(global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CodeHolder(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create an uninitialized CodeHolder (you must init() it before it can be used).</summary>
            public CodeHolder()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Initialize to CodeHolder to hold code described by `codeInfo`.</summary>
            public uint Init(global::GraphEngine.Jit.Native.Asmjit.CodeInfo info)
            {
                if (ReferenceEquals(info, null))
                    throw new global::System.ArgumentNullException("info", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = info.__Instance;
                var __ret = __Internal.Init((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Detach all code-generators attached and reset the</summary>
            public void Reset(bool releaseMemory)
            {
                __Internal.Reset((__Instance + __PointerAdjustment), releaseMemory);
            }

            /// <summary>Attach a</summary>
            public uint Attach(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter emitter)
            {
                var __arg0 = ReferenceEquals(emitter, null) ? global::System.IntPtr.Zero : emitter.__Instance;
                var __ret = __Internal.Attach((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Detach a</summary>
            public uint Detach(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter emitter)
            {
                var __arg0 = ReferenceEquals(emitter, null) ? global::System.IntPtr.Zero : emitter.__Instance;
                var __ret = __Internal.Detach((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Synchronize all states of all `CodeEmitter`s associated with the CodeHolder.</para>
            /// <para>This is required as some code generators don't sync every time they do</para>
            /// <para>something - for example</para>
            /// </summary>
            /// <remarks>
            /// <para>reallocate the</para>
            /// <para>or directive.</para>
            /// </remarks>
            public void Sync()
            {
                __Internal.Sync((__Instance + __PointerAdjustment));
            }

            /// <summary>Reset the logger (does nothing if not attached).</summary>
            public void ResetLogger()
            {
                __Internal.ResetLogger((__Instance + __PointerAdjustment));
            }

            /// <summary>Set the error handler, will affect all attached `CodeEmitter`s.</summary>
            public uint SetErrorHandler(global::GraphEngine.Jit.Native.Asmjit.ErrorHandler handler)
            {
                var __arg0 = ReferenceEquals(handler, null) ? global::System.IntPtr.Zero : handler.__Instance;
                var __ret = __Internal.SetErrorHandler((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Reset the error handler (does nothing if not attached).</summary>
            public void ResetErrorHandler()
            {
                __Internal.ResetErrorHandler((__Instance + __PointerAdjustment));
            }

            /// <summary>Get a section entry of the given index.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.SectionEntry GetSectionEntry(ulong index)
            {
                var __ret = __Internal.GetSectionEntry((__Instance + __PointerAdjustment), index);
                global::GraphEngine.Jit.Native.Asmjit.SectionEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.SectionEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.SectionEntry) global::GraphEngine.Jit.Native.Asmjit.SectionEntry.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.SectionEntry.__CreateInstance(__ret);
                return __result0;
            }

            public uint GrowBuffer(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer cb, ulong n)
            {
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                var __ret = __Internal.GrowBuffer((__Instance + __PointerAdjustment), __arg0, n);
                return __ret;
            }

            public uint ReserveBuffer(global::GraphEngine.Jit.Native.Asmjit.CodeBuffer cb, ulong n)
            {
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                var __ret = __Internal.ReserveBuffer((__Instance + __PointerAdjustment), __arg0, n);
                return __ret;
            }

            /// <summary>Create a new anonymous label and return its id in `idOut`.</summary>
            /// <remarks>Returns `Error`, does not report error to</remarks>
            public uint NewLabelId(ref uint idOut)
            {
                fixed (uint* __refParamPtr0 = &idOut)
                {
                    var __arg0 = __refParamPtr0;
                    var __ret = __Internal.NewLabelId((__Instance + __PointerAdjustment), __arg0);
                    return __ret;
                }
            }

            /// <summary>Create a new named label label-type `type`.</summary>
            /// <remarks>Returns `Error`, does not report error to</remarks>
            public uint NewNamedLabelId(ref uint idOut, string name, ulong nameLength, uint type, uint parentId)
            {
                fixed (uint* __refParamPtr0 = &idOut)
                {
                    var __arg0 = __refParamPtr0;
                    var __ret = __Internal.NewNamedLabelId((__Instance + __PointerAdjustment), __arg0, name, nameLength, type, parentId);
                    return __ret;
                }
            }

            /// <summary>Get a label id by name.</summary>
            public uint GetLabelIdByName(string name, ulong nameLength, uint parentId)
            {
                var __ret = __Internal.GetLabelIdByName((__Instance + __PointerAdjustment), name, nameLength, parentId);
                return __ret;
            }

            /// <summary>Create a new label-link used to store information about yet unbound labels.</summary>
            /// <remarks>Returns `null` if the allocation failed.</remarks>
            public global::GraphEngine.Jit.Native.Asmjit.LabelLink NewLabelLink(global::GraphEngine.Jit.Native.Asmjit.LabelEntry le, uint sectionId, ulong offset, long rel)
            {
                var __arg0 = ReferenceEquals(le, null) ? global::System.IntPtr.Zero : le.__Instance;
                var __ret = __Internal.NewLabelLink((__Instance + __PointerAdjustment), __arg0, sectionId, offset, rel);
                global::GraphEngine.Jit.Native.Asmjit.LabelLink __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.LabelLink.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.LabelLink) global::GraphEngine.Jit.Native.Asmjit.LabelLink.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.LabelLink.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Get if the `label` is valid (i.e. created by `newLabelId()`).</summary>
            public bool IsLabelValid(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = __Internal.IsLabelValid((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Get if the label having `id` is valid (i.e. created by `newLabelId()`).</summary>
            public bool IsLabelValid(uint labelId)
            {
                var __ret = __Internal.IsLabelValid((__Instance + __PointerAdjustment), labelId);
                return __ret;
            }

            /// <summary>Get if the `label` is already bound.</summary>
            /// <remarks>Returns `false` if the `label` is not valid.</remarks>
            public bool IsLabelBound(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = __Internal.IsLabelBound((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }


            public bool IsLabelBound(uint id)
            {
                var __ret = __Internal.IsLabelBound((__Instance + __PointerAdjustment), id);
                return __ret;
            }

            /// <summary>Get a `label` offset or -1 if the label is not yet bound.</summary>
            public long GetLabelOffset(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = __Internal.GetLabelOffset((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }


            public long GetLabelOffset(uint id)
            {
                var __ret = __Internal.GetLabelOffset((__Instance + __PointerAdjustment), id);
                return __ret;
            }

            /// <summary>Get information about the given `label`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.LabelEntry GetLabelEntry(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = __Internal.GetLabelEntry((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.LabelEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.LabelEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.LabelEntry) global::GraphEngine.Jit.Native.Asmjit.LabelEntry.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Get information about a label having the given `id`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.LabelEntry GetLabelEntry(uint id)
            {
                var __ret = __Internal.GetLabelEntry((__Instance + __PointerAdjustment), id);
                global::GraphEngine.Jit.Native.Asmjit.LabelEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.LabelEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.LabelEntry) global::GraphEngine.Jit.Native.Asmjit.LabelEntry.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.LabelEntry.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Create a new relocation entry of type `type` and size `size`.</summary>
            /// <remarks>Additional fields can be set after the relocation entry was created.</remarks>
            public uint NewRelocEntry(global::GraphEngine.Jit.Native.Asmjit.RelocEntry dst, uint type, uint size)
            {
                var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
                var __ret = __Internal.NewRelocEntry((__Instance + __PointerAdjustment), __arg0, type, size);
                return __ret;
            }

            public global::GraphEngine.Jit.Native.Asmjit.RelocEntry GetRelocEntry(uint id)
            {
                var __ret = __Internal.GetRelocEntry((__Instance + __PointerAdjustment), id);
                global::GraphEngine.Jit.Native.Asmjit.RelocEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.RelocEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.RelocEntry) global::GraphEngine.Jit.Native.Asmjit.RelocEntry.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.RelocEntry.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Relocate the code to `baseAddress` and copy it to `dst`.</summary>
            /// <param name="dst">
            /// <para>Contains the location where the relocated code should be</para>
            /// <para>copied. The pointer can be address returned by virtual memory allocator</para>
            /// <para>or any other address that has sufficient space.</para>
            /// </param>
            /// <param name="baseAddress">
            /// <para>Base address used for relocation. `JitRuntime` always</para>
            /// <para>sets the `baseAddress` to be the same as `dst`.</para>
            /// </param>
            /// <returns>
            /// <para>The number bytes actually used. If the code emitter reserved</para>
            /// <para>space for possible trampolines, but didn't use it, the number of bytes</para>
            /// <para>used can actually be less than the expected worst case. Virtual memory</para>
            /// <para>allocator can shrink the memory it allocated initially.</para>
            /// <para>A given buffer will be overwritten, to get the number of bytes required,</para>
            /// <para>use `getCodeSize()`.</para>
            /// </returns>
            public ulong Relocate(global::System.IntPtr dst, ulong baseAddress)
            {
                var __ret = __Internal.Relocate((__Instance + __PointerAdjustment), dst, baseAddress);
                return __ret;
            }

            /// <summary>Get the attached logger.</summary>
            /// <remarks>Attach a `logger` to CodeHolder and propagate it to all attached `CodeEmitter`s.</remarks>
            public global::GraphEngine.Jit.Native.Asmjit.Logger Logger
            {
                get
                {
                    var __ret = __Internal.GetLogger((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.Logger __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.Logger.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.Logger) global::GraphEngine.Jit.Native.Asmjit.Logger.NativeToManagedMap[__ret];
                    else global::GraphEngine.Jit.Native.Asmjit.Logger.NativeToManagedMap[__ret] = __result0 = (global::GraphEngine.Jit.Native.Asmjit.Logger) global::GraphEngine.Jit.Native.Asmjit.Logger.__CreateInstance(__ret);
                    return __result0;
                }

                set
                {
                    var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    __Internal.SetLogger((__Instance + __PointerAdjustment), __arg0);
                }
            }

            public bool IsInitialized
            {
                get
                {
                    var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get code/target information, see</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CodeInfo CodeInfo
            {
                get
                {
                    var __ret = __Internal.GetCodeInfo((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CodeInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CodeInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeInfo) global::GraphEngine.Jit.Native.Asmjit.CodeInfo.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get architecture information, see</summary>
            public global::GraphEngine.Jit.Native.Asmjit.ArchInfo ArchInfo
            {
                get
                {
                    var __ret = __Internal.GetArchInfo((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.ArchInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ArchInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ArchInfo) global::GraphEngine.Jit.Native.Asmjit.ArchInfo.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get the target's architecture type.</summary>
            public uint ArchType
            {
                get
                {
                    var __ret = __Internal.GetArchType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the target's architecture sub-type.</summary>
            public uint ArchSubType
            {
                get
                {
                    var __ret = __Internal.GetArchSubType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if a static base-address is set.</summary>
            public bool HasBaseAddress
            {
                get
                {
                    var __ret = __Internal.HasBaseAddress((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a static base-address (uint64_t).</summary>
            public ulong BaseAddress
            {
                get
                {
                    var __ret = __Internal.GetBaseAddress((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get global hints, internally propagated to all `CodeEmitter`s attached.</summary>
            public uint GlobalHints
            {
                get
                {
                    var __ret = __Internal.GetGlobalHints((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get global options, internally propagated to all `CodeEmitter`s attached.</summary>
            public uint GlobalOptions
            {
                get
                {
                    var __ret = __Internal.GetGlobalOptions((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the size code&amp;data of all sections.</summary>
            public ulong CodeSize
            {
                get
                {
                    var __ret = __Internal.GetCodeSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get size of all possible trampolines.</summary>
            /// <remarks>
            /// <para>Trampolines are needed to successfully generate relative jumps to absolute</para>
            /// <para>addresses. This value is only non-zero if jmp of call instructions were</para>
            /// <para>used with immediate operand (this means jumping or calling an absolute</para>
            /// <para>address directly).</para>
            /// </remarks>
            public ulong TrampolinesSize
            {
                get
                {
                    var __ret = __Internal.GetTrampolinesSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if a logger attached.</summary>
            public bool HasLogger
            {
                get
                {
                    var __ret = __Internal.HasLogger((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if error-handler is attached.</summary>
            public bool HasErrorHandler
            {
                get
                {
                    var __ret = __Internal.HasErrorHandler((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the error-handler.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.ErrorHandler ErrorHandler
            {
                get
                {
                    var __ret = __Internal.GetErrorHandler((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.ErrorHandler __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ErrorHandler) global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.NativeToManagedMap[__ret];
                    else global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.NativeToManagedMap[__ret] = __result0 = (global::GraphEngine.Jit.Native.Asmjit.ErrorHandler) global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get number of labels created.</summary>
            public ulong LabelsCount
            {
                get
                {
                    var __ret = __Internal.GetLabelsCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get number of label references, which are unresolved at the moment.</summary>
            public ulong UnresolvedLabelsCount
            {
                get
                {
                    var __ret = __Internal.GetUnresolvedLabelsCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the code contains relocations.</summary>
            public bool HasRelocations
            {
                get
                {
                    var __ret = __Internal.HasRelocations((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        public unsafe partial class ErrorHandlerInternal : global::GraphEngine.Jit.Native.Asmjit.ErrorHandler, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal ErrorHandlerInternal(global::GraphEngine.Jit.Native.Asmjit.ErrorHandler.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal ErrorHandlerInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Error handler (abstract).</summary>
            /// <remarks>
            /// <para>Error handler is called after an error happened and before it's propagated</para>
            /// <para>to the caller. There are multiple ways how the error handler can be used:</para>
            /// <para>1. Returning `true` or `false` from `handleError()`. If `true` is returned</para>
            /// <para>it means that the error was reported and AsmJit can continue execution.</para>
            /// <para>The reported error still be propagated to the caller, but won't put the</para>
            /// <para>CodeEmitter into an error state (it won't set last-error). However,</para>
            /// <para>returning `false` means that the error cannot be handled - in such case</para>
            /// <para>it stores the error, which can be then retrieved by using `getLastError()`.</para>
            /// <para>Returning `false` is the default behavior when no error handler is present.</para>
            /// <para>To put the assembler into a non-error state again a `resetLastError()` must</para>
            /// <para>be called.</para>
            /// <para>2. Throwing an exception. AsmJit doesn't use exceptions and is completely</para>
            /// <para>exception-safe, but you can throw exception from your error handler if</para>
            /// <para>this way is the preferred way of handling errors in your project. Throwing</para>
            /// <para>an exception acts virtually as returning `true` as AsmJit won't be able</para>
            /// <para>to store the error because the exception changes execution path.</para>
            /// <para>3. Using plain old C's `setjmp()` and `longjmp()`. Asmjit always puts</para>
            /// <para>`CodeEmitter` to a consistent state before calling the `handleError()`</para>
            /// <para>so `longjmp()` can be used without any issues to cancel the code</para>
            /// <para>generation if an error occurred. There is no difference between</para>
            /// <para>exceptions and longjmp() from AsmJit's perspective.</para>
            /// </remarks>
            public override bool HandleError(uint err, string message, global::GraphEngine.Jit.Native.Asmjit.CodeEmitter origin)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___HandleErrorDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_bool_IntPtr_uint_string_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_bool_IntPtr_uint_string_IntPtr));
                var __arg2 = ReferenceEquals(origin, null) ? global::System.IntPtr.Zero : origin.__Instance;
                var __ret = ___HandleErrorDelegate((__Instance + __PointerAdjustment), err, message, __arg2);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>\{</summary>
        public unsafe abstract partial class CodeEmitter : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 120)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_CodeEmitter;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(24)]
                internal global::System.IntPtr _code;

                [FieldOffset(32)]
                internal global::System.IntPtr _nextEmitter;

                [FieldOffset(40)]
                internal byte _type;

                [FieldOffset(41)]
                internal byte _destroyed;

                [FieldOffset(42)]
                internal byte _finalized;

                [FieldOffset(43)]
                internal byte _reserved;

                [FieldOffset(44)]
                internal uint _lastError;

                [FieldOffset(48)]
                internal uint _privateData;

                [FieldOffset(52)]
                internal uint _globalHints;

                [FieldOffset(56)]
                internal uint _globalOptions;

                [FieldOffset(60)]
                internal uint _options;

                [FieldOffset(64)]
                internal global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal _extraReg;

                [FieldOffset(72)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(80)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal _none;

                [FieldOffset(96)]
                internal global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal _nativeGpReg;

                [FieldOffset(112)]
                internal global::System.IntPtr _nativeGpArray;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CodeEmitter@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CodeEmitter@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CodeEmitter@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLabelByName@CodeEmitter@asmjit@@QEAA?AVLabel@2@PEBD_KI@Z")]
                internal static extern void GetLabelByName(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string name, ulong nameLength, uint parentId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setLastError@CodeEmitter@asmjit@@QEAAIIPEBD@Z")]
                internal static extern uint SetLastError(global::System.IntPtr instance, uint error, [MarshalAs(UnmanagedType.LPStr)] string message);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetLastError@CodeEmitter@asmjit@@QEAAIXZ")]
                internal static extern uint ResetLastError(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addOptions@CodeEmitter@asmjit@@QEAAXI@Z")]
                internal static extern void AddOptions(global::System.IntPtr instance, uint options);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetOptions@CodeEmitter@asmjit@@QEAAXXZ")]
                internal static extern void ResetOptions(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setExtraReg@CodeEmitter@asmjit@@QEAAXAEBVReg@2@@Z")]
                internal static extern void SetExtraReg(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetExtraReg@CodeEmitter@asmjit@@QEAAXXZ")]
                internal static extern void ResetExtraReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetInlineComment@CodeEmitter@asmjit@@QEAAXXZ")]
                internal static extern void ResetInlineComment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isLabelValid@CodeEmitter@asmjit@@QEBA_NAEBVLabel@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLabelValid(global::System.IntPtr instance, global::System.IntPtr label);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isLabelValid@CodeEmitter@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLabelValid(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?commentf@CodeEmitter@asmjit@@QEAAIPEBDZZ")]
                internal static extern uint Commentf(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string fmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAII@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@00@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@000@Z")]
                internal static extern uint emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0000@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@00000@Z")]
                internal static extern uint emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, global::System.IntPtr o5);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIH@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, int o0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@H@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, int o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0H@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, int o2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@00H@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, int o3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@000H@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, int o4);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0000H@Z")]
                internal static extern uint Emit(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, int o5);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAII_J@Z")]
                internal static extern uint Emit_1(global::System.IntPtr instance, uint instId, long o0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@_J@Z")]
                internal static extern uint Emit_1(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, long o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0_J@Z")]
                internal static extern uint Emit_1(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, long o2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@00_J@Z")]
                internal static extern uint Emit_1(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, long o3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@000_J@Z")]
                internal static extern uint Emit_1(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, long o4);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0000_J@Z")]
                internal static extern uint Emit_1(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, long o5);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIII@Z")]
                internal static extern uint Emit_2(global::System.IntPtr instance, uint instId, uint o0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@I@Z")]
                internal static extern uint Emit_2(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, uint o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0I@Z")]
                internal static extern uint Emit_2(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, uint o2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@00I@Z")]
                internal static extern uint Emit_2(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, uint o3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@000I@Z")]
                internal static extern uint Emit_2(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, uint o4);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0000I@Z")]
                internal static extern uint Emit_2(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, uint o5);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAII_K@Z")]
                internal static extern uint Emit_3(global::System.IntPtr instance, uint instId, ulong o0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@_K@Z")]
                internal static extern uint Emit_3(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, ulong o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0_K@Z")]
                internal static extern uint Emit_3(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, ulong o2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@00_K@Z")]
                internal static extern uint Emit_3(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, ulong o3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@000_K@Z")]
                internal static extern uint Emit_3(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, ulong o4);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emit@CodeEmitter@asmjit@@QEAAIIAEBUOperand_@2@0000_K@Z")]
                internal static extern uint Emit_3(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, ulong o5);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?emitOpArray@CodeEmitter@asmjit@@QEAAIIPEBUOperand_@2@_K@Z")]
                internal static extern uint emitOpArray(global::System.IntPtr instance, uint instId, global::System.IntPtr opArray, ulong opCount);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOptions@CodeEmitter@asmjit@@QEBAIXZ")]
                internal static extern uint GetOptions(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setOptions@CodeEmitter@asmjit@@QEAAXI@Z")]
                internal static extern void SetOptions(global::System.IntPtr instance, uint options);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getExtraReg@CodeEmitter@asmjit@@QEBAAEBURegOnly@2@XZ")]
                internal static extern global::System.IntPtr GetExtraReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setExtraReg@CodeEmitter@asmjit@@QEAAXAEBURegOnly@2@@Z")]
                internal static extern void SetExtraReg_1(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInlineComment@CodeEmitter@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetInlineComment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setInlineComment@CodeEmitter@asmjit@@QEAAXPEBD@Z")]
                internal static extern void SetInlineComment(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInitialized@CodeEmitter@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInitialized(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCodeInfo@CodeEmitter@asmjit@@QEBAAEBVCodeInfo@2@XZ")]
                internal static extern global::System.IntPtr GetCodeInfo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCode@CodeEmitter@asmjit@@QEBAPEAVCodeHolder@2@XZ")]
                internal static extern global::System.IntPtr GetCode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchInfo@CodeEmitter@asmjit@@QEBAAEBVArchInfo@2@XZ")]
                internal static extern global::System.IntPtr GetArchInfo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?is32Bit@CodeEmitter@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Is32Bit(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?is64Bit@CodeEmitter@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Is64Bit(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchType@CodeEmitter@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchSubType@CodeEmitter@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchSubType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGpSize@CodeEmitter@asmjit@@QEBAIXZ")]
                internal static extern uint GetGpSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGpCount@CodeEmitter@asmjit@@QEBAIXZ")]
                internal static extern uint GetGpCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getType@CodeEmitter@asmjit@@QEBAIXZ")]
                internal static extern uint GetType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isAssembler@CodeEmitter@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAssembler(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isCodeBuilder@CodeEmitter@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsCodeBuilder(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isCodeCompiler@CodeEmitter@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsCodeCompiler(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGlobalHints@CodeEmitter@asmjit@@QEBAIXZ")]
                internal static extern uint GetGlobalHints(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGlobalOptions@CodeEmitter@asmjit@@QEBAIXZ")]
                internal static extern uint GetGlobalOptions(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInErrorState@CodeEmitter@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInErrorState(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLastError@CodeEmitter@asmjit@@QEBAIXZ")]
                internal static extern uint GetLastError(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasExtraReg@CodeEmitter@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasExtraReg(global::System.IntPtr instance);
            }

            /// <summary>CodeEmitter type.</summary>
            public enum Type : uint
            {
                kTypeNone = 0,
                kTypeAssembler = 1,
                kTypeBuilder = 2,
                kTypeCompiler = 3,
                kTypeCount = 4
            }

            /// <summary>CodeEmitter hints - global settings that affect machine-code generation.</summary>
            public enum Hints : uint
            {
                /// <summary>Emit optimized code-alignment sequences.</summary>
                /// <remarks>
                /// <para>Default `true`.</para>
                /// <para>X86/X64 Specific</para>
                /// <para>----------------</para>
                /// <para>Default align sequence used by X86/X64 architecture is one-byte (0x90)</para>
                /// <para>opcode that is often shown by disassemblers as nop. However there are</para>
                /// <para>more optimized align sequences for 2-11 bytes that may execute faster.</para>
                /// <para>If this feature is enabled AsmJit will generate specialized sequences</para>
                /// <para>for alignment between 2 to 11 bytes.</para>
                /// </remarks>
                kHintOptimizedAlign = 0x1,
                /// <summary>Emit jump-prediction hints.</summary>
                /// <remarks>
                /// <para>Default `false`.</para>
                /// <para>X86/X64 Specific</para>
                /// <para>----------------</para>
                /// <para>Jump prediction is usually based on the direction of the jump. If the</para>
                /// <para>jump is backward it is usually predicted as taken; and if the jump is</para>
                /// <para>forward it is usually predicted as not-taken. The reason is that loops</para>
                /// <para>generally use backward jumps and conditions usually use forward jumps.</para>
                /// <para>However this behavior can be overridden by using instruction prefixes.</para>
                /// <para>If this option is enabled these hints will be emitted.</para>
                /// <para>This feature is disabled by default, because the only processor that</para>
                /// <para>used to take into consideration prediction hints was P4. Newer processors</para>
                /// <para>implement heuristics for branch prediction that ignores any static hints.</para>
                /// </remarks>
                kHintPredictedJumps = 0x2
            }

            /// <summary>CodeEmitter options that are merged with instruction options.</summary>
            public enum Options : uint
            {
                /// <summary>
                /// <para>Reserved, used to check for errors in `Assembler::_emit()`. In addition,</para>
                /// <para>if an emitter is in error state it will have `kOptionMaybeFailureCase`</para>
                /// <para>set</para>
                /// </summary>
                kOptionMaybeFailureCase = 0x1,
                /// <summary>Perform a strict validation before the instruction is emitted.</summary>
                kOptionStrictValidation = 0x2,
                /// <summary>Logging is enabled and `CodeHolder::getLogger()` should return a valid</summary>
                kOptionLoggingEnabled = 0x4,
                /// <summary>
                /// <para>Mask of all internal options that are not used to represent instruction</para>
                /// <para>options, but are used to instrument Assembler and CodeBuilder. These</para>
                /// <para>options are internal and should not be used outside of AsmJit itself.</para>
                /// </summary>
                /// <remarks>NOTE: Reserved options should never appear in `CBInst` options.</remarks>
                kOptionReservedMask = 0x7,
                /// <summary>Used only by Assembler to mark `_op4` and `_op5` are used.</summary>
                kOptionOp4Op5Used = 0x8,
                /// <summary>Prevents following a jump during compilation (CodeCompiler).</summary>
                kOptionUnfollow = 0x10,
                /// <summary>Overwrite the destination operand (CodeCompiler).</summary>
                /// <remarks>
                /// <para>Hint that is important for register liveness analysis. It tells the</para>
                /// <para>compiler that the destination operand will be overwritten now or by</para>
                /// <para>adjacent instructions. CodeCompiler knows when a register is completely</para>
                /// <para>overwritten by a single instruction, for example you don't have to</para>
                /// <para>mark &quot;movaps&quot; or &quot;pxor x, x&quot;, however, if a pair of instructions is</para>
                /// <para>used and the first of them doesn't completely overwrite the content</para>
                /// <para>of the destination, CodeCompiler fails to mark that register as dead.</para>
                /// <para>X86/X64 Specific</para>
                /// <para>----------------</para>
                /// <para>- All instructions that always overwrite at least the size of the</para>
                /// <para>register the virtual-register uses , for example &quot;mov&quot;, &quot;movq&quot;,</para>
                /// <para>&quot;movaps&quot; don't need the overwrite option to be used - conversion,</para>
                /// <para>shuffle, and other miscellaneous instructions included.</para>
                /// <para>- All instructions that clear the destination register if all operands</para>
                /// <para>are the same, for example &quot;xor x, x&quot;, &quot;pcmpeqb x x&quot;, etc...</para>
                /// <para>- Consecutive instructions that partially overwrite the variable until</para>
                /// <para>there is no old content require the `overwrite()` to be used. Some</para>
                /// <para>examples (not always the best use cases thought):</para>
                /// <para>- `movlps xmm0, ?` followed by `movhps xmm0, ?` and vice versa</para>
                /// <para>- `movlpd xmm0, ?` followed by `movhpd xmm0, ?` and vice versa</para>
                /// <para>- `mov al, ?` followed by `and ax, 0xFF`</para>
                /// <para>- `mov al, ?` followed by `mov ah, al`</para>
                /// <para>- `pinsrq xmm0, ?, 0` followed by `pinsrq xmm0, ?, 1`</para>
                /// <para>- If allocated variable is used temporarily for scalar operations. For</para>
                /// <para>example if you allocate a full vector like `X86Compiler::newXmm()`</para>
                /// <para>and then use that vector for scalar operations you should use</para>
                /// <para>`overwrite()` directive:</para>
                /// <para>- `sqrtss x, y` - only LO element of `x` is changed, if you don't use</para>
                /// <para>HI elements, use `X86Compiler.overwrite().sqrtss(x, y)`.</para>
                /// </remarks>
                kOptionOverwrite = 0x20
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CodeEmitter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CodeEmitter>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeEmitterInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeEmitterInternal(native, skipVTables);
            }

            protected CodeEmitter(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            protected CodeEmitter(uint type)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), type);
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.CodeEmitter");
            }

            protected CodeEmitter(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.CodeEmitter");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__Internal*) __Instance)->vfptr_CodeEmitter = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Called after the</summary>
            public abstract uint OnAttach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code);

            /// <summary>Called after the</summary>
            public abstract uint OnDetach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code);

            /// <summary>Emit instruction having max 6 operands.</summary>
            public abstract uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, global::GraphEngine.Jit.Native.Asmjit.Operand_ o5);

            /// <summary>Emit instruction having operands stored in array.</summary>
            public virtual uint EmitOpArray(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ opArray, ulong opCount)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___EmitOpArrayDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_ulong));
                var __arg1 = ReferenceEquals(opArray, null) ? global::System.IntPtr.Zero : opArray.__Instance;
                var __ret = ___EmitOpArrayDelegate((__Instance + __PointerAdjustment), instId, __arg1, opCount);
                return __ret;
            }

            /// <summary>Create a new label.</summary>
            public abstract global::GraphEngine.Jit.Native.Asmjit.Label NewLabel();

            /// <summary>Create a new named label.</summary>
            public abstract global::GraphEngine.Jit.Native.Asmjit.Label NewNamedLabel(string name, ulong nameLength, uint type, uint parentId);

            /// <summary>Bind the `label` to the current position of the current section.</summary>
            /// <remarks>NOTE: Attempt to bind the same label multiple times will return an error.</remarks>
            public abstract uint Bind(global::GraphEngine.Jit.Native.Asmjit.Label label);

            /// <summary>Embed raw data into the code-buffer.</summary>
            public abstract uint Embed(global::System.IntPtr data, uint size);

            /// <summary>Embed absolute label address as data (4 or 8 bytes).</summary>
            public abstract uint EmbedLabel(global::GraphEngine.Jit.Native.Asmjit.Label label);

            /// <summary>
            /// <para>Embed a constant pool into the code-buffer in the following steps:</para>
            /// <para>1. Align by using kAlignData to the minimum `pool` alignment.</para>
            /// <para>2. Bind `label` so it's bound to an aligned location.</para>
            /// <para>3. Emit constant pool data.</para>
            /// </summary>
            public abstract uint EmbedConstPool(global::GraphEngine.Jit.Native.Asmjit.Label label, global::GraphEngine.Jit.Native.Asmjit.ConstPool pool);

            /// <summary>Emit a comment string `s` with an optional `len` parameter.</summary>
            public abstract uint Comment(string s, ulong len);

            /// <summary>Emit instruction having max 4 operands.</summary>
            public abstract uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3);

            /// <summary>Align to the `alignment` specified.</summary>
            /// <remarks>
            /// <para>The sequence that is used to fill the gap between the aligned location</para>
            /// <para>and the current location depends on the align `mode`, see</para>
            /// </remarks>
            public abstract uint Align(uint mode, uint alignment);

            public virtual uint Finalize()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 14 * 8);
                var ___FinalizeDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr));
                var __ret = ___FinalizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get a label by name.</summary>
            /// <remarks>
            /// <para>Returns invalid Label in case that the name is invalid or label was not found.</para>
            /// <para>NOTE: This function doesn't trigger ErrorHandler in case the name is</para>
            /// <para>invalid or no such label exist. You must always check the validity of the</para>
            /// </remarks>
            public global::GraphEngine.Jit.Native.Asmjit.Label GetLabelByName(string name, ulong nameLength, uint parentId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                __Internal.GetLabelByName((__Instance + __PointerAdjustment), new IntPtr(&__ret), name, nameLength, parentId);
                return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
            }

            /// <summary>Set the last error code and propagate it through the error handler.</summary>
            public uint SetLastError(uint error, string message)
            {
                var __ret = __Internal.SetLastError((__Instance + __PointerAdjustment), error, message);
                return __ret;
            }

            /// <summary>Clear the last error code and return `kErrorOk`.</summary>
            public uint ResetLastError()
            {
                var __ret = __Internal.ResetLastError((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Add options of the next instruction.</summary>
            public void AddOptions(uint options)
            {
                __Internal.AddOptions((__Instance + __PointerAdjustment), options);
            }

            /// <summary>Reset options of the next instruction.</summary>
            public void ResetOptions()
            {
                __Internal.ResetOptions((__Instance + __PointerAdjustment));
            }

            /// <summary>Set an extra operand that will be used by the next instruction (architecture specific).</summary>
            public void SetExtraReg(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                __Internal.SetExtraReg((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Reset an extra operand that will be used by the next instruction (architecture specific).</summary>
            public void ResetExtraReg()
            {
                __Internal.ResetExtraReg((__Instance + __PointerAdjustment));
            }

            /// <summary>Reset annotation of the next instruction to null.</summary>
            public void ResetInlineComment()
            {
                __Internal.ResetInlineComment((__Instance + __PointerAdjustment));
            }

            /// <summary>Get if the `label` is valid (i.e. registered).</summary>
            public bool IsLabelValid(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = __Internal.IsLabelValid((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Get if the label `id` is valid (i.e. registered).</summary>
            public bool IsLabelValid(uint id)
            {
                var __ret = __Internal.IsLabelValid((__Instance + __PointerAdjustment), id);
                return __ret;
            }

            /// <summary>Emit a formatted string `fmt`.</summary>
            public uint Commentf(string fmt)
            {
                var __ret = __Internal.Commentf((__Instance + __PointerAdjustment), fmt);
                return __ret;
            }

            /// <summary>Emit an instruction.</summary>
            public uint Emit(uint instId)
            {
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, __arg1);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, __arg1, __arg2);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3);
                return __ret;
            }


            public uint emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = __Internal.emit((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, __arg5);
                return __ret;
            }


            public uint emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, global::GraphEngine.Jit.Native.Asmjit.Operand_ o5)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                if (ReferenceEquals(o5, null))
                    throw new global::System.ArgumentNullException("o5", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = o5.__Instance;
                var __ret = __Internal.emit((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                return __ret;
            }

            /// <summary>Emit an instruction that has a 32-bit signed immediate operand.</summary>
            public uint Emit(uint instId, int o0)
            {
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, o0);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, int o1)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, __arg1, o1);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, int o2)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, __arg1, __arg2, o2);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, int o3)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, o3);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, int o4)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, o4);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, int o5)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                var __ret = __Internal.Emit((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, __arg5, o5);
                return __ret;
            }

            /// <summary>Emit an instruction that has a 64-bit signed immediate operand.</summary>
            public uint Emit(uint instId, long o0)
            {
                var __ret = __Internal.Emit_1((__Instance + __PointerAdjustment), instId, o0);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, long o1)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                var __ret = __Internal.Emit_1((__Instance + __PointerAdjustment), instId, __arg1, o1);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, long o2)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                var __ret = __Internal.Emit_1((__Instance + __PointerAdjustment), instId, __arg1, __arg2, o2);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, long o3)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                var __ret = __Internal.Emit_1((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, o3);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, long o4)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = __Internal.Emit_1((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, o4);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, long o5)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                var __ret = __Internal.Emit_1((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, __arg5, o5);
                return __ret;
            }


            public uint Emit(uint instId, uint o0)
            {
                var __ret = __Internal.Emit_2((__Instance + __PointerAdjustment), instId, o0);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, uint o1)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                var __ret = __Internal.Emit_2((__Instance + __PointerAdjustment), instId, __arg1, o1);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, uint o2)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                var __ret = __Internal.Emit_2((__Instance + __PointerAdjustment), instId, __arg1, __arg2, o2);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, uint o3)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                var __ret = __Internal.Emit_2((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, o3);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, uint o4)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = __Internal.Emit_2((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, o4);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, uint o5)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                var __ret = __Internal.Emit_2((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, __arg5, o5);
                return __ret;
            }


            public uint Emit(uint instId, ulong o0)
            {
                var __ret = __Internal.Emit_3((__Instance + __PointerAdjustment), instId, o0);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, ulong o1)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                var __ret = __Internal.Emit_3((__Instance + __PointerAdjustment), instId, __arg1, o1);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, ulong o2)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                var __ret = __Internal.Emit_3((__Instance + __PointerAdjustment), instId, __arg1, __arg2, o2);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, ulong o3)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                var __ret = __Internal.Emit_3((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, o3);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, ulong o4)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = __Internal.Emit_3((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, o4);
                return __ret;
            }


            public uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, ulong o5)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                var __ret = __Internal.Emit_3((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, __arg5, o5);
                return __ret;
            }

            public uint emitOpArray(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ opArray, ulong opCount)
            {
                var __arg1 = ReferenceEquals(opArray, null) ? global::System.IntPtr.Zero : opArray.__Instance;
                var __ret = __Internal.emitOpArray((__Instance + __PointerAdjustment), instId, __arg1, opCount);
                return __ret;
            }

            /// <summary>Get options of the next instruction.</summary>
            /// <remarks>Set options of the next instruction.</remarks>
            public uint options
            {
                get
                {
                    var __ret = __Internal.GetOptions((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetOptions((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get an extra operand that will be used by the next instruction (architecture specific).</summary>
            /// <remarks>Set an extra operand that will be used by the next instruction (architecture specific).</remarks>
            public global::GraphEngine.Jit.Native.Asmjit.RegOnly ExtraReg
            {
                get
                {
                    var __ret = __Internal.GetExtraReg((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.RegOnly __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.RegOnly.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.RegOnly) global::GraphEngine.Jit.Native.Asmjit.RegOnly.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.RegOnly.__CreateInstance(__ret);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetExtraReg_1((__Instance + __PointerAdjustment), __arg0);
                }
            }

            /// <summary>Get annotation of the next instruction.</summary>
            /// <remarks>
            /// <para>Set annotation of the next instruction.</para>
            /// <para>NOTE: This string is set back to null by `_emit()`, but until that it has</para>
            /// <para>to remain valid as `CodeEmitter` is not required to make a copy of it (and</para>
            /// <para>it would be slow to do that for each instruction).</para>
            /// </remarks>
            public string InlineComment
            {
                get
                {
                    var __ret = __Internal.GetInlineComment((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }

                set
                {
                    __Internal.SetInlineComment((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get if the CodeEmitter is initialized (i.e. attached to a</summary>
            public bool IsInitialized
            {
                get
                {
                    var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get information about the code, see</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CodeInfo CodeInfo
            {
                get
                {
                    var __ret = __Internal.GetCodeInfo((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CodeInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CodeInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeInfo) global::GraphEngine.Jit.Native.Asmjit.CodeInfo.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CodeHolder Code
            {
                get
                {
                    var __ret = __Internal.GetCode((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get information about the architecture, see</summary>
            public global::GraphEngine.Jit.Native.Asmjit.ArchInfo ArchInfo
            {
                get
                {
                    var __ret = __Internal.GetArchInfo((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.ArchInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ArchInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ArchInfo) global::GraphEngine.Jit.Native.Asmjit.ArchInfo.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.ArchInfo.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get if the target architecture is 32-bit.</summary>
            public bool Is32Bit
            {
                get
                {
                    var __ret = __Internal.Is32Bit((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the target architecture is 64-bit.</summary>
            public bool Is64Bit
            {
                get
                {
                    var __ret = __Internal.Is64Bit((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the target architecture type.</summary>
            public uint ArchType
            {
                get
                {
                    var __ret = __Internal.GetArchType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the target architecture sub-type.</summary>
            public uint ArchSubType
            {
                get
                {
                    var __ret = __Internal.GetArchSubType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the target architecture's GP register size (4 or 8 bytes).</summary>
            public uint GpSize
            {
                get
                {
                    var __ret = __Internal.GetGpSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the number of target GP registers.</summary>
            public uint GpCount
            {
                get
                {
                    var __ret = __Internal.GetGpCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the type of this CodeEmitter, see</summary>
            public uint type
            {
                get
                {
                    var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsAssembler
            {
                get
                {
                    var __ret = __Internal.IsAssembler((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsCodeBuilder
            {
                get
                {
                    var __ret = __Internal.IsCodeBuilder((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsCodeCompiler
            {
                get
                {
                    var __ret = __Internal.IsCodeCompiler((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get global hints.</summary>
            public uint GlobalHints
            {
                get
                {
                    var __ret = __Internal.GetGlobalHints((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get global options.</summary>
            /// <remarks>
            /// <para>Global options are merged with instruction options before the instruction</para>
            /// <para>is encoded. These options have some bits reserved that are used for error</para>
            /// <para>checking, logging, and strict validation. Other options are globals that</para>
            /// <para>affect each instruction, for example if VEX3 is set globally, it will all</para>
            /// <para>instructions, even those that don't have such option set.</para>
            /// </remarks>
            public uint GlobalOptions
            {
                get
                {
                    var __ret = __Internal.GetGlobalOptions((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the object is in error state.</summary>
            /// <remarks>
            /// <para>Error state means that it does not consume anything unless the error</para>
            /// <para>state is reset by calling `resetLastError()`. Use `getLastError()` to</para>
            /// <para>get the last error that put the object into the error state.</para>
            /// </remarks>
            public bool IsInErrorState
            {
                get
                {
                    var __ret = __Internal.IsInErrorState((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the last error code.</summary>
            public uint LastError
            {
                get
                {
                    var __ret = __Internal.GetLastError((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the extra register operand is valid.</summary>
            public bool HasExtraReg
            {
                get
                {
                    var __ret = __Internal.HasExtraReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~CodeEmitter() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error onAttach(CodeHolder* code) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnAttachDelegateInstance;

            private static uint _OnAttachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnAttach(__result0);
                return __ret;
            }

            // Error onDetach(CodeHolder* code) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnDetachDelegateInstance;

            private static uint _OnDetachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnDetach(__result0);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3, const Operand_& o4, const Operand_& o5) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _EmitDelegateInstance;

            private static uint _EmitDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, global::System.IntPtr o5)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result5;
                if (o4 == IntPtr.Zero) __result5 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o4))
                    __result5 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o4];
                else __result5 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o4);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result6;
                if (o5 == IntPtr.Zero) __result6 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o5))
                    __result6 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o5];
                else __result6 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o5);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4, __result5, __result6);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr _Emit_1DelegateInstance;

            private static uint _Emit_1DelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4);
                return __ret;
            }

            // Error _emitOpArray(uint32_t instId, const Operand_* opArray, size_t opCount)
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_ulong _EmitOpArrayDelegateInstance;

            private static uint _EmitOpArrayDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr opArray, ulong opCount)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (opArray == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(opArray))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[opArray];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(opArray);
                var __ret = __target.EmitOpArray(instId, __result1, opCount);
                return __ret;
            }

            // Label newLabel() = 0
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr _NewLabelDelegateInstance;

            private static void _NewLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewLabel();
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Label newNamedLabel( const char* name, size_t nameLength = Globals::kInvalidIndex, uint32_t type = Label::kTypeGlobal, uint32_t parentId = 0) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint _NewNamedLabelDelegateInstance;

            private static void _NewNamedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string name, ulong nameLength, uint type, uint parentId)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewNamedLabel(name, nameLength, type, parentId);
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Error bind(const Label& label) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _BindDelegateInstance;

            private static uint _BindDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.Bind(__result0);
                return __ret;
            }

            // Error align(uint32_t mode, uint32_t alignment) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint _AlignDelegateInstance;

            private static uint _AlignDelegateHook(global::System.IntPtr instance, uint mode, uint alignment)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Align(mode, alignment);
                return __ret;
            }

            // Error embed(const void* data, uint32_t size) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint _EmbedDelegateInstance;

            private static uint _EmbedDelegateHook(global::System.IntPtr instance, global::System.IntPtr data, uint size)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Embed(data, size);
                return __ret;
            }

            // Error embedLabel(const Label& label) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _EmbedLabelDelegateInstance;

            private static uint _EmbedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.EmbedLabel(__result0);
                return __ret;
            }

            // Error embedConstPool(const Label& label, const ConstPool& pool) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr _EmbedConstPoolDelegateInstance;

            private static uint _EmbedConstPoolDelegateHook(global::System.IntPtr instance, global::System.IntPtr label, global::System.IntPtr pool)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                global::GraphEngine.Jit.Native.Asmjit.ConstPool __result1;
                if (pool == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap.ContainsKey(pool))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.ConstPool) global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap[pool];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.ConstPool.__CreateInstance(pool);
                var __ret = __target.EmbedConstPool(__result0, __result1);
                return __ret;
            }

            // Error comment(const char* s, size_t len = Globals::kInvalidIndex) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong _CommentDelegateInstance;

            private static uint _CommentDelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s, ulong len)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Comment(s, len);
                return __ret;
            }

            // Error finalize()
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr _FinalizeDelegateInstance;

            private static uint _FinalizeDelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Finalize();
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[15];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _OnAttachDelegateInstance += _OnAttachDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnAttachDelegateInstance).ToPointer();
                    _OnDetachDelegateInstance += _OnDetachDelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnDetachDelegateInstance).ToPointer();
                    _EmitDelegateInstance += _EmitDelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EmitDelegateInstance).ToPointer();
                    _Emit_1DelegateInstance += _Emit_1DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Emit_1DelegateInstance).ToPointer();
                    _EmitOpArrayDelegateInstance += _EmitOpArrayDelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_EmitOpArrayDelegateInstance).ToPointer();
                    _NewLabelDelegateInstance += _NewLabelDelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewLabelDelegateInstance).ToPointer();
                    _NewNamedLabelDelegateInstance += _NewNamedLabelDelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewNamedLabelDelegateInstance).ToPointer();
                    _BindDelegateInstance += _BindDelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_BindDelegateInstance).ToPointer();
                    _AlignDelegateInstance += _AlignDelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_AlignDelegateInstance).ToPointer();
                    _EmbedDelegateInstance += _EmbedDelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_EmbedDelegateInstance).ToPointer();
                    _EmbedLabelDelegateInstance += _EmbedLabelDelegateHook;
                    _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_EmbedLabelDelegateInstance).ToPointer();
                    _EmbedConstPoolDelegateInstance += _EmbedConstPoolDelegateHook;
                    _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_EmbedConstPoolDelegateInstance).ToPointer();
                    _CommentDelegateInstance += _CommentDelegateHook;
                    _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_CommentDelegateInstance).ToPointer();
                    _FinalizeDelegateInstance += _FinalizeDelegateHook;
                    _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_FinalizeDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(15 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                        *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                        *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                        *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                        *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                        *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                        *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                        *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                        *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                        *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                        *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                        *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                        *(void**) (vfptr0 + 104) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 104);
                        *(void**) (vfptr0 + 112) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 112);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(15 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                        *(void**) (vfptr0 + 16) = _Thunks[2];
                        *(void**) (vfptr0 + 24) = _Thunks[3];
                        *(void**) (vfptr0 + 32) = _Thunks[4];
                        *(void**) (vfptr0 + 40) = _Thunks[5];
                        *(void**) (vfptr0 + 48) = _Thunks[6];
                        *(void**) (vfptr0 + 56) = _Thunks[7];
                        *(void**) (vfptr0 + 64) = _Thunks[8];
                        *(void**) (vfptr0 + 72) = _Thunks[9];
                        *(void**) (vfptr0 + 80) = _Thunks[10];
                        *(void**) (vfptr0 + 88) = _Thunks[11];
                        *(void**) (vfptr0 + 96) = _Thunks[12];
                        *(void**) (vfptr0 + 104) = _Thunks[13];
                        *(void**) (vfptr0 + 112) = _Thunks[14];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        public unsafe partial class CodeEmitterInternal : global::GraphEngine.Jit.Native.Asmjit.CodeEmitter, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CodeEmitterInternal(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal CodeEmitterInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Called after the</summary>
            public override uint OnAttach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___OnAttachDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___OnAttachDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Called after the</summary>
            public override uint OnDetach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___OnDetachDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___OnDetachDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Emit instruction having max 6 operands.</summary>
            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, global::GraphEngine.Jit.Native.Asmjit.Operand_ o5)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___EmitDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                if (ReferenceEquals(o5, null))
                    throw new global::System.ArgumentNullException("o5", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = o5.__Instance;
                var __ret = ___EmitDelegate((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                return __ret;
            }

            /// <summary>Create a new label.</summary>
            public override global::GraphEngine.Jit.Native.Asmjit.Label NewLabel()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___NewLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                ___NewLabelDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
            }

            /// <summary>Create a new named label.</summary>
            public override global::GraphEngine.Jit.Native.Asmjit.Label NewNamedLabel(string name, ulong nameLength, uint type, uint parentId)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___NewNamedLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint));
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                ___NewNamedLabelDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), name, nameLength, type, parentId);
                return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
            }

            /// <summary>Bind the `label` to the current position of the current section.</summary>
            /// <remarks>NOTE: Attempt to bind the same label multiple times will return an error.</remarks>
            public override uint Bind(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___BindDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = ___BindDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Embed raw data into the code-buffer.</summary>
            public override uint Embed(global::System.IntPtr data, uint size)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
                var ___EmbedDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint));
                var __ret = ___EmbedDelegate((__Instance + __PointerAdjustment), data, size);
                return __ret;
            }

            /// <summary>Embed absolute label address as data (4 or 8 bytes).</summary>
            public override uint EmbedLabel(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
                var ___EmbedLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = ___EmbedLabelDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Embed a constant pool into the code-buffer in the following steps:</para>
            /// <para>1. Align by using kAlignData to the minimum `pool` alignment.</para>
            /// <para>2. Bind `label` so it's bound to an aligned location.</para>
            /// <para>3. Emit constant pool data.</para>
            /// </summary>
            public override uint EmbedConstPool(global::GraphEngine.Jit.Native.Asmjit.Label label, global::GraphEngine.Jit.Native.Asmjit.ConstPool pool)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
                var ___EmbedConstPoolDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                if (ReferenceEquals(pool, null))
                    throw new global::System.ArgumentNullException("pool", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = pool.__Instance;
                var __ret = ___EmbedConstPoolDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }

            /// <summary>Emit a comment string `s` with an optional `len` parameter.</summary>
            public override uint Comment(string s, ulong len)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 13 * 8);
                var ___CommentDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong));
                var __ret = ___CommentDelegate((__Instance + __PointerAdjustment), s, len);
                return __ret;
            }

            /// <summary>Emit instruction having max 4 operands.</summary>
            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___Emit_1Delegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = ___Emit_1Delegate((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4);
                return __ret;
            }

            /// <summary>Align to the `alignment` specified.</summary>
            /// <remarks>
            /// <para>The sequence that is used to fill the gap between the aligned location</para>
            /// <para>and the current location depends on the align `mode`, see</para>
            /// </remarks>
            public override uint Align(uint mode, uint alignment)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
                var ___AlignDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint));
                var __ret = ___AlignDelegate((__Instance + __PointerAdjustment), mode, alignment);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Base assembler.</summary>
        /// <remarks>
        /// <para>This class implements a base interface that is used by architecture</para>
        /// <para>specific assemblers.</para>
        /// <para>CodeCompiler.</para>
        /// </remarks>
        public unsafe abstract partial class Assembler : global::GraphEngine.Jit.Native.Asmjit.CodeEmitter, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 184)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_CodeEmitter;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(24)]
                internal global::System.IntPtr _code;

                [FieldOffset(32)]
                internal global::System.IntPtr _nextEmitter;

                [FieldOffset(40)]
                internal byte _type;

                [FieldOffset(41)]
                internal byte _destroyed;

                [FieldOffset(42)]
                internal byte _finalized;

                [FieldOffset(43)]
                internal byte _reserved;

                [FieldOffset(44)]
                internal uint _lastError;

                [FieldOffset(48)]
                internal uint _privateData;

                [FieldOffset(52)]
                internal uint _globalHints;

                [FieldOffset(56)]
                internal uint _globalOptions;

                [FieldOffset(60)]
                internal uint _options;

                [FieldOffset(64)]
                internal global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal _extraReg;

                [FieldOffset(72)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(80)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal _none;

                [FieldOffset(96)]
                internal global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal _nativeGpReg;

                [FieldOffset(112)]
                internal global::System.IntPtr _nativeGpArray;

                [FieldOffset(120)]
                internal global::System.IntPtr _section;

                [FieldOffset(128)]
                internal global::System.IntPtr _bufferData;

                [FieldOffset(136)]
                internal global::System.IntPtr _bufferEnd;

                [FieldOffset(144)]
                internal global::System.IntPtr _bufferPtr;

                [FieldOffset(152)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal _op4;

                [FieldOffset(168)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal _op5;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Assembler@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1Assembler@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setOffset@Assembler@asmjit@@QEAAI_K@Z")]
                internal static extern uint SetOffset(global::System.IntPtr instance, ulong offset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_emitLog@Assembler@asmjit@@IEAAXIIAEBUOperand_@2@000IIPEAE@Z")]
                internal static extern void EmitLog(global::System.IntPtr instance, uint instId, uint options, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, uint relSize, uint imLen, byte* afterCursor);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_emitFailed@Assembler@asmjit@@IEAAIIIIAEBUOperand_@2@000@Z")]
                internal static extern uint EmitFailed(global::System.IntPtr instance, uint err, uint instId, uint options, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBufferCapacity@Assembler@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetBufferCapacity(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRemainingSpace@Assembler@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetRemainingSpace(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOffset@Assembler@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBufferData@Assembler@asmjit@@QEBAPEAEXZ")]
                internal static extern byte* GetBufferData(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBufferEnd@Assembler@asmjit@@QEBAPEAEXZ")]
                internal static extern byte* GetBufferEnd(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getBufferPtr@Assembler@asmjit@@QEBAPEAEXZ")]
                internal static extern byte* GetBufferPtr(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.Assembler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.AssemblerInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Assembler __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Assembler.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.AssemblerInternal(native, skipVTables);
            }

            protected Assembler(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a new `Assembler` instance.</summary>
            protected Assembler()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Assembler.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.Assembler");
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.Assembler.__Internal*) __Instance)->vfptr_CodeEmitter = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override uint OnAttach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___OnAttachDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___OnAttachDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public override uint OnDetach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___OnDetachDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___OnDetachDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, global::GraphEngine.Jit.Native.Asmjit.Operand_ o5)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___EmitDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                if (ReferenceEquals(o5, null))
                    throw new global::System.ArgumentNullException("o5", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = o5.__Instance;
                var __ret = ___EmitDelegate((__Instance + __PointerAdjustment), instId, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                return __ret;
            }

            public override uint EmitOpArray(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ opArray, ulong opCount)
            {
                return base.EmitOpArray(instId, opArray, opCount);
            }

            /// <summary>Called by</summary>
            public virtual void Sync()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 15 * 8);
                var ___SyncDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr));
                ___SyncDelegate((__Instance + __PointerAdjustment));
            }

            /// <summary>Set the current position in the CodeBuffer to `offset`.</summary>
            /// <remarks>
            /// <para>NOTE: The `offset` cannot be outside of the buffer length (even if it's</para>
            /// <para>within buffer's capacity).</para>
            /// </remarks>
            public uint SetOffset(ulong offset)
            {
                var __ret = __Internal.SetOffset((__Instance + __PointerAdjustment), offset);
                return __ret;
            }

            public override global::GraphEngine.Jit.Native.Asmjit.Label NewLabel()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___NewLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                ___NewLabelDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
            }

            public override global::GraphEngine.Jit.Native.Asmjit.Label NewNamedLabel(string name, ulong nameLength, uint type, uint parentId)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___NewNamedLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint));
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                ___NewNamedLabelDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), name, nameLength, type, parentId);
                return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
            }

            public override uint Bind(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___BindDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = ___BindDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public override uint Embed(global::System.IntPtr data, uint size)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
                var ___EmbedDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint));
                var __ret = ___EmbedDelegate((__Instance + __PointerAdjustment), data, size);
                return __ret;
            }

            public override uint EmbedLabel(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
                var ___EmbedLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = ___EmbedLabelDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public override uint EmbedConstPool(global::GraphEngine.Jit.Native.Asmjit.Label label, global::GraphEngine.Jit.Native.Asmjit.ConstPool pool)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
                var ___EmbedConstPoolDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                if (ReferenceEquals(pool, null))
                    throw new global::System.ArgumentNullException("pool", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = pool.__Instance;
                var __ret = ___EmbedConstPoolDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }

            public override uint Comment(string s, ulong len)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 13 * 8);
                var ___CommentDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong));
                var __ret = ___CommentDelegate((__Instance + __PointerAdjustment), s, len);
                return __ret;
            }

            protected void EmitLog(uint instId, uint options, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, uint relSize, uint imLen, byte* afterCursor)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o3.__Instance;
                __Internal.EmitLog((__Instance + __PointerAdjustment), instId, options, __arg2, __arg3, __arg4, __arg5, relSize, imLen, afterCursor);
            }

            protected uint EmitFailed(uint err, uint instId, uint options, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = o3.__Instance;
                var __ret = __Internal.EmitFailed((__Instance + __PointerAdjustment), err, instId, options, __arg3, __arg4, __arg5, __arg6);
                return __ret;
            }

            /// <summary>Get the capacity of the current CodeBuffer.</summary>
            public ulong BufferCapacity
            {
                get
                {
                    var __ret = __Internal.GetBufferCapacity((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the number of remaining bytes in the current CodeBuffer.</summary>
            public ulong RemainingSpace
            {
                get
                {
                    var __ret = __Internal.GetRemainingSpace((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the current position in the CodeBuffer.</summary>
            public ulong Offset
            {
                get
                {
                    var __ret = __Internal.GetOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get start of the CodeBuffer of the current section.</summary>
            public byte* BufferData
            {
                get
                {
                    var __ret = __Internal.GetBufferData((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get end (first invalid byte) of the current section.</summary>
            public byte* BufferEnd
            {
                get
                {
                    var __ret = __Internal.GetBufferEnd((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get pointer in the CodeBuffer of the current section.</summary>
            public byte* BufferPtr
            {
                get
                {
                    var __ret = __Internal.GetBufferPtr((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~Assembler() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error onAttach(CodeHolder* code) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnAttachDelegateInstance;

            private static uint _OnAttachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnAttach(__result0);
                return __ret;
            }

            // Error onDetach(CodeHolder* code) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnDetachDelegateInstance;

            private static uint _OnDetachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnDetach(__result0);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3, const Operand_& o4, const Operand_& o5) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _EmitDelegateInstance;

            private static uint _EmitDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, global::System.IntPtr o5)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result5;
                if (o4 == IntPtr.Zero) __result5 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o4))
                    __result5 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o4];
                else __result5 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o4);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result6;
                if (o5 == IntPtr.Zero) __result6 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o5))
                    __result6 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o5];
                else __result6 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o5);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4, __result5, __result6);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr _Emit_1DelegateInstance;

            private static uint _Emit_1DelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4);
                return __ret;
            }

            // Error _emitOpArray(uint32_t instId, const Operand_* opArray, size_t opCount) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_ulong _EmitOpArrayDelegateInstance;

            private static uint _EmitOpArrayDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr opArray, ulong opCount)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (opArray == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(opArray))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[opArray];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(opArray);
                var __ret = __target.EmitOpArray(instId, __result1, opCount);
                return __ret;
            }

            // Label newLabel() override
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr _NewLabelDelegateInstance;

            private static void _NewLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewLabel();
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Label newNamedLabel( const char* name, size_t nameLength = Globals::kInvalidIndex, uint32_t type = Label::kTypeGlobal, uint32_t parentId = 0) override
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint _NewNamedLabelDelegateInstance;

            private static void _NewNamedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string name, ulong nameLength, uint type, uint parentId)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewNamedLabel(name, nameLength, type, parentId);
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Error bind(const Label& label) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _BindDelegateInstance;

            private static uint _BindDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.Bind(__result0);
                return __ret;
            }

            // Error align(uint32_t mode, uint32_t alignment) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint _AlignDelegateInstance;

            private static uint _AlignDelegateHook(global::System.IntPtr instance, uint mode, uint alignment)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Align(mode, alignment);
                return __ret;
            }

            // Error embed(const void* data, uint32_t size) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint _EmbedDelegateInstance;

            private static uint _EmbedDelegateHook(global::System.IntPtr instance, global::System.IntPtr data, uint size)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Embed(data, size);
                return __ret;
            }

            // Error embedLabel(const Label& label) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _EmbedLabelDelegateInstance;

            private static uint _EmbedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.EmbedLabel(__result0);
                return __ret;
            }

            // Error embedConstPool(const Label& label, const ConstPool& pool) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr _EmbedConstPoolDelegateInstance;

            private static uint _EmbedConstPoolDelegateHook(global::System.IntPtr instance, global::System.IntPtr label, global::System.IntPtr pool)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                global::GraphEngine.Jit.Native.Asmjit.ConstPool __result1;
                if (pool == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap.ContainsKey(pool))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.ConstPool) global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap[pool];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.ConstPool.__CreateInstance(pool);
                var __ret = __target.EmbedConstPool(__result0, __result1);
                return __ret;
            }

            // Error comment(const char* s, size_t len = Globals::kInvalidIndex) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong _CommentDelegateInstance;

            private static uint _CommentDelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s, ulong len)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Comment(s, len);
                return __ret;
            }

            // Error finalize()
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr _FinalizeDelegateInstance;

            private static uint _FinalizeDelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Finalize();
                return __ret;
            }

            // void sync() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr _SyncDelegateInstance;

            private static void _SyncDelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Assembler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Sync();
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[16];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _OnAttachDelegateInstance += _OnAttachDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnAttachDelegateInstance).ToPointer();
                    _OnDetachDelegateInstance += _OnDetachDelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnDetachDelegateInstance).ToPointer();
                    _EmitDelegateInstance += _EmitDelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EmitDelegateInstance).ToPointer();
                    _Emit_1DelegateInstance += _Emit_1DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Emit_1DelegateInstance).ToPointer();
                    _EmitOpArrayDelegateInstance += _EmitOpArrayDelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_EmitOpArrayDelegateInstance).ToPointer();
                    _NewLabelDelegateInstance += _NewLabelDelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewLabelDelegateInstance).ToPointer();
                    _NewNamedLabelDelegateInstance += _NewNamedLabelDelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewNamedLabelDelegateInstance).ToPointer();
                    _BindDelegateInstance += _BindDelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_BindDelegateInstance).ToPointer();
                    _AlignDelegateInstance += _AlignDelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_AlignDelegateInstance).ToPointer();
                    _EmbedDelegateInstance += _EmbedDelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_EmbedDelegateInstance).ToPointer();
                    _EmbedLabelDelegateInstance += _EmbedLabelDelegateHook;
                    _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_EmbedLabelDelegateInstance).ToPointer();
                    _EmbedConstPoolDelegateInstance += _EmbedConstPoolDelegateHook;
                    _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_EmbedConstPoolDelegateInstance).ToPointer();
                    _CommentDelegateInstance += _CommentDelegateHook;
                    _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_CommentDelegateInstance).ToPointer();
                    _FinalizeDelegateInstance += _FinalizeDelegateHook;
                    _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_FinalizeDelegateInstance).ToPointer();
                    _SyncDelegateInstance += _SyncDelegateHook;
                    _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_SyncDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(16 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                        *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                        *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                        *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                        *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                        *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                        *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                        *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                        *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                        *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                        *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                        *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                        *(void**) (vfptr0 + 104) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 104);
                        *(void**) (vfptr0 + 112) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 112);
                        *(void**) (vfptr0 + 120) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 120);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(16 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                        *(void**) (vfptr0 + 16) = _Thunks[2];
                        *(void**) (vfptr0 + 24) = _Thunks[3];
                        *(void**) (vfptr0 + 32) = _Thunks[4];
                        *(void**) (vfptr0 + 40) = _Thunks[5];
                        *(void**) (vfptr0 + 48) = _Thunks[6];
                        *(void**) (vfptr0 + 56) = _Thunks[7];
                        *(void**) (vfptr0 + 64) = _Thunks[8];
                        *(void**) (vfptr0 + 72) = _Thunks[9];
                        *(void**) (vfptr0 + 80) = _Thunks[10];
                        *(void**) (vfptr0 + 88) = _Thunks[11];
                        *(void**) (vfptr0 + 96) = _Thunks[12];
                        *(void**) (vfptr0 + 104) = _Thunks[13];
                        *(void**) (vfptr0 + 112) = _Thunks[14];
                        *(void**) (vfptr0 + 120) = _Thunks[15];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        public unsafe partial class AssemblerInternal : global::GraphEngine.Jit.Native.Asmjit.Assembler, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Assembler.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Assembler.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.Assembler.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal AssemblerInternal(global::GraphEngine.Jit.Native.Asmjit.Assembler.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal AssemblerInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Emit instruction having max 4 operands.</summary>
            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___Emit_1Delegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = ___Emit_1Delegate((__Instance), instId, __arg1, __arg2, __arg3, __arg4);
                return __ret;
            }

            /// <summary>Align to the `alignment` specified.</summary>
            /// <remarks>
            /// <para>The sequence that is used to fill the gap between the aligned location</para>
            /// <para>and the current location depends on the align `mode`, see</para>
            /// </remarks>
            public override uint Align(uint mode, uint alignment)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
                var ___AlignDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint));
                var __ret = ___AlignDelegate((__Instance), mode, alignment);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Constant pool.</summary>
        public unsafe partial class ConstPool : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 224)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _zone;

                [FieldOffset(8)]
                internal fixed byte _tree[144];

                [FieldOffset(152)]
                internal fixed long _gaps[6];

                [FieldOffset(200)]
                internal global::System.IntPtr _gapPool;

                [FieldOffset(208)]
                internal ulong _size;

                [FieldOffset(216)]
                internal ulong _alignment;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ConstPool@asmjit@@QEAA@PEAVZone@1@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr zone);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1ConstPool@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@ConstPool@asmjit@@QEAAXPEAVZone@2@@Z")]
                internal static extern void Reset(global::System.IntPtr instance, global::System.IntPtr zone);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?add@ConstPool@asmjit@@QEAAIPEBX_KAEA_K@Z")]
                internal static extern uint Add(global::System.IntPtr instance, global::System.IntPtr data, ulong size, ulong* dstOffset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fill@ConstPool@asmjit@@QEBAXPEAX@Z")]
                internal static extern void Fill(global::System.IntPtr instance, global::System.IntPtr dst);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isEmpty@ConstPool@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEmpty(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSize@ConstPool@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAlignment@ConstPool@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetAlignment(global::System.IntPtr instance);
            }

            public enum KIndex
            {
                kIndex1 = 0,
                kIndex2 = 1,
                kIndex4 = 2,
                kIndex8 = 3,
                kIndex16 = 4,
                kIndex32 = 5,
                kIndexCount = 6
            }

            /// <summary>Zone-allocated const-pool tree.</summary>
            public unsafe partial class Tree : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr _root;

                    [FieldOffset(8)]
                    internal ulong _length;

                    [FieldOffset(16)]
                    internal ulong _dataSize;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Tree@ConstPool@asmjit@@QEAA@_K@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong dataSize);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Tree@ConstPool@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Tree@ConstPool@asmjit@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?reset@Tree@ConstPool@asmjit@@QEAAXXZ")]
                    internal static extern void Reset(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setDataSize@Tree@ConstPool@asmjit@@QEAAX_K@Z")]
                    internal static extern void SetDataSize(global::System.IntPtr instance, ulong dataSize);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?get@Tree@ConstPool@asmjit@@QEAAPEAUNode@23@PEBX@Z")]
                    internal static extern global::System.IntPtr Get(global::System.IntPtr instance, global::System.IntPtr data);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?put@Tree@ConstPool@asmjit@@QEAAXPEAUNode@23@@Z")]
                    internal static extern void Put(global::System.IntPtr instance, global::System.IntPtr node);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?_newNode@Tree@ConstPool@asmjit@@SAPEAUNode@23@PEAVZone@3@PEBX_K2_N@Z")]
                    internal static extern global::System.IntPtr NewNode(global::System.IntPtr zone, global::System.IntPtr data, ulong size, ulong offset, bool shared);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isEmpty@Tree@ConstPool@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsEmpty(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getLength@Tree@ConstPool@asmjit@@QEBA_KXZ")]
                    internal static extern ulong GetLength(global::System.IntPtr instance);
                }

                [Flags]
                public enum KHeightLimit
                {
                    /// <summary>Maximum tree height == log2(1&lt;&gt;&lt;&gt;64).</summary>
                    kHeightLimit = 64
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Tree(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Tree(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Tree(ulong dataSize)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), dataSize);
                }

                public Tree(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.ConstPool.Tree __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public void Reset()
                {
                    __Internal.Reset((__Instance + __PointerAdjustment));
                }

                public void SetDataSize(ulong dataSize)
                {
                    __Internal.SetDataSize((__Instance + __PointerAdjustment), dataSize);
                }

                public global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node Get(global::System.IntPtr data)
                {
                    var __ret = __Internal.Get((__Instance + __PointerAdjustment), data);
                    global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node) global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__CreateInstance(__ret);
                    return __result0;
                }

                public void Put(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node node)
                {
                    var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                    __Internal.Put((__Instance + __PointerAdjustment), __arg0);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node NewNode(global::GraphEngine.Jit.Native.Asmjit.Zone zone, global::System.IntPtr data, ulong size, ulong offset, bool shared)
                {
                    var __arg0 = ReferenceEquals(zone, null) ? global::System.IntPtr.Zero : zone.__Instance;
                    var __ret = __Internal.NewNode(__arg0, data, size, offset, shared);
                    global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node) global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__CreateInstance(__ret);
                    return __result0;
                }

                public bool IsEmpty
                {
                    get
                    {
                        var __ret = __Internal.IsEmpty((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public ulong Length
                {
                    get
                    {
                        var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            /// <summary>Zone-allocated const-pool node.</summary>
            public unsafe partial class Node : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed long _link[2];

                    [FieldOffset(16)]
                    internal uint _level;

                    [FieldOffset(19)]
                    internal uint _shared;

                    [FieldOffset(20)]
                    internal uint _offset;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Node@ConstPool@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getData@Node@ConstPool@asmjit@@QEBAPEAXXZ")]
                    internal static extern global::System.IntPtr GetData(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Node(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Node(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Node()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Node(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.ConstPool.Node __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::System.IntPtr Data
                {
                    get
                    {
                        var __ret = __Internal.GetData((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            /// <summary>Zone-allocated const-pool gap.</summary>
            public unsafe partial class Gap : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr _next;

                    [FieldOffset(8)]
                    internal ulong _offset;

                    [FieldOffset(16)]
                    internal ulong _length;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Gap@ConstPool@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Gap(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Gap(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Gap()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Gap(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.ConstPool.Gap __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ConstPool> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.ConstPool>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.ConstPool __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ConstPool(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.ConstPool __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.ConstPool.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.ConstPool(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.ConstPool.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.ConstPool.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ConstPool(global::GraphEngine.Jit.Native.Asmjit.ConstPool.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ConstPool(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ConstPool(global::GraphEngine.Jit.Native.Asmjit.Zone zone)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.ConstPool.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(zone, null) ? global::System.IntPtr.Zero : zone.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.ConstPool __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Reset(global::GraphEngine.Jit.Native.Asmjit.Zone zone)
            {
                var __arg0 = ReferenceEquals(zone, null) ? global::System.IntPtr.Zero : zone.__Instance;
                __Internal.Reset((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Add a constant to the constant pool.</summary>
            /// <remarks>
            /// <para>The constant must have known size, which is 1, 2, 4, 8, 16 or 32 bytes.</para>
            /// <para>The constant is added to the pool only if it doesn't not exist, otherwise</para>
            /// <para>cached value is returned.</para>
            /// <para>AsmJit is able to subdivide added constants, so for example if you add</para>
            /// <para>8-byte constant 0x1122334455667788 it will create the following slots:</para>
            /// <para>8-byte: 0x1122334455667788</para>
            /// <para>4-byte: 0x11223344, 0x55667788</para>
            /// <para>The reason is that when combining MMX/SSE/AVX code some patterns are used</para>
            /// <para>frequently. However, AsmJit is not able to reallocate a constant that has</para>
            /// <para>been already added. For example if you try to add 4-byte constant and then</para>
            /// <para>8-byte constant having the same 4-byte pattern as the previous one, two</para>
            /// <para>independent slots will be generated by the pool.</para>
            /// </remarks>
            public uint Add(global::System.IntPtr data, ulong size, ref ulong dstOffset)
            {
                fixed (ulong* __refParamPtr2 = &dstOffset)
                {
                    var __arg2 = __refParamPtr2;
                    var __ret = __Internal.Add((__Instance + __PointerAdjustment), data, size, __arg2);
                    return __ret;
                }
            }

            /// <summary>Fill the destination with the constants from the pool.</summary>
            public void Fill(global::System.IntPtr dst)
            {
                __Internal.Fill((__Instance + __PointerAdjustment), dst);
            }

            /// <summary>Get whether the constant-pool is empty.</summary>
            public bool IsEmpty
            {
                get
                {
                    var __ret = __Internal.IsEmpty((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the size of the constant-pool in bytes.</summary>
            public ulong Size
            {
                get
                {
                    var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get minimum alignment.</summary>
            public ulong Alignment
            {
                get
                {
                    var __ret = __Internal.GetAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>\{</summary>
        public unsafe abstract partial class CodeBuilder : global::GraphEngine.Jit.Native.Asmjit.CodeEmitter, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 392)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_CodeEmitter;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(24)]
                internal global::System.IntPtr _code;

                [FieldOffset(32)]
                internal global::System.IntPtr _nextEmitter;

                [FieldOffset(40)]
                internal byte _type;

                [FieldOffset(41)]
                internal byte _destroyed;

                [FieldOffset(42)]
                internal byte _finalized;

                [FieldOffset(43)]
                internal byte _reserved;

                [FieldOffset(44)]
                internal uint _lastError;

                [FieldOffset(48)]
                internal uint _privateData;

                [FieldOffset(52)]
                internal uint _globalHints;

                [FieldOffset(56)]
                internal uint _globalOptions;

                [FieldOffset(60)]
                internal uint _options;

                [FieldOffset(64)]
                internal global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal _extraReg;

                [FieldOffset(72)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(80)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal _none;

                [FieldOffset(96)]
                internal global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal _nativeGpReg;

                [FieldOffset(112)]
                internal global::System.IntPtr _nativeGpArray;

                [FieldOffset(120)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _cbBaseZone;

                [FieldOffset(152)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _cbDataZone;

                [FieldOffset(184)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _cbPassZone;

                [FieldOffset(216)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal _cbHeap;

                [FieldOffset(312)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _cbPasses;

                [FieldOffset(336)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _cbLabels;

                [FieldOffset(360)]
                internal global::System.IntPtr _firstNode;

                [FieldOffset(368)]
                internal global::System.IntPtr _lastNode;

                [FieldOffset(376)]
                internal global::System.IntPtr _cursor;

                [FieldOffset(384)]
                internal uint _position;

                [FieldOffset(388)]
                internal uint _nodeFlags;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CodeBuilder@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CodeBuilder@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?registerLabelNode@CodeBuilder@asmjit@@QEAAIPEAVCBLabel@2@@Z")]
                internal static extern uint RegisterLabelNode(global::System.IntPtr instance, global::System.IntPtr node);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCBLabel@CodeBuilder@asmjit@@QEAAIPEAPEAVCBLabel@2@I@Z")]
                internal static extern uint GetCBLabel(global::System.IntPtr instance, global::System.IntPtr pOut, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCBLabel@CodeBuilder@asmjit@@QEAAIPEAPEAVCBLabel@2@AEBVLabel@2@@Z")]
                internal static extern uint GetCBLabel(global::System.IntPtr instance, global::System.IntPtr pOut, global::System.IntPtr label);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newLabelNode@CodeBuilder@asmjit@@QEAAPEAVCBLabel@2@XZ")]
                internal static extern global::System.IntPtr NewLabelNode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newAlignNode@CodeBuilder@asmjit@@QEAAPEAVCBAlign@2@II@Z")]
                internal static extern global::System.IntPtr NewAlignNode(global::System.IntPtr instance, uint mode, uint alignment);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newDataNode@CodeBuilder@asmjit@@QEAAPEAVCBData@2@PEBXI@Z")]
                internal static extern global::System.IntPtr NewDataNode(global::System.IntPtr instance, global::System.IntPtr data, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newConstPool@CodeBuilder@asmjit@@QEAAPEAVCBConstPool@2@XZ")]
                internal static extern global::System.IntPtr NewConstPool(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newCommentNode@CodeBuilder@asmjit@@QEAAPEAVCBComment@2@PEBD_K@Z")]
                internal static extern global::System.IntPtr NewCommentNode(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addNode@CodeBuilder@asmjit@@QEAAPEAVCBNode@2@PEAV32@@Z")]
                internal static extern global::System.IntPtr AddNode(global::System.IntPtr instance, global::System.IntPtr node);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addAfter@CodeBuilder@asmjit@@QEAAPEAVCBNode@2@PEAV32@0@Z")]
                internal static extern global::System.IntPtr AddAfter(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr @ref);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addBefore@CodeBuilder@asmjit@@QEAAPEAVCBNode@2@PEAV32@0@Z")]
                internal static extern global::System.IntPtr AddBefore(global::System.IntPtr instance, global::System.IntPtr node, global::System.IntPtr @ref);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?removeNode@CodeBuilder@asmjit@@QEAAPEAVCBNode@2@PEAV32@@Z")]
                internal static extern global::System.IntPtr RemoveNode(global::System.IntPtr instance, global::System.IntPtr node);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?removeNodes@CodeBuilder@asmjit@@QEAAXPEAVCBNode@2@0@Z")]
                internal static extern void RemoveNodes(global::System.IntPtr instance, global::System.IntPtr first, global::System.IntPtr last);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_setCursor@CodeBuilder@asmjit@@QEAAXPEAVCBNode@2@@Z")]
                internal static extern void SetCursor(global::System.IntPtr instance, global::System.IntPtr node);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setCursor@CodeBuilder@asmjit@@QEAAPEAVCBNode@2@PEAV32@@Z")]
                internal static extern global::System.IntPtr setCursor(global::System.IntPtr instance, global::System.IntPtr node);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPassByName@CodeBuilder@asmjit@@QEBAPEAVCBPass@2@PEBD@Z")]
                internal static extern global::System.IntPtr GetPassByName(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addPass@CodeBuilder@asmjit@@QEAAIPEAVCBPass@2@@Z")]
                internal static extern uint AddPass(global::System.IntPtr instance, global::System.IntPtr pass);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?deletePass@CodeBuilder@asmjit@@QEAAIPEAVCBPass@2@@Z")]
                internal static extern uint DeletePass(global::System.IntPtr instance, global::System.IntPtr pass);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFirstNode@CodeBuilder@asmjit@@QEBAPEAVCBNode@2@XZ")]
                internal static extern global::System.IntPtr GetFirstNode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLastNode@CodeBuilder@asmjit@@QEBAPEAVCBNode@2@XZ")]
                internal static extern global::System.IntPtr GetLastNode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCursor@CodeBuilder@asmjit@@QEBAPEAVCBNode@2@XZ")]
                internal static extern global::System.IntPtr GetCursor(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CodeBuilder __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeBuilderInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeBuilder __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeBuilderInternal(native, skipVTables);
            }

            protected CodeBuilder(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a new `CodeBuilder` instance.</summary>
            protected CodeBuilder()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.CodeBuilder");
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.__Internal*) __Instance)->vfptr_CodeEmitter = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override uint OnAttach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___OnAttachDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___OnAttachDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public override uint OnDetach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___OnDetachDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___OnDetachDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public uint RegisterLabelNode(global::GraphEngine.Jit.Native.Asmjit.CBLabel node)
            {
                var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var __ret = __Internal.RegisterLabelNode((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Get `CBLabel` by `id`.</summary>
            public uint GetCBLabel(global::GraphEngine.Jit.Native.Asmjit.CBLabel pOut, uint id)
            {
                var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
                var __ret = __Internal.GetCBLabel((__Instance + __PointerAdjustment), __arg0, id);
                return __ret;
            }

            /// <summary>Get `CBLabel` by `label`.</summary>
            public uint GetCBLabel(global::GraphEngine.Jit.Native.Asmjit.CBLabel pOut, global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = label.__Instance;
                var __ret = __Internal.GetCBLabel((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }

            /// <summary>Create a new</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBLabel NewLabelNode()
            {
                var __ret = __Internal.NewLabelNode((__Instance + __PointerAdjustment));
                global::GraphEngine.Jit.Native.Asmjit.CBLabel __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBLabel.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBLabel) global::GraphEngine.Jit.Native.Asmjit.CBLabel.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBLabel.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Create a new</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBAlign NewAlignNode(uint mode, uint alignment)
            {
                var __ret = __Internal.NewAlignNode((__Instance + __PointerAdjustment), mode, alignment);
                global::GraphEngine.Jit.Native.Asmjit.CBAlign __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBAlign.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBAlign) global::GraphEngine.Jit.Native.Asmjit.CBAlign.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBAlign.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Create a new</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBData NewDataNode(global::System.IntPtr data, uint size)
            {
                var __ret = __Internal.NewDataNode((__Instance + __PointerAdjustment), data, size);
                global::GraphEngine.Jit.Native.Asmjit.CBData __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBData.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBData) global::GraphEngine.Jit.Native.Asmjit.CBData.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBData.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Create a new</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBConstPool NewConstPool()
            {
                var __ret = __Internal.NewConstPool((__Instance + __PointerAdjustment));
                global::GraphEngine.Jit.Native.Asmjit.CBConstPool __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBConstPool.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBConstPool) global::GraphEngine.Jit.Native.Asmjit.CBConstPool.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBConstPool.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Create a new</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBComment NewCommentNode(string s, ulong len)
            {
                var __ret = __Internal.NewCommentNode((__Instance + __PointerAdjustment), s, len);
                global::GraphEngine.Jit.Native.Asmjit.CBComment __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBComment.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBComment) global::GraphEngine.Jit.Native.Asmjit.CBComment.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBComment.__CreateInstance(__ret);
                return __result0;
            }

            public override global::GraphEngine.Jit.Native.Asmjit.Label NewLabel()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___NewLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                ___NewLabelDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
            }

            public override global::GraphEngine.Jit.Native.Asmjit.Label NewNamedLabel(string name, ulong nameLength, uint type, uint parentId)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___NewNamedLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint));
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                ___NewNamedLabelDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), name, nameLength, type, parentId);
                return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
            }

            public override uint Bind(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___BindDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = ___BindDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public override uint Align(uint mode, uint alignment)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
                var ___AlignDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint));
                var __ret = ___AlignDelegate((__Instance + __PointerAdjustment), mode, alignment);
                return __ret;
            }

            public override uint Embed(global::System.IntPtr data, uint size)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
                var ___EmbedDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint));
                var __ret = ___EmbedDelegate((__Instance + __PointerAdjustment), data, size);
                return __ret;
            }

            public override uint EmbedLabel(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
                var ___EmbedLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = ___EmbedLabelDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public override uint EmbedConstPool(global::GraphEngine.Jit.Native.Asmjit.Label label, global::GraphEngine.Jit.Native.Asmjit.ConstPool pool)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
                var ___EmbedConstPoolDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                if (ReferenceEquals(pool, null))
                    throw new global::System.ArgumentNullException("pool", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = pool.__Instance;
                var __ret = ___EmbedConstPoolDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }

            public override uint Comment(string s, ulong len)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 13 * 8);
                var ___CommentDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong));
                var __ret = ___CommentDelegate((__Instance + __PointerAdjustment), s, len);
                return __ret;
            }

            /// <summary>Add `node` after the current and set current to `node`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode AddNode(global::GraphEngine.Jit.Native.Asmjit.CBNode node)
            {
                var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var __ret = __Internal.AddNode((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Insert `node` after `ref`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode AddAfter(global::GraphEngine.Jit.Native.Asmjit.CBNode node, global::GraphEngine.Jit.Native.Asmjit.CBNode @ref)
            {
                var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var __arg1 = ReferenceEquals(@ref, null) ? global::System.IntPtr.Zero : @ref.__Instance;
                var __ret = __Internal.AddAfter((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Insert `node` before `ref`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode AddBefore(global::GraphEngine.Jit.Native.Asmjit.CBNode node, global::GraphEngine.Jit.Native.Asmjit.CBNode @ref)
            {
                var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var __arg1 = ReferenceEquals(@ref, null) ? global::System.IntPtr.Zero : @ref.__Instance;
                var __ret = __Internal.AddBefore((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Remove `node`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode RemoveNode(global::GraphEngine.Jit.Native.Asmjit.CBNode node)
            {
                var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var __ret = __Internal.RemoveNode((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Remove multiple nodes.</summary>
            public void RemoveNodes(global::GraphEngine.Jit.Native.Asmjit.CBNode first, global::GraphEngine.Jit.Native.Asmjit.CBNode last)
            {
                var __arg0 = ReferenceEquals(first, null) ? global::System.IntPtr.Zero : first.__Instance;
                var __arg1 = ReferenceEquals(last, null) ? global::System.IntPtr.Zero : last.__Instance;
                __Internal.RemoveNodes((__Instance + __PointerAdjustment), __arg0, __arg1);
            }

            /// <summary>Set the current node without returning the previous node.</summary>
            public void SetCursor(global::GraphEngine.Jit.Native.Asmjit.CBNode node)
            {
                var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                __Internal.SetCursor((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Set the current node to `node` and return the previous one.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode setCursor(global::GraphEngine.Jit.Native.Asmjit.CBNode node)
            {
                var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
                var __ret = __Internal.setCursor((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Get a `CBPass` by name.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBPass GetPassByName(string name)
            {
                var __ret = __Internal.GetPassByName((__Instance + __PointerAdjustment), name);
                global::GraphEngine.Jit.Native.Asmjit.CBPass __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBPass.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBPass) global::GraphEngine.Jit.Native.Asmjit.CBPass.NativeToManagedMap[__ret];
                else global::GraphEngine.Jit.Native.Asmjit.CBPass.NativeToManagedMap[__ret] = __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBPass) global::GraphEngine.Jit.Native.Asmjit.CBPass.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Add `pass` to the list of passes.</summary>
            public uint AddPass(global::GraphEngine.Jit.Native.Asmjit.CBPass pass)
            {
                var __arg0 = ReferenceEquals(pass, null) ? global::System.IntPtr.Zero : pass.__Instance;
                var __ret = __Internal.AddPass((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Remove `pass` from the list of passes and delete it.</summary>
            public uint DeletePass(global::GraphEngine.Jit.Native.Asmjit.CBPass pass)
            {
                var __arg0 = ReferenceEquals(pass, null) ? global::System.IntPtr.Zero : pass.__Instance;
                var __ret = __Internal.DeletePass((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            public virtual uint Serialize(global::GraphEngine.Jit.Native.Asmjit.CodeEmitter dst)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 15 * 8);
                var ___SerializeDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
                var __ret = ___SerializeDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Get the first node.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode FirstNode
            {
                get
                {
                    var __ret = __Internal.GetFirstNode((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get the last node.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode LastNode
            {
                get
                {
                    var __ret = __Internal.GetLastNode((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get current node.</summary>
            /// <remarks>
            /// <para>If this method returns null it means that nothing has been</para>
            /// <para>emitted yet.</para>
            /// </remarks>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode Cursor
            {
                get
                {
                    var __ret = __Internal.GetCursor((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~CodeBuilder() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error onAttach(CodeHolder* code) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnAttachDelegateInstance;

            private static uint _OnAttachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnAttach(__result0);
                return __ret;
            }

            // Error onDetach(CodeHolder* code) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnDetachDelegateInstance;

            private static uint _OnDetachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnDetach(__result0);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3, const Operand_& o4, const Operand_& o5) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _EmitDelegateInstance;

            private static uint _EmitDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, global::System.IntPtr o5)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result5;
                if (o4 == IntPtr.Zero) __result5 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o4))
                    __result5 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o4];
                else __result5 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o4);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result6;
                if (o5 == IntPtr.Zero) __result6 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o5))
                    __result6 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o5];
                else __result6 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o5);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4, __result5, __result6);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr _Emit_1DelegateInstance;

            private static uint _Emit_1DelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4);
                return __ret;
            }

            // Error _emitOpArray(uint32_t instId, const Operand_* opArray, size_t opCount)
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_ulong _EmitOpArrayDelegateInstance;

            private static uint _EmitOpArrayDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr opArray, ulong opCount)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (opArray == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(opArray))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[opArray];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(opArray);
                var __ret = __target.EmitOpArray(instId, __result1, opCount);
                return __ret;
            }

            // Label newLabel() override
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr _NewLabelDelegateInstance;

            private static void _NewLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewLabel();
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Label newNamedLabel(const char* name, size_t nameLength = Globals::kInvalidIndex, uint32_t type = Label::kTypeGlobal, uint32_t parentId = kInvalidValue) override
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint _NewNamedLabelDelegateInstance;

            private static void _NewNamedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string name, ulong nameLength, uint type, uint parentId)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewNamedLabel(name, nameLength, type, parentId);
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Error bind(const Label& label) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _BindDelegateInstance;

            private static uint _BindDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.Bind(__result0);
                return __ret;
            }

            // Error align(uint32_t mode, uint32_t alignment) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint _AlignDelegateInstance;

            private static uint _AlignDelegateHook(global::System.IntPtr instance, uint mode, uint alignment)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Align(mode, alignment);
                return __ret;
            }

            // Error embed(const void* data, uint32_t size) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint _EmbedDelegateInstance;

            private static uint _EmbedDelegateHook(global::System.IntPtr instance, global::System.IntPtr data, uint size)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Embed(data, size);
                return __ret;
            }

            // Error embedLabel(const Label& label) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _EmbedLabelDelegateInstance;

            private static uint _EmbedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.EmbedLabel(__result0);
                return __ret;
            }

            // Error embedConstPool(const Label& label, const ConstPool& pool) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr _EmbedConstPoolDelegateInstance;

            private static uint _EmbedConstPoolDelegateHook(global::System.IntPtr instance, global::System.IntPtr label, global::System.IntPtr pool)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                global::GraphEngine.Jit.Native.Asmjit.ConstPool __result1;
                if (pool == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap.ContainsKey(pool))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.ConstPool) global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap[pool];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.ConstPool.__CreateInstance(pool);
                var __ret = __target.EmbedConstPool(__result0, __result1);
                return __ret;
            }

            // Error comment(const char* s, size_t len = Globals::kInvalidIndex) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong _CommentDelegateInstance;

            private static uint _CommentDelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s, ulong len)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Comment(s, len);
                return __ret;
            }

            // Error finalize()
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr _FinalizeDelegateInstance;

            private static uint _FinalizeDelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Finalize();
                return __ret;
            }

            // Error serialize(CodeEmitter* dst)
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _SerializeDelegateInstance;

            private static uint _SerializeDelegateHook(global::System.IntPtr instance, global::System.IntPtr dst)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __result0;
                if (dst == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.NativeToManagedMap.ContainsKey(dst))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.NativeToManagedMap[dst];
                else __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__CreateInstance(dst, skipVTables: true);
                var __ret = __target.Serialize(__result0);
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[16];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _OnAttachDelegateInstance += _OnAttachDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnAttachDelegateInstance).ToPointer();
                    _OnDetachDelegateInstance += _OnDetachDelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnDetachDelegateInstance).ToPointer();
                    _EmitDelegateInstance += _EmitDelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EmitDelegateInstance).ToPointer();
                    _Emit_1DelegateInstance += _Emit_1DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Emit_1DelegateInstance).ToPointer();
                    _EmitOpArrayDelegateInstance += _EmitOpArrayDelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_EmitOpArrayDelegateInstance).ToPointer();
                    _NewLabelDelegateInstance += _NewLabelDelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewLabelDelegateInstance).ToPointer();
                    _NewNamedLabelDelegateInstance += _NewNamedLabelDelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewNamedLabelDelegateInstance).ToPointer();
                    _BindDelegateInstance += _BindDelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_BindDelegateInstance).ToPointer();
                    _AlignDelegateInstance += _AlignDelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_AlignDelegateInstance).ToPointer();
                    _EmbedDelegateInstance += _EmbedDelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_EmbedDelegateInstance).ToPointer();
                    _EmbedLabelDelegateInstance += _EmbedLabelDelegateHook;
                    _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_EmbedLabelDelegateInstance).ToPointer();
                    _EmbedConstPoolDelegateInstance += _EmbedConstPoolDelegateHook;
                    _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_EmbedConstPoolDelegateInstance).ToPointer();
                    _CommentDelegateInstance += _CommentDelegateHook;
                    _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_CommentDelegateInstance).ToPointer();
                    _FinalizeDelegateInstance += _FinalizeDelegateHook;
                    _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_FinalizeDelegateInstance).ToPointer();
                    _SerializeDelegateInstance += _SerializeDelegateHook;
                    _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_SerializeDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(16 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                        *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                        *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                        *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                        *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                        *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                        *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                        *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                        *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                        *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                        *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                        *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                        *(void**) (vfptr0 + 104) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 104);
                        *(void**) (vfptr0 + 112) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 112);
                        *(void**) (vfptr0 + 120) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 120);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(16 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                        *(void**) (vfptr0 + 16) = _Thunks[2];
                        *(void**) (vfptr0 + 24) = _Thunks[3];
                        *(void**) (vfptr0 + 32) = _Thunks[4];
                        *(void**) (vfptr0 + 40) = _Thunks[5];
                        *(void**) (vfptr0 + 48) = _Thunks[6];
                        *(void**) (vfptr0 + 56) = _Thunks[7];
                        *(void**) (vfptr0 + 64) = _Thunks[8];
                        *(void**) (vfptr0 + 72) = _Thunks[9];
                        *(void**) (vfptr0 + 80) = _Thunks[10];
                        *(void**) (vfptr0 + 88) = _Thunks[11];
                        *(void**) (vfptr0 + 96) = _Thunks[12];
                        *(void**) (vfptr0 + 104) = _Thunks[13];
                        *(void**) (vfptr0 + 112) = _Thunks[14];
                        *(void**) (vfptr0 + 120) = _Thunks[15];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        /// <summary>`CodeBuilder` pass used to  code transformations, analysis, and lowering.</summary>
        public unsafe abstract partial class CBPass : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_CBPass;

                [FieldOffset(8)]
                internal global::System.IntPtr _cb;

                [FieldOffset(16)]
                internal global::System.IntPtr _name;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBPass@asmjit@@QEAA@PEBD@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBPass@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?cb@CBPass@asmjit@@QEBAPEBVCodeBuilder@2@XZ")]
                internal static extern global::System.IntPtr Cb(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getName@CBPass@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetName(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CBPass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CBPass>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.CBPass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBPassInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBPass __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBPass.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBPassInternal(native, skipVTables);
            }

            protected CBPass(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            protected CBPass(string name)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBPass.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), name);
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.CBPass");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBPass __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.CBPass.__Internal*) __Instance)->vfptr_CBPass = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Process the code stored in CodeBuffer `cb`.</summary>
            /// <remarks>
            /// <para>This is the only function that is called by the `CodeBuilder` to process</para>
            /// <para>the code. It passes the CodeBuilder itself (`cb`) and also a zone memory</para>
            /// <para>allocator `zone`, which will be reset after the `process()` returns. The</para>
            /// <para>allocator should be used for all allocations as it's fast and everything</para>
            /// <para>it allocates will be released at once when `process()` returns.</para>
            /// </remarks>
            public abstract uint Process(global::GraphEngine.Jit.Native.Asmjit.Zone zone);

            public global::GraphEngine.Jit.Native.Asmjit.CodeBuilder Cb
            {
                get
                {
                    var __ret = __Internal.Cb((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CodeBuilder __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.NativeToManagedMap[__ret];
                    else global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.NativeToManagedMap[__ret] = __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeBuilder) global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public string Name
            {
                get
                {
                    var __ret = __Internal.GetName((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~CBPass() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CBPass) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error process(Zone* zone) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _ProcessDelegateInstance;

            private static uint _ProcessDelegateHook(global::System.IntPtr instance, global::System.IntPtr zone)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CBPass) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Zone __result0;
                if (zone == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Zone.NativeToManagedMap.ContainsKey(zone))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Zone) global::GraphEngine.Jit.Native.Asmjit.Zone.NativeToManagedMap[zone];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Zone.__CreateInstance(zone);
                var __ret = __target.Process(__result0);
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _ProcessDelegateInstance += _ProcessDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_ProcessDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        /// <summary>Node (CodeBuilder).</summary>
        /// <remarks>
        /// <para>Every node represents a building-block used by</para>
        /// <para>instruction, data, label, comment, directive, or any other high-level</para>
        /// <para>representation that can be transformed to the building blocks mentioned.</para>
        /// <para>Every class that inherits</para>
        /// <para>can lower to basic nodes.</para>
        /// </remarks>
        public unsafe partial class CBNode : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBNode@asmjit@@QEAA@PEAVCodeBuilder@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, uint type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBNode@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasFlag@CBNode@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasFlag(global::System.IntPtr instance, uint flag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?orFlags@CBNode@asmjit@@QEAAXI@Z")]
                internal static extern void OrFlags(global::System.IntPtr instance, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andFlags@CBNode@asmjit@@QEAAXI@Z")]
                internal static extern void AndFlags(global::System.IntPtr instance, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNotFlags@CBNode@asmjit@@QEAAXI@Z")]
                internal static extern void AndNotFlags(global::System.IntPtr instance, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetInlineComment@CBNode@asmjit@@QEAAXXZ")]
                internal static extern void ResetInlineComment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetPassData@CBNode@asmjit@@QEAAXXZ")]
                internal static extern void ResetPassData(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFlags@CBNode@asmjit@@QEBAIXZ")]
                internal static extern uint GetFlags(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setFlags@CBNode@asmjit@@QEAAXI@Z")]
                internal static extern void SetFlags(global::System.IntPtr instance, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPosition@CBNode@asmjit@@QEBAIXZ")]
                internal static extern uint GetPosition(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setPosition@CBNode@asmjit@@QEAAXI@Z")]
                internal static extern void SetPosition(global::System.IntPtr instance, uint position);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInlineComment@CBNode@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetInlineComment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setInlineComment@CBNode@asmjit@@QEAAXPEBD@Z")]
                internal static extern void SetInlineComment(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPrev@CBNode@asmjit@@QEBAPEAV12@XZ")]
                internal static extern global::System.IntPtr GetPrev(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getNext@CBNode@asmjit@@QEBAPEAV12@XZ")]
                internal static extern global::System.IntPtr GetNext(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getType@CBNode@asmjit@@QEBAIXZ")]
                internal static extern uint GetType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isTranslated@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsTranslated(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRemovable@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRemovable(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isInformative@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsInformative(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isLabel@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLabel(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isJmp@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsJmp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isJcc@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsJcc(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isJmpOrJcc@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsJmpOrJcc(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRet@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRet(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isSpecial@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSpecial(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isFp@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasPosition@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasPosition(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasInlineComment@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasInlineComment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasPassData@CBNode@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasPassData(global::System.IntPtr instance);
            }

            /// <summary>Type of</summary>
            public enum NodeType : uint
            {
                /// <summary>Invalid node (internal, don't use).</summary>
                kNodeNone = 0,
                /// <summary>Node is</summary>
                kNodeInst = 1,
                /// <summary>Node is</summary>
                kNodeData = 2,
                /// <summary>Node is</summary>
                kNodeAlign = 3,
                /// <summary>Node is</summary>
                kNodeLabel = 4,
                /// <summary>Node is</summary>
                kNodeLabelData = 5,
                /// <summary>Node is</summary>
                kNodeConstPool = 6,
                /// <summary>Node is</summary>
                kNodeComment = 7,
                /// <summary>Node is</summary>
                kNodeSentinel = 8,
                /// <summary>Node is</summary>
                kNodeFunc = 16,
                /// <summary>Node is</summary>
                kNodeFuncExit = 17,
                /// <summary>Node is</summary>
                kNodeFuncCall = 18,
                /// <summary>Node is</summary>
                kNodePushArg = 19,
                /// <summary>Node is</summary>
                kNodeHint = 20,
                /// <summary>First id of a user-defined node.</summary>
                kNodeUser = 32
            }

            [Flags]
            public enum Flags : uint
            {
                /// <summary>The node has been translated by the CodeCompiler.</summary>
                kFlagIsTranslated = 0x1,
                /// <summary>If the node can be safely removed (has no effect).</summary>
                kFlagIsRemovable = 0x4,
                /// <summary>If the node is informative only and can be safely removed.</summary>
                kFlagIsInformative = 0x8,
                /// <summary>If the `CBInst` is a jump.</summary>
                kFlagIsJmp = 0x10,
                /// <summary>If the `CBInst` is a conditional jump.</summary>
                kFlagIsJcc = 0x20,
                /// <summary>
                /// <para>If the `CBInst` is an unconditional jump or conditional jump that is</para>
                /// <para>likely to be taken.</para>
                /// </summary>
                kFlagIsTaken = 0x40,
                /// <summary>If the `CBNode` will return from a function.</summary>
                /// <remarks>This flag is used by both `CBSentinel` and `CCFuncRet`.</remarks>
                kFlagIsRet = 0x80,
                /// <summary>Whether the instruction is special.</summary>
                kFlagIsSpecial = 0x100,
                /// <summary>Whether the instruction is an FPU instruction.</summary>
                kFlagIsFp = 0x200
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CBNode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.CBNode>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.CBNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBNode(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBNode __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBNode.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBNode(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBNode.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBNode.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBNode.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBNode(global::GraphEngine.Jit.Native.Asmjit.CBNode.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBNode(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new</summary>
            public CBNode(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, uint type)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBNode.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, type);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get whether the instruction has flag `flag`.</summary>
            public bool HasFlag(uint flag)
            {
                var __ret = __Internal.HasFlag((__Instance + __PointerAdjustment), flag);
                return __ret;
            }

            /// <summary>Add instruction `flags`.</summary>
            public void OrFlags(uint flags)
            {
                __Internal.OrFlags((__Instance + __PointerAdjustment), flags);
            }

            /// <summary>And instruction `flags`.</summary>
            public void AndFlags(uint flags)
            {
                __Internal.AndFlags((__Instance + __PointerAdjustment), flags);
            }

            /// <summary>Clear instruction `flags`.</summary>
            public void AndNotFlags(uint flags)
            {
                __Internal.AndNotFlags((__Instance + __PointerAdjustment), flags);
            }

            /// <summary>Set an inline comment string to null.</summary>
            public void ResetInlineComment()
            {
                __Internal.ResetInlineComment((__Instance + __PointerAdjustment));
            }

            /// <summary>Reset work-data to null.</summary>
            public void ResetPassData()
            {
                __Internal.ResetPassData((__Instance + __PointerAdjustment));
            }

            /// <summary>Get the node flags.</summary>
            /// <remarks>Set node flags to `flags`.</remarks>
            public uint flags
            {
                get
                {
                    var __ret = __Internal.GetFlags((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetFlags((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get flow index.</summary>
            /// <remarks>Set flow index.</remarks>
            public uint Position
            {
                get
                {
                    var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetPosition((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get an inline comment string.</summary>
            /// <remarks>Set an inline comment string to `s`.</remarks>
            public string InlineComment
            {
                get
                {
                    var __ret = __Internal.GetInlineComment((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }

                set
                {
                    __Internal.SetInlineComment((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get previous node in the compiler stream.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode Prev
            {
                get
                {
                    var __ret = __Internal.GetPrev((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get next node in the compiler stream.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBNode Next
            {
                get
                {
                    var __ret = __Internal.GetNext((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBNode __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBNode) global::GraphEngine.Jit.Native.Asmjit.CBNode.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBNode.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get the node type, see</summary>
            public uint Type
            {
                get
                {
                    var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the node has been translated.</summary>
            public bool IsTranslated
            {
                get
                {
                    var __ret = __Internal.IsTranslated((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the node is removable if it's in unreachable code block.</summary>
            public bool IsRemovable
            {
                get
                {
                    var __ret = __Internal.IsRemovable((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the node is informative only (comment, hint).</summary>
            public bool IsInformative
            {
                get
                {
                    var __ret = __Internal.IsInformative((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Whether the node is `CBLabel`.</summary>
            public bool IsLabel
            {
                get
                {
                    var __ret = __Internal.IsLabel((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Whether the `CBInst` node is an unconditional jump.</summary>
            public bool IsJmp
            {
                get
                {
                    var __ret = __Internal.IsJmp((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Whether the `CBInst` node is a conditional jump.</summary>
            public bool IsJcc
            {
                get
                {
                    var __ret = __Internal.IsJcc((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Whether the `CBInst` node is a conditional/unconditional jump.</summary>
            public bool IsJmpOrJcc
            {
                get
                {
                    var __ret = __Internal.IsJmpOrJcc((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Whether the `CBInst` node is a return.</summary>
            public bool IsRet
            {
                get
                {
                    var __ret = __Internal.IsRet((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the node is `CBInst` and the instruction is special.</summary>
            public bool IsSpecial
            {
                get
                {
                    var __ret = __Internal.IsSpecial((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the node is `CBInst` and the instruction uses x87-FPU.</summary>
            public bool IsFp
            {
                get
                {
                    var __ret = __Internal.IsFp((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool HasPosition
            {
                get
                {
                    var __ret = __Internal.HasPosition((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the node has an inline comment.</summary>
            public bool HasInlineComment
            {
                get
                {
                    var __ret = __Internal.HasInlineComment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the node has associated work-data.</summary>
            public bool HasPassData
            {
                get
                {
                    var __ret = __Internal.HasPassData((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Instruction (CodeBuilder).</summary>
        /// <remarks>Wraps an instruction with its options and operands.</remarks>
        public unsafe partial class CBInst : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 72)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal _instDetail;

                [FieldOffset(56)]
                internal byte _memOpIndex;

                [FieldOffset(57)]
                internal fixed byte _reserved[7];

                [FieldOffset(64)]
                internal global::System.IntPtr _opArray;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBInst@asmjit@@QEAA@PEAVCodeBuilder@1@IIPEAVOperand@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, uint instId, uint options, global::System.IntPtr opArray, uint opCount);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBInst@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addOptions@CBInst@asmjit@@QEAAXI@Z")]
                internal static extern void AddOptions(global::System.IntPtr instance, uint options);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andOptions@CBInst@asmjit@@QEAAXI@Z")]
                internal static extern void AndOptions(global::System.IntPtr instance, uint options);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?delOptions@CBInst@asmjit@@QEAAXI@Z")]
                internal static extern void DelOptions(global::System.IntPtr instance, uint options);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setExtraReg@CBInst@asmjit@@QEAAXAEBVReg@2@@Z")]
                internal static extern void SetExtraReg(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetExtraReg@CBInst@asmjit@@QEAAXXZ")]
                internal static extern void ResetExtraReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setMemOpIndex@CBInst@asmjit@@QEAAXI@Z")]
                internal static extern void SetMemOpIndex(global::System.IntPtr instance, uint index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetMemOpIndex@CBInst@asmjit@@QEAAXXZ")]
                internal static extern void ResetMemOpIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_updateMemOp@CBInst@asmjit@@QEAAXXZ")]
                internal static extern void UpdateMemOp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInstId@CBInst@asmjit@@QEBAIXZ")]
                internal static extern uint GetInstId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setInstId@CBInst@asmjit@@QEAAXI@Z")]
                internal static extern void SetInstId(global::System.IntPtr instance, uint instId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOptions@CBInst@asmjit@@QEBAIXZ")]
                internal static extern uint GetOptions(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setOptions@CBInst@asmjit@@QEAAXI@Z")]
                internal static extern void SetOptions(global::System.IntPtr instance, uint options);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getExtraReg@CBInst@asmjit@@QEAAAEAURegOnly@2@XZ")]
                internal static extern global::System.IntPtr GetExtraReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setExtraReg@CBInst@asmjit@@QEAAXAEBURegOnly@2@@Z")]
                internal static extern void SetExtraReg_1(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInstDetail@CBInst@asmjit@@QEAAAEAVDetail@Inst@2@XZ")]
                internal static extern global::System.IntPtr GetInstDetail(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isTaken@CBInst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsTaken(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasExtraReg@CBInst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasExtraReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOpCount@CBInst@asmjit@@QEBAIXZ")]
                internal static extern uint GetOpCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOpArray@CBInst@asmjit@@QEAAPEAVOperand@2@XZ")]
                internal static extern global::System.IntPtr GetOpArray(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasMemOp@CBInst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasMemOp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getMemOp@CBInst@asmjit@@QEBAPEAVMem@2@XZ")]
                internal static extern global::System.IntPtr GetMemOp(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBInst __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBInst(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBInst __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBInst.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBInst(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBInst.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBInst.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBInst.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBInst(global::GraphEngine.Jit.Native.Asmjit.CBInst.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBInst(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CBInst` instance.</summary>
            public CBInst(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, uint instId, uint options, global::GraphEngine.Jit.Native.Asmjit.Operand opArray, uint opCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBInst.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                var __arg3 = ReferenceEquals(opArray, null) ? global::System.IntPtr.Zero : opArray.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, instId, options, __arg3, opCount);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Add emit options.</summary>
            public void AddOptions(uint options)
            {
                __Internal.AddOptions((__Instance + __PointerAdjustment), options);
            }

            /// <summary>Mask emit options.</summary>
            public void AndOptions(uint options)
            {
                __Internal.AndOptions((__Instance + __PointerAdjustment), options);
            }

            /// <summary>Clear emit options.</summary>
            public void DelOptions(uint options)
            {
                __Internal.DelOptions((__Instance + __PointerAdjustment), options);
            }

            /// <summary>Set extra register operand to `reg`.</summary>
            public void SetExtraReg(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                __Internal.SetExtraReg((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Reset extra register operand.</summary>
            public void ResetExtraReg()
            {
                __Internal.ResetExtraReg((__Instance + __PointerAdjustment));
            }

            /// <summary>Set memory operand index, `0xFF` means no memory operand.</summary>
            public void SetMemOpIndex(uint index)
            {
                __Internal.SetMemOpIndex((__Instance + __PointerAdjustment), index);
            }

            /// <summary>Reset memory operand index to `0xFF` (no operand).</summary>
            public void ResetMemOpIndex()
            {
                __Internal.ResetMemOpIndex((__Instance + __PointerAdjustment));
            }

            public void UpdateMemOp()
            {
                __Internal.UpdateMemOp((__Instance + __PointerAdjustment));
            }

            /// <summary>Get the instruction id, see</summary>
            /// <remarks>Set the instruction id to `instId`, see</remarks>
            public uint InstId
            {
                get
                {
                    var __ret = __Internal.GetInstId((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetInstId((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get emit options.</summary>
            /// <remarks>Set emit options.</remarks>
            public uint Options
            {
                get
                {
                    var __ret = __Internal.GetOptions((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetOptions((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get extra register operand.</summary>
            /// <remarks>Set extra register operand to `reg`.</remarks>
            public global::GraphEngine.Jit.Native.Asmjit.RegOnly ExtraReg
            {
                get
                {
                    var __ret = __Internal.GetExtraReg((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.RegOnly __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.RegOnly.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.RegOnly) global::GraphEngine.Jit.Native.Asmjit.RegOnly.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.RegOnly.__CreateInstance(__ret);
                    return __result0;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetExtraReg_1((__Instance + __PointerAdjustment), __arg0);
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.Inst.Detail InstDetail
            {
                get
                {
                    var __ret = __Internal.GetInstDetail((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.Inst.Detail __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.Inst.Detail) global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Whether the instruction is either a jump or a conditional jump likely to be taken.</summary>
            public bool IsTaken
            {
                get
                {
                    var __ret = __Internal.IsTaken((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the node has an extra register operand.</summary>
            public bool HasExtraReg
            {
                get
                {
                    var __ret = __Internal.HasExtraReg((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get operands count.</summary>
            public uint OpCount
            {
                get
                {
                    var __ret = __Internal.GetOpCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get operands list.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Operand OpArray
            {
                get
                {
                    var __ret = __Internal.GetOpArray((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.Operand __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.Operand) global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.Operand.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get whether the instruction contains a memory operand.</summary>
            public bool HasMemOp
            {
                get
                {
                    var __ret = __Internal.HasMemOp((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get memory operand.</summary>
            /// <remarks>
            /// <para>NOTE: Can only be called if the instruction has such operand,</para>
            /// <para>see `hasMemOp()`.</para>
            /// </remarks>
            public global::GraphEngine.Jit.Native.Asmjit.Mem MemOp
            {
                get
                {
                    var __ret = __Internal.GetMemOp((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.Mem __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.Mem.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.Mem) global::GraphEngine.Jit.Native.Asmjit.Mem.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.Mem.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        public unsafe partial class CBInstEx : global::GraphEngine.Jit.Native.Asmjit.CBInst, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 104)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal _instDetail;

                [FieldOffset(56)]
                internal byte _memOpIndex;

                [FieldOffset(57)]
                internal fixed byte _reserved[7];

                [FieldOffset(64)]
                internal global::System.IntPtr _opArray;

                [FieldOffset(72)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal _op4;

                [FieldOffset(88)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand.__Internal _op5;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBInstEx@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBInstEx@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBInstEx@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBInstEx __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBInstEx(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBInstEx __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBInstEx.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBInstEx(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBInstEx.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBInstEx.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.CBInstEx.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private CBInstEx(global::GraphEngine.Jit.Native.Asmjit.CBInstEx.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBInstEx(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CBInstEx()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBInstEx.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Asm jump (conditional or direct).</summary>
        /// <remarks>Extension of `CBInst` node, which stores more information about the jump.</remarks>
        public unsafe partial class CBJump : global::GraphEngine.Jit.Native.Asmjit.CBInst, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 88)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal _instDetail;

                [FieldOffset(56)]
                internal byte _memOpIndex;

                [FieldOffset(57)]
                internal fixed byte _reserved[7];

                [FieldOffset(64)]
                internal global::System.IntPtr _opArray;

                [FieldOffset(72)]
                internal global::System.IntPtr _target;

                [FieldOffset(80)]
                internal global::System.IntPtr _jumpNext;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBJump@asmjit@@QEAA@PEAVCodeBuilder@1@IIPEAVOperand@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, uint instId, uint options, global::System.IntPtr opArray, uint opCount);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBJump@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getTarget@CBJump@asmjit@@QEBAPEAVCBLabel@2@XZ")]
                internal static extern global::System.IntPtr GetTarget(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getJumpNext@CBJump@asmjit@@QEBAPEAV12@XZ")]
                internal static extern global::System.IntPtr GetJumpNext(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBJump __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBJump(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBJump __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBJump.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBJump(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBJump.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBJump.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBJump.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBJump(global::GraphEngine.Jit.Native.Asmjit.CBJump.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBJump(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CBJump(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, uint instId, uint options, global::GraphEngine.Jit.Native.Asmjit.Operand opArray, uint opCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBJump.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                var __arg3 = ReferenceEquals(opArray, null) ? global::System.IntPtr.Zero : opArray.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, instId, options, __arg3, opCount);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::GraphEngine.Jit.Native.Asmjit.CBLabel Target
            {
                get
                {
                    var __ret = __Internal.GetTarget((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBLabel __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBLabel.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBLabel) global::GraphEngine.Jit.Native.Asmjit.CBLabel.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBLabel.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.CBJump JumpNext
            {
                get
                {
                    var __ret = __Internal.GetJumpNext((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBJump __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBJump.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBJump) global::GraphEngine.Jit.Native.Asmjit.CBJump.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBJump.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        /// <summary>Asm data (CodeBuilder).</summary>
        /// <remarks>
        /// <para>Wraps `.data` directive. The node contains data that will be placed at the</para>
        /// <para>node's position in the assembler stream. The data is considered to be RAW;</para>
        /// <para>no analysis nor byte-order conversion is performed on RAW data.</para>
        /// </remarks>
        public unsafe partial class CBData : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal global::GraphEngine.Jit.Native.Asmjit.CBData._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBData@asmjit@@QEAA@PEAVCodeBuilder@1@PEAXI@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, global::System.IntPtr data, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBData@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSize@CBData@asmjit@@QEBAIXZ")]
                internal static extern uint GetSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getData@CBData@asmjit@@QEBAPEAEXZ")]
                internal static extern byte* GetData(global::System.IntPtr instance);
            }

            public enum KInlineBufferSize
            {
                kInlineBufferSize = 20
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.CBData._.__.__Internal __;

                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.CBData._.__.__Internal __1;
                }

                public unsafe partial class __
                {
                    [StructLayout(LayoutKind.Explicit, Size = 24)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal fixed byte _buf[20];

                        [FieldOffset(20)]
                        internal uint _size;
                    }
                }
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBData(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBData.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBData(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBData.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBData.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBData.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBData(global::GraphEngine.Jit.Native.Asmjit.CBData.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBData(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CBData` instance.</summary>
            public CBData(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, global::System.IntPtr data, uint size)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, data, size);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get size of the data.</summary>
            public uint Size
            {
                get
                {
                    var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get pointer to the data.</summary>
            public byte* Data
            {
                get
                {
                    var __ret = __Internal.GetData((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Align directive (CodeBuilder).</summary>
        /// <remarks>Wraps `.align` directive.</remarks>
        public unsafe partial class CBAlign : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal uint _mode;

                [FieldOffset(44)]
                internal uint _alignment;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBAlign@asmjit@@QEAA@PEAVCodeBuilder@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, uint mode, uint alignment);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBAlign@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getMode@CBAlign@asmjit@@QEBAIXZ")]
                internal static extern uint GetMode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setMode@CBAlign@asmjit@@QEAAXI@Z")]
                internal static extern void SetMode(global::System.IntPtr instance, uint mode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAlignment@CBAlign@asmjit@@QEBAIXZ")]
                internal static extern uint GetAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setAlignment@CBAlign@asmjit@@QEAAXI@Z")]
                internal static extern void SetAlignment(global::System.IntPtr instance, uint alignment);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBAlign __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBAlign(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBAlign __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBAlign.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBAlign(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBAlign.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBAlign.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBAlign.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBAlign(global::GraphEngine.Jit.Native.Asmjit.CBAlign.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBAlign(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CBAlign` instance.</summary>
            public CBAlign(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, uint mode, uint alignment)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBAlign.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, mode, alignment);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get align mode.</summary>
            /// <remarks>Set align mode.</remarks>
            public uint Mode
            {
                get
                {
                    var __ret = __Internal.GetMode((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetMode((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get align offset in bytes.</summary>
            /// <remarks>Set align offset in bytes to `offset`.</remarks>
            public uint Alignment
            {
                get
                {
                    var __ret = __Internal.GetAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetAlignment((__Instance + __PointerAdjustment), value);
                }
            }
        }

        /// <summary>Label (CodeBuilder).</summary>
        public unsafe partial class CBLabel : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal uint _id;

                [FieldOffset(44)]
                internal uint _numRefs;

                [FieldOffset(48)]
                internal global::System.IntPtr _from;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBLabel@asmjit@@QEAA@PEAVCodeBuilder@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBLabel@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addNumRefs@CBLabel@asmjit@@QEAAXI@Z")]
                internal static extern void AddNumRefs(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?subNumRefs@CBLabel@asmjit@@QEAAXI@Z")]
                internal static extern void SubNumRefs(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getNumRefs@CBLabel@asmjit@@QEBAIXZ")]
                internal static extern uint GetNumRefs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setNumRefs@CBLabel@asmjit@@QEAAXI@Z")]
                internal static extern void SetNumRefs(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getId@CBLabel@asmjit@@QEBAIXZ")]
                internal static extern uint GetId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLabel@CBLabel@asmjit@@QEBA?AVLabel@2@XZ")]
                internal static extern void GetLabel(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFrom@CBLabel@asmjit@@QEBAPEAVCBJump@2@XZ")]
                internal static extern global::System.IntPtr GetFrom(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBLabel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBLabel(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBLabel __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBLabel.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBLabel(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBLabel.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBLabel.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBLabel.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBLabel(global::GraphEngine.Jit.Native.Asmjit.CBLabel.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBLabel(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CBLabel` instance.</summary>
            public CBLabel(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, uint id)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBLabel.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, id);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Add number of jumps to this target.</summary>
            public void AddNumRefs(uint i)
            {
                __Internal.AddNumRefs((__Instance + __PointerAdjustment), i);
            }

            /// <summary>Subtract number of jumps to this target.</summary>
            public void SubNumRefs(uint i)
            {
                __Internal.SubNumRefs((__Instance + __PointerAdjustment), i);
            }

            /// <summary>Get number of jumps to this target.</summary>
            /// <remarks>Set number of jumps to this target.</remarks>
            public uint NumRefs
            {
                get
                {
                    var __ret = __Internal.GetNumRefs((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetNumRefs((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get the label id.</summary>
            public uint Id
            {
                get
                {
                    var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the label as `Label` operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Label Label
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                    __Internal.GetLabel((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
                }
            }

            /// <summary>Get first jmp instruction.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBJump From
            {
                get
                {
                    var __ret = __Internal.GetFrom((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBJump __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBJump.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBJump) global::GraphEngine.Jit.Native.Asmjit.CBJump.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBJump.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        public unsafe partial class CBLabelData : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal uint _id;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBLabelData@asmjit@@QEAA@PEAVCodeBuilder@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBLabelData@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getId@CBLabelData@asmjit@@QEBAIXZ")]
                internal static extern uint GetId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLabel@CBLabelData@asmjit@@QEBA?AVLabel@2@XZ")]
                internal static extern void GetLabel(global::System.IntPtr instance, global::System.IntPtr @return);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBLabelData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBLabelData(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBLabelData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBLabelData.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBLabelData(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBLabelData.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBLabelData.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBLabelData.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBLabelData(global::GraphEngine.Jit.Native.Asmjit.CBLabelData.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBLabelData(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CBLabelData` instance.</summary>
            public CBLabelData(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, uint id)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBLabelData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, id);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the label id.</summary>
            public uint Id
            {
                get
                {
                    var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the label as `Label` operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Label Label
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                    __Internal.GetLabel((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
                }
            }
        }

        public unsafe partial class CBConstPool : global::GraphEngine.Jit.Native.Asmjit.CBLabel, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 280)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal uint _id;

                [FieldOffset(44)]
                internal uint _numRefs;

                [FieldOffset(48)]
                internal global::System.IntPtr _from;

                [FieldOffset(56)]
                internal global::GraphEngine.Jit.Native.Asmjit.ConstPool.__Internal _constPool;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBConstPool@asmjit@@QEAA@PEAVCodeBuilder@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBConstPool@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?add@CBConstPool@asmjit@@QEAAIPEBX_KAEA_K@Z")]
                internal static extern uint Add(global::System.IntPtr instance, global::System.IntPtr data, ulong size, ulong* dstOffset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getConstPool@CBConstPool@asmjit@@QEAAAEAVConstPool@2@XZ")]
                internal static extern global::System.IntPtr GetConstPool(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isEmpty@CBConstPool@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEmpty(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSize@CBConstPool@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAlignment@CBConstPool@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetAlignment(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBConstPool __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBConstPool(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBConstPool __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBConstPool.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBConstPool(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBConstPool.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBConstPool.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBConstPool.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBConstPool(global::GraphEngine.Jit.Native.Asmjit.CBConstPool.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBConstPool(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CBConstPool` instance.</summary>
            public CBConstPool(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, uint id)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBConstPool.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, id);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>See</summary>
            public uint Add(global::System.IntPtr data, ulong size, ref ulong dstOffset)
            {
                fixed (ulong* __refParamPtr2 = &dstOffset)
                {
                    var __arg2 = __refParamPtr2;
                    var __ret = __Internal.Add((__Instance + __PointerAdjustment), data, size, __arg2);
                    return __ret;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.ConstPool ConstPool
            {
                get
                {
                    var __ret = __Internal.GetConstPool((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.ConstPool __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.ConstPool) global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.ConstPool.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get whether the constant-pool is empty.</summary>
            public bool IsEmpty
            {
                get
                {
                    var __ret = __Internal.IsEmpty((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the size of the constant-pool in bytes.</summary>
            public ulong Size
            {
                get
                {
                    var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get minimum alignment.</summary>
            public ulong Alignment
            {
                get
                {
                    var __ret = __Internal.GetAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Comment (CodeBuilder).</summary>
        public unsafe partial class CBComment : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBComment@asmjit@@QEAA@PEAVCodeBuilder@1@PEBD@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, [MarshalAs(UnmanagedType.LPStr)] string comment);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBComment@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBComment(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBComment __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBComment.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBComment(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBComment.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBComment.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBComment.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBComment(global::GraphEngine.Jit.Native.Asmjit.CBComment.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBComment(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CBComment` instance.</summary>
            public CBComment(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, string comment)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBComment.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, comment);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Sentinel (CodeBuilder).</summary>
        /// <remarks>
        /// <para>Sentinel is a marker that is completely ignored by the code builder. It's</para>
        /// <para>used to remember a position in a code as it never gets removed by any pass.</para>
        /// </remarks>
        public unsafe partial class CBSentinel : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CBSentinel@asmjit@@QEAA@PEAVCodeBuilder@1@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CBSentinel@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CBSentinel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBSentinel(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CBSentinel __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CBSentinel.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CBSentinel(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBSentinel.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBSentinel.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBSentinel.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CBSentinel(global::GraphEngine.Jit.Native.Asmjit.CBSentinel.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CBSentinel(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CBSentinel` instance.</summary>
            public CBSentinel(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBSentinel.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class CBPassInternal : global::GraphEngine.Jit.Native.Asmjit.CBPass, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CBPass.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CBPass.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CBPass.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CBPassInternal(global::GraphEngine.Jit.Native.Asmjit.CBPass.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal CBPassInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Process the code stored in CodeBuffer `cb`.</summary>
            /// <remarks>
            /// <para>This is the only function that is called by the `CodeBuilder` to process</para>
            /// <para>the code. It passes the CodeBuilder itself (`cb`) and also a zone memory</para>
            /// <para>allocator `zone`, which will be reset after the `process()` returns. The</para>
            /// <para>allocator should be used for all allocations as it's fast and everything</para>
            /// <para>it allocates will be released at once when `process()` returns.</para>
            /// </remarks>
            public override uint Process(global::GraphEngine.Jit.Native.Asmjit.Zone zone)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___ProcessDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(zone, null) ? global::System.IntPtr.Zero : zone.__Instance;
                var __ret = ___ProcessDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }
        }

        public unsafe partial class CodeBuilderInternal : global::GraphEngine.Jit.Native.Asmjit.CodeBuilder, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CodeBuilderInternal(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal CodeBuilderInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Emit instruction having max 6 operands.</summary>
            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, global::GraphEngine.Jit.Native.Asmjit.Operand_ o5)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___EmitDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                if (ReferenceEquals(o5, null))
                    throw new global::System.ArgumentNullException("o5", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = o5.__Instance;
                var __ret = ___EmitDelegate((__Instance), instId, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                return __ret;
            }

            /// <summary>Emit instruction having max 4 operands.</summary>
            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___Emit_1Delegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = ___Emit_1Delegate((__Instance), instId, __arg1, __arg2, __arg3, __arg4);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Scope of the constant.</summary>
        public enum ConstScope : uint
        {
            /// <summary>Local constant, always embedded right after the current function.</summary>
            kConstScopeLocal = 0,
            /// <summary>Global constant, embedded at the end of the currently compiled code.</summary>
            kConstScopeGlobal = 1
        }

        public unsafe partial class RACell
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RACell> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RACell>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.RACell __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RACell(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.RACell __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.RACell.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RACell(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.RACell.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RACell.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.RACell.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private RACell(global::GraphEngine.Jit.Native.Asmjit.RACell.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RACell(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }
        }

        public unsafe partial class TiedReg
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TiedReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.TiedReg>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.TiedReg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.TiedReg(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.TiedReg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.TiedReg.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.TiedReg(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.TiedReg.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.TiedReg.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.TiedReg.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TiedReg(global::GraphEngine.Jit.Native.Asmjit.TiedReg.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TiedReg(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }
        }

        public unsafe partial class RAState
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RAState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.RAState>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.RAState __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RAState(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.RAState __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.RAState.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RAState(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.RAState.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.RAState.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.RAState.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private RAState(global::GraphEngine.Jit.Native.Asmjit.RAState.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RAState(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }
        }

        /// <summary>Virtual register data (CodeCompiler).</summary>
        public unsafe partial class VirtReg : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint _id;

                [FieldOffset(4)]
                internal global::GraphEngine.Jit.Native.Asmjit.RegInfo.__Internal _regInfo;

                [FieldOffset(8)]
                internal global::System.IntPtr _name;

                [FieldOffset(16)]
                internal uint _size;

                [FieldOffset(20)]
                internal byte _typeId;

                [FieldOffset(21)]
                internal byte _alignment;

                [FieldOffset(22)]
                internal byte _priority;

                [FieldOffset(23)]
                internal byte _isFixed;

                [FieldOffset(23)]
                internal byte _isStack;

                [FieldOffset(23)]
                internal byte _isMaterialized;

                [FieldOffset(23)]
                internal byte _saveOnUnuse;

                [FieldOffset(24)]
                internal uint _raId;

                [FieldOffset(28)]
                internal int _memOffset;

                [FieldOffset(32)]
                internal uint _homeMask;

                [FieldOffset(36)]
                internal byte _state;

                [FieldOffset(37)]
                internal byte _physId;

                [FieldOffset(38)]
                internal byte _modified;

                [FieldOffset(40)]
                internal global::System.IntPtr _memCell;

                [FieldOffset(48)]
                internal global::System.IntPtr _tied;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0VirtReg@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetPhysId@VirtReg@asmjit@@QEAAXXZ")]
                internal static extern void ResetPhysId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addHomeId@VirtReg@asmjit@@QEAAXI@Z")]
                internal static extern void AddHomeId(global::System.IntPtr instance, uint physId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?saveOnUnuse@VirtReg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SaveOnUnuse(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPriority@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetPriority(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setPriority@VirtReg@asmjit@@QEAAXI@Z")]
                internal static extern void SetPriority(global::System.IntPtr instance, uint priority);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getState@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetState(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setState@VirtReg@asmjit@@QEAAXI@Z")]
                internal static extern void SetState(global::System.IntPtr instance, uint state);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPhysId@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetPhysId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setPhysId@VirtReg@asmjit@@QEAAXI@Z")]
                internal static extern void SetPhysId(global::System.IntPtr instance, uint physId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isModified@VirtReg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsModified(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setModified@VirtReg@asmjit@@QEAAX_N@Z")]
                internal static extern void SetModified(global::System.IntPtr instance, bool modified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getMemOffset@VirtReg@asmjit@@QEBAHXZ")]
                internal static extern int GetMemOffset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setMemOffset@VirtReg@asmjit@@QEAAXH@Z")]
                internal static extern void SetMemOffset(global::System.IntPtr instance, int offset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getMemCell@VirtReg@asmjit@@QEBAPEAURACell@2@XZ")]
                internal static extern global::System.IntPtr GetMemCell(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setMemCell@VirtReg@asmjit@@QEAAXPEAURACell@2@@Z")]
                internal static extern void SetMemCell(global::System.IntPtr instance, global::System.IntPtr cell);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getId@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getName@VirtReg@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetName(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getType@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getKind@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetKind(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRegSize@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetRegSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSignature@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetSignature(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getTypeId@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetTypeId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSize@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetSize(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAlignment@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetAlignment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getHomeMask@VirtReg@asmjit@@QEBAIXZ")]
                internal static extern uint GetHomeMask(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isFixed@VirtReg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFixed(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isStack@VirtReg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsStack(global::System.IntPtr instance);
            }

            /// <summary>A state of a virtual register (used during register allocation).</summary>
            public enum State : uint
            {
                /// <summary>Not allocated, not used.</summary>
                kStateNone = 0,
                /// <summary>Allocated in register.</summary>
                kStateReg = 1,
                /// <summary>Allocated in memory or spilled.</summary>
                kStateMem = 2
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VirtReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VirtReg>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.VirtReg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.VirtReg(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.VirtReg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.VirtReg.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.VirtReg(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.VirtReg.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VirtReg.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.VirtReg.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VirtReg(global::GraphEngine.Jit.Native.Asmjit.VirtReg.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VirtReg(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public VirtReg()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VirtReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public VirtReg(global::GraphEngine.Jit.Native.Asmjit.VirtReg _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VirtReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.VirtReg.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.VirtReg.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.VirtReg __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Reset register index.</summary>
            public void ResetPhysId()
            {
                __Internal.ResetPhysId((__Instance + __PointerAdjustment));
            }

            /// <summary>Add a home register index to the home registers mask.</summary>
            public void AddHomeId(uint physId)
            {
                __Internal.AddHomeId((__Instance + __PointerAdjustment), physId);
            }

            /// <summary>Get whether to save variable when it's unused (spill).</summary>
            public bool SaveOnUnuse()
            {
                var __ret = __Internal.SaveOnUnuse((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get the virtual-register  priority, used by compiler to decide which variable to spill.</summary>
            /// <remarks>Set the virtual-register  priority.</remarks>
            public uint Priority
            {
                get
                {
                    var __ret = __Internal.GetPriority((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetPriority((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get variable state, only used by `RAPass`.</summary>
            /// <remarks>Set variable state, only used by `RAPass`.</remarks>
            public uint state
            {
                get
                {
                    var __ret = __Internal.GetState((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetState((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get register index.</summary>
            /// <remarks>Set register index.</remarks>
            public uint PhysId
            {
                get
                {
                    var __ret = __Internal.GetPhysId((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetPhysId((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get whether the variable was changed.</summary>
            /// <remarks>Set whether the variable was changed.</remarks>
            public bool Modified
            {
                get
                {
                    var __ret = __Internal.IsModified((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetModified((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get home memory offset.</summary>
            /// <remarks>Set home memory offset.</remarks>
            public int MemOffset
            {
                get
                {
                    var __ret = __Internal.GetMemOffset((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetMemOffset((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get home memory cell.</summary>
            /// <remarks>Set home memory cell.</remarks>
            public global::GraphEngine.Jit.Native.Asmjit.RACell MemCell
            {
                get
                {
                    var __ret = __Internal.GetMemCell((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.RACell __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.RACell.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.RACell) global::GraphEngine.Jit.Native.Asmjit.RACell.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.RACell.__CreateInstance(__ret);
                    return __result0;
                }

                set
                {
                    var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    __Internal.SetMemCell((__Instance + __PointerAdjustment), __arg0);
                }
            }

            /// <summary>Get the virtual-register id.</summary>
            public uint Id
            {
                get
                {
                    var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get virtual-register's name.</summary>
            public string Name
            {
                get
                {
                    var __ret = __Internal.GetName((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            /// <summary>Get a physical register type.</summary>
            public uint Type
            {
                get
                {
                    var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a physical register kind.</summary>
            public uint Kind
            {
                get
                {
                    var __ret = __Internal.GetKind((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a physical register size.</summary>
            public uint RegSize
            {
                get
                {
                    var __ret = __Internal.GetRegSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a register signature of this virtual register.</summary>
            public uint Signature
            {
                get
                {
                    var __ret = __Internal.GetSignature((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get a register's type-id, see</summary>
            public uint TypeId
            {
                get
                {
                    var __ret = __Internal.GetTypeId((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get virtual-register's size.</summary>
            public uint Size
            {
                get
                {
                    var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get virtual-register's alignment.</summary>
            public uint Alignment
            {
                get
                {
                    var __ret = __Internal.GetAlignment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get home registers mask.</summary>
            public uint HomeMask
            {
                get
                {
                    var __ret = __Internal.GetHomeMask((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public bool IsFixed
            {
                get
                {
                    var __ret = __Internal.IsFixed((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get whether the VirtReg is only memory allocated on the stack.</summary>
            public bool IsStack
            {
                get
                {
                    var __ret = __Internal.IsStack((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Hint for register allocator (CodeCompiler).</summary>
        public unsafe partial class CCHint : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal global::System.IntPtr _vreg;

                [FieldOffset(48)]
                internal uint _hint;

                [FieldOffset(52)]
                internal uint _value;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CCHint@asmjit@@QEAA@PEAVCodeBuilder@1@PEAUVirtReg@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, global::System.IntPtr vreg, uint hint, uint value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CCHint@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getHint@CCHint@asmjit@@QEBAIXZ")]
                internal static extern uint GetHint(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setHint@CCHint@asmjit@@QEAAXI@Z")]
                internal static extern void SetHint(global::System.IntPtr instance, uint hint);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getValue@CCHint@asmjit@@QEBAIXZ")]
                internal static extern uint GetValue(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setValue@CCHint@asmjit@@QEAAXI@Z")]
                internal static extern void SetValue(global::System.IntPtr instance, uint value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVReg@CCHint@asmjit@@QEBAPEAUVirtReg@2@XZ")]
                internal static extern global::System.IntPtr GetVReg(global::System.IntPtr instance);
            }

            /// <summary>Hint type.</summary>
            public enum Hint : uint
            {
                /// <summary>Alloc to physical reg.</summary>
                kHintAlloc = 0,
                /// <summary>Spill to memory.</summary>
                kHintSpill = 1,
                /// <summary>Save if modified.</summary>
                kHintSave = 2,
                /// <summary>Save if modified and mark it as unused.</summary>
                kHintSaveAndUnuse = 3,
                /// <summary>Mark as unused.</summary>
                kHintUnuse = 4
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CCHint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCHint(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CCHint __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CCHint.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCHint(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CCHint.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCHint.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CCHint.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CCHint(global::GraphEngine.Jit.Native.Asmjit.CCHint.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CCHint(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CCHint` instance.</summary>
            public CCHint(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, global::GraphEngine.Jit.Native.Asmjit.VirtReg vreg, uint hint, uint value)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCHint.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                var __arg1 = ReferenceEquals(vreg, null) ? global::System.IntPtr.Zero : vreg.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, hint, value);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get hint it, see</summary>
            /// <remarks>Set hint it, see</remarks>
            public uint hint
            {
                get
                {
                    var __ret = __Internal.GetHint((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetHint((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get hint value.</summary>
            /// <remarks>Set hint value.</remarks>
            public uint Value
            {
                get
                {
                    var __ret = __Internal.GetValue((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetValue((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get variable.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.VirtReg VReg
            {
                get
                {
                    var __ret = __Internal.GetVReg((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.VirtReg __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.VirtReg) global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.VirtReg.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        /// <summary>Function entry (CodeCompiler).</summary>
        public unsafe partial class CCFunc : global::GraphEngine.Jit.Native.Asmjit.CBLabel, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 352)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal uint _id;

                [FieldOffset(44)]
                internal uint _numRefs;

                [FieldOffset(48)]
                internal global::System.IntPtr _from;

                [FieldOffset(56)]
                internal global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__Internal _funcDetail;

                [FieldOffset(288)]
                internal global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.__Internal _frameInfo;

                [FieldOffset(320)]
                internal global::System.IntPtr _exitNode;

                [FieldOffset(328)]
                internal global::System.IntPtr _end;

                [FieldOffset(336)]
                internal global::System.IntPtr _args;

                [FieldOffset(344)]
                internal byte _isFinished;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CCFunc@asmjit@@QEAA@PEAVCodeBuilder@1@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CCFunc@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArg@CCFunc@asmjit@@QEBAPEAUVirtReg@2@I@Z")]
                internal static extern global::System.IntPtr GetArg(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setArg@CCFunc@asmjit@@QEAAXIPEAUVirtReg@2@@Z")]
                internal static extern void SetArg(global::System.IntPtr instance, uint i, global::System.IntPtr vreg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetArg@CCFunc@asmjit@@QEAAXI@Z")]
                internal static extern void ResetArg(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addAttributes@CCFunc@asmjit@@QEAAXI@Z")]
                internal static extern void AddAttributes(global::System.IntPtr instance, uint attrs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getExitNode@CCFunc@asmjit@@QEBAPEAVCBLabel@2@XZ")]
                internal static extern global::System.IntPtr GetExitNode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getExitLabel@CCFunc@asmjit@@QEBA?AVLabel@2@XZ")]
                internal static extern void GetExitLabel(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getEnd@CCFunc@asmjit@@QEBAPEAVCBSentinel@2@XZ")]
                internal static extern global::System.IntPtr GetEnd(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getDetail@CCFunc@asmjit@@QEAAAEAVFuncDetail@2@XZ")]
                internal static extern global::System.IntPtr GetDetail(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFrameInfo@CCFunc@asmjit@@QEAAAEAUFuncFrameInfo@2@XZ")]
                internal static extern global::System.IntPtr GetFrameInfo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArgCount@CCFunc@asmjit@@QEBAIXZ")]
                internal static extern uint GetArgCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRetCount@CCFunc@asmjit@@QEBAIXZ")]
                internal static extern uint GetRetCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArgs@CCFunc@asmjit@@QEBAPEAPEAUVirtReg@2@XZ")]
                internal static extern global::System.IntPtr GetArgs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAttributes@CCFunc@asmjit@@QEBAIXZ")]
                internal static extern uint GetAttributes(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CCFunc __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCFunc(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CCFunc __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CCFunc.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCFunc(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CCFunc.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCFunc.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CCFunc.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CCFunc(global::GraphEngine.Jit.Native.Asmjit.CCFunc.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CCFunc(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CCFunc` instance.</summary>
            /// <remarks>Always use `CodeCompiler::addFunc()` to create</remarks>
            public CCFunc(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCFunc.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get argument at `i`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.VirtReg GetArg(uint i)
            {
                var __ret = __Internal.GetArg((__Instance + __PointerAdjustment), i);
                global::GraphEngine.Jit.Native.Asmjit.VirtReg __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.VirtReg) global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.VirtReg.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Set argument at `i`.</summary>
            public void SetArg(uint i, global::GraphEngine.Jit.Native.Asmjit.VirtReg vreg)
            {
                var __arg1 = ReferenceEquals(vreg, null) ? global::System.IntPtr.Zero : vreg.__Instance;
                __Internal.SetArg((__Instance + __PointerAdjustment), i, __arg1);
            }

            /// <summary>Reset argument at `i`.</summary>
            public void ResetArg(uint i)
            {
                __Internal.ResetArg((__Instance + __PointerAdjustment), i);
            }

            public void AddAttributes(uint attrs)
            {
                __Internal.AddAttributes((__Instance + __PointerAdjustment), attrs);
            }

            /// <summary>Get function exit `CBLabel`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBLabel ExitNode
            {
                get
                {
                    var __ret = __Internal.GetExitNode((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBLabel __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBLabel.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBLabel) global::GraphEngine.Jit.Native.Asmjit.CBLabel.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBLabel.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get function exit label.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Label ExitLabel
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                    __Internal.GetExitLabel((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
                }
            }

            /// <summary>Get &quot;End of Func&quot; sentinel.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBSentinel End
            {
                get
                {
                    var __ret = __Internal.GetEnd((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CBSentinel __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CBSentinel.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBSentinel) global::GraphEngine.Jit.Native.Asmjit.CBSentinel.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBSentinel.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get function declaration.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.FuncDetail Detail
            {
                get
                {
                    var __ret = __Internal.GetDetail((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.FuncDetail __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.FuncDetail.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.FuncDetail) global::GraphEngine.Jit.Native.Asmjit.FuncDetail.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get function declaration.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo FrameInfo
            {
                get
                {
                    var __ret = __Internal.GetFrameInfo((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo) global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.FuncFrameInfo.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get arguments count.</summary>
            public uint ArgCount
            {
                get
                {
                    var __ret = __Internal.GetArgCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get returns count.</summary>
            public uint RetCount
            {
                get
                {
                    var __ret = __Internal.GetRetCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get arguments list.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.VirtReg Args
            {
                get
                {
                    var __ret = __Internal.GetArgs((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.VirtReg __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.VirtReg) global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.VirtReg.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public uint Attributes
            {
                get
                {
                    var __ret = __Internal.GetAttributes((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Function return (CodeCompiler).</summary>
        public unsafe partial class CCFuncRet : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 72)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal fixed byte _ret[32];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CCFuncRet@asmjit@@QEAA@PEAVCodeBuilder@1@AEBUOperand_@1@1@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, global::System.IntPtr o0, global::System.IntPtr o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CCFuncRet@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFirst@CCFuncRet@asmjit@@QEAAAEAVOperand@2@XZ")]
                internal static extern global::System.IntPtr GetFirst(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSecond@CCFuncRet@asmjit@@QEAAAEAVOperand@2@XZ")]
                internal static extern global::System.IntPtr GetSecond(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CCFuncRet __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCFuncRet(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CCFuncRet __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCFuncRet(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CCFuncRet(global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CCFuncRet(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CCFuncRet` instance.</summary>
            public CCFuncRet(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the first return operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Operand First
            {
                get
                {
                    var __ret = __Internal.GetFirst((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.Operand __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.Operand) global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.Operand.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get the second return operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Operand Second
            {
                get
                {
                    var __ret = __Internal.GetSecond((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.Operand __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.Operand) global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.Operand.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        /// <summary>Function call (CodeCompiler).</summary>
        public unsafe partial class CCFuncCall : global::GraphEngine.Jit.Native.Asmjit.CBInst, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 344)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal global::GraphEngine.Jit.Native.Asmjit.Inst.Detail.__Internal _instDetail;

                [FieldOffset(56)]
                internal byte _memOpIndex;

                [FieldOffset(57)]
                internal fixed byte _reserved[7];

                [FieldOffset(64)]
                internal global::System.IntPtr _opArray;

                [FieldOffset(72)]
                internal global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__Internal _funcDetail;

                [FieldOffset(304)]
                internal fixed byte _ret[32];

                [FieldOffset(336)]
                internal global::System.IntPtr _args;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CCFuncCall@asmjit@@QEAA@PEAVCodeBuilder@1@IIPEAVOperand@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, uint instId, uint options, global::System.IntPtr opArray, uint opCount);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CCFuncCall@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setSignature@CCFuncCall@asmjit@@QEAAIAEBUFuncSignature@2@@Z")]
                internal static extern uint SetSignature(global::System.IntPtr instance, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRet@CCFuncCall@asmjit@@QEAAAEAVOperand@2@I@Z")]
                internal static extern global::System.IntPtr GetRet(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArg@CCFuncCall@asmjit@@QEAAAEAVOperand@2@I@Z")]
                internal static extern global::System.IntPtr GetArg(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_setArg@CCFuncCall@asmjit@@QEAA_NIAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetArg(global::System.IntPtr instance, uint i, global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_setRet@CCFuncCall@asmjit@@QEAA_NIAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetRet(global::System.IntPtr instance, uint i, global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setArg@CCFuncCall@asmjit@@QEAA_NIAEBVReg@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetArg_1(global::System.IntPtr instance, uint i, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setArg@CCFuncCall@asmjit@@QEAA_NIAEBVImm@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetArg_2(global::System.IntPtr instance, uint i, global::System.IntPtr imm);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setRet@CCFuncCall@asmjit@@QEAA_NIAEBVReg@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetRet_1(global::System.IntPtr instance, uint i, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getDetail@CCFuncCall@asmjit@@QEAAAEAVFuncDetail@2@XZ")]
                internal static extern global::System.IntPtr GetDetail(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getTarget@CCFuncCall@asmjit@@QEAAAEAVOperand@2@XZ")]
                internal static extern global::System.IntPtr GetTarget(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCFuncCall(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCFuncCall(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CCFuncCall(global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CCFuncCall(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CCFuncCall` instance.</summary>
            public CCFuncCall(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, uint instId, uint options, global::GraphEngine.Jit.Native.Asmjit.Operand opArray, uint opCount)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                var __arg3 = ReferenceEquals(opArray, null) ? global::System.IntPtr.Zero : opArray.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, instId, options, __arg3, opCount);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Set function signature.</summary>
            public uint SetSignature(global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = sign.__Instance;
                var __ret = __Internal.SetSignature((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Get return at `i`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Operand GetRet(uint i)
            {
                var __ret = __Internal.GetRet((__Instance + __PointerAdjustment), i);
                global::GraphEngine.Jit.Native.Asmjit.Operand __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Operand) global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Operand.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Get argument at `i`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Operand GetArg(uint i)
            {
                var __ret = __Internal.GetArg((__Instance + __PointerAdjustment), i);
                global::GraphEngine.Jit.Native.Asmjit.Operand __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Operand) global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Operand.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Set argument at `i` to `op`.</summary>
            public bool SetArg(uint i, global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = op.__Instance;
                var __ret = __Internal.SetArg((__Instance + __PointerAdjustment), i, __arg1);
                return __ret;
            }

            /// <summary>Set return at `i` to `op`.</summary>
            public bool SetRet(uint i, global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = op.__Instance;
                var __ret = __Internal.SetRet((__Instance + __PointerAdjustment), i, __arg1);
                return __ret;
            }

            /// <summary>Set argument at `i` to `reg`.</summary>
            public bool SetArg(uint i, global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = reg.__Instance;
                var __ret = __Internal.SetArg_1((__Instance + __PointerAdjustment), i, __arg1);
                return __ret;
            }

            /// <summary>Set argument at `i` to `imm`.</summary>
            public bool SetArg(uint i, global::GraphEngine.Jit.Native.Asmjit.Imm imm)
            {
                if (ReferenceEquals(imm, null))
                    throw new global::System.ArgumentNullException("imm", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = imm.__Instance;
                var __ret = __Internal.SetArg_2((__Instance + __PointerAdjustment), i, __arg1);
                return __ret;
            }

            /// <summary>Set return at `i` to `var`.</summary>
            public bool SetRet(uint i, global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = reg.__Instance;
                var __ret = __Internal.SetRet_1((__Instance + __PointerAdjustment), i, __arg1);
                return __ret;
            }

            /// <summary>Get function declaration.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.FuncDetail Detail
            {
                get
                {
                    var __ret = __Internal.GetDetail((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.FuncDetail __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.FuncDetail.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.FuncDetail) global::GraphEngine.Jit.Native.Asmjit.FuncDetail.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.FuncDetail.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get target operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.Operand Target
            {
                get
                {
                    var __ret = __Internal.GetTarget((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.Operand __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.Operand) global::GraphEngine.Jit.Native.Asmjit.Operand.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.Operand.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        /// <summary>Push argument before a function call (CodeCompiler).</summary>
        public unsafe partial class CCPushArg : global::GraphEngine.Jit.Native.Asmjit.CBNode, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 72)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _prev;

                [FieldOffset(8)]
                internal global::System.IntPtr _next;

                [FieldOffset(16)]
                internal byte _type;

                [FieldOffset(17)]
                internal byte _opCount;

                [FieldOffset(18)]
                internal ushort _flags;

                [FieldOffset(20)]
                internal uint _position;

                [FieldOffset(24)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(32)]
                internal global::System.IntPtr _passData;

                [FieldOffset(40)]
                internal global::System.IntPtr _call;

                [FieldOffset(48)]
                internal global::System.IntPtr _src;

                [FieldOffset(56)]
                internal global::System.IntPtr _cvt;

                [FieldOffset(64)]
                internal uint _args;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CCPushArg@asmjit@@QEAA@PEAVCodeBuilder@1@PEAVCCFuncCall@1@PEAUVirtReg@1@2@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cb, global::System.IntPtr call, global::System.IntPtr src, global::System.IntPtr cvt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CCPushArg@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCall@CCPushArg@asmjit@@QEBAPEAVCCFuncCall@2@XZ")]
                internal static extern global::System.IntPtr GetCall(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSrcReg@CCPushArg@asmjit@@QEBAPEAUVirtReg@2@XZ")]
                internal static extern global::System.IntPtr GetSrcReg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCvtReg@CCPushArg@asmjit@@QEBAPEAUVirtReg@2@XZ")]
                internal static extern global::System.IntPtr GetCvtReg(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CCPushArg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCPushArg(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CCPushArg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CCPushArg.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CCPushArg(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CCPushArg.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCPushArg.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CCPushArg.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CCPushArg(global::GraphEngine.Jit.Native.Asmjit.CCPushArg.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CCPushArg(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `CCPushArg` instance.</summary>
            public CCPushArg(global::GraphEngine.Jit.Native.Asmjit.CodeBuilder cb, global::GraphEngine.Jit.Native.Asmjit.CCFuncCall call, global::GraphEngine.Jit.Native.Asmjit.VirtReg src, global::GraphEngine.Jit.Native.Asmjit.VirtReg cvt)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CCPushArg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(cb, null) ? global::System.IntPtr.Zero : cb.__Instance;
                var __arg1 = ReferenceEquals(call, null) ? global::System.IntPtr.Zero : call.__Instance;
                var __arg2 = ReferenceEquals(src, null) ? global::System.IntPtr.Zero : src.__Instance;
                var __arg3 = ReferenceEquals(cvt, null) ? global::System.IntPtr.Zero : cvt.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CBNode __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the associated function-call.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFuncCall Call
            {
                get
                {
                    var __ret = __Internal.GetCall((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall) global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get source variable.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.VirtReg SrcReg
            {
                get
                {
                    var __ret = __Internal.GetSrcReg((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.VirtReg __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.VirtReg) global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.VirtReg.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get conversion variable.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.VirtReg CvtReg
            {
                get
                {
                    var __ret = __Internal.GetCvtReg((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.VirtReg __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.VirtReg) global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.VirtReg.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }

        /// <summary>Code emitter that uses virtual registers and performs register allocation.</summary>
        /// <remarks>
        /// <para>Compiler is a high-level code-generation tool that provides register</para>
        /// <para>allocation and automatic handling of function calling conventions. It was</para>
        /// <para>primarily designed for merging multiple parts of code into a function</para>
        /// <para>without worrying about registers and function calling conventions.</para>
        /// <para>CodeCompiler can be used, with a minimum effort, to handle 32-bit and 64-bit</para>
        /// <para>code at the same time.</para>
        /// <para>CodeCompiler is based on CodeBuilder and contains all the features it</para>
        /// <para>provides. It means that the code it stores can be modified (removed, added,</para>
        /// <para>injected) and analyzed. When the code is finalized the compiler can emit</para>
        /// <para>the code into an Assembler to translate the abstract representation into a</para>
        /// <para>machine code.</para>
        /// </remarks>
        public unsafe abstract partial class CodeCompiler : global::GraphEngine.Jit.Native.Asmjit.CodeBuilder, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 472)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_CodeEmitter;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(24)]
                internal global::System.IntPtr _code;

                [FieldOffset(32)]
                internal global::System.IntPtr _nextEmitter;

                [FieldOffset(40)]
                internal byte _type;

                [FieldOffset(41)]
                internal byte _destroyed;

                [FieldOffset(42)]
                internal byte _finalized;

                [FieldOffset(43)]
                internal byte _reserved;

                [FieldOffset(44)]
                internal uint _lastError;

                [FieldOffset(48)]
                internal uint _privateData;

                [FieldOffset(52)]
                internal uint _globalHints;

                [FieldOffset(56)]
                internal uint _globalOptions;

                [FieldOffset(60)]
                internal uint _options;

                [FieldOffset(64)]
                internal global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal _extraReg;

                [FieldOffset(72)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(80)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal _none;

                [FieldOffset(96)]
                internal global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal _nativeGpReg;

                [FieldOffset(112)]
                internal global::System.IntPtr _nativeGpArray;

                [FieldOffset(120)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _cbBaseZone;

                [FieldOffset(152)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _cbDataZone;

                [FieldOffset(184)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _cbPassZone;

                [FieldOffset(216)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneHeap.__Internal _cbHeap;

                [FieldOffset(312)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _cbPasses;

                [FieldOffset(336)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _cbLabels;

                [FieldOffset(360)]
                internal global::System.IntPtr _firstNode;

                [FieldOffset(368)]
                internal global::System.IntPtr _lastNode;

                [FieldOffset(376)]
                internal global::System.IntPtr _cursor;

                [FieldOffset(384)]
                internal uint _position;

                [FieldOffset(388)]
                internal uint _nodeFlags;

                [FieldOffset(392)]
                internal global::System.IntPtr _func;

                [FieldOffset(400)]
                internal global::GraphEngine.Jit.Native.Asmjit.Zone.__Internal _vRegZone;

                [FieldOffset(432)]
                internal global::GraphEngine.Jit.Native.Asmjit.ZoneVector.__Internal _vRegArray;

                [FieldOffset(456)]
                internal global::System.IntPtr _localConstPool;

                [FieldOffset(464)]
                internal global::System.IntPtr _globalConstPool;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CodeCompiler@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CodeCompiler@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newHintNode@CodeCompiler@asmjit@@QEAAPEAVCCHint@2@AEAVReg@2@II@Z")]
                internal static extern global::System.IntPtr NewHintNode(global::System.IntPtr instance, global::System.IntPtr reg, uint hint, uint value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newFunc@CodeCompiler@asmjit@@QEAAPEAVCCFunc@2@AEBUFuncSignature@2@@Z")]
                internal static extern global::System.IntPtr NewFunc(global::System.IntPtr instance, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addFunc@CodeCompiler@asmjit@@QEAAPEAVCCFunc@2@PEAV32@@Z")]
                internal static extern global::System.IntPtr AddFunc(global::System.IntPtr instance, global::System.IntPtr func);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addFunc@CodeCompiler@asmjit@@QEAAPEAVCCFunc@2@AEBUFuncSignature@2@@Z")]
                internal static extern global::System.IntPtr AddFunc_1(global::System.IntPtr instance, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?endFunc@CodeCompiler@asmjit@@QEAAPEAVCBSentinel@2@XZ")]
                internal static extern global::System.IntPtr EndFunc(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newRet@CodeCompiler@asmjit@@QEAAPEAVCCFuncRet@2@AEBUOperand_@2@0@Z")]
                internal static extern global::System.IntPtr NewRet(global::System.IntPtr instance, global::System.IntPtr o0, global::System.IntPtr o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addRet@CodeCompiler@asmjit@@QEAAPEAVCCFuncRet@2@AEBUOperand_@2@0@Z")]
                internal static extern global::System.IntPtr AddRet(global::System.IntPtr instance, global::System.IntPtr o0, global::System.IntPtr o1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newCall@CodeCompiler@asmjit@@QEAAPEAVCCFuncCall@2@IAEBUOperand_@2@AEBUFuncSignature@2@@Z")]
                internal static extern global::System.IntPtr NewCall(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addCall@CodeCompiler@asmjit@@QEAAPEAVCCFuncCall@2@IAEBUOperand_@2@AEBUFuncSignature@2@@Z")]
                internal static extern global::System.IntPtr AddCall(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setArg@CodeCompiler@asmjit@@QEAAIIAEBVReg@2@@Z")]
                internal static extern uint SetArg(global::System.IntPtr instance, uint argIndex, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_hint@CodeCompiler@asmjit@@QEAAIAEAVReg@2@II@Z")]
                internal static extern uint Hint(global::System.IntPtr instance, global::System.IntPtr reg, uint hint, uint value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?newVirtReg@CodeCompiler@asmjit@@QEAAPEAUVirtReg@2@IIPEBD@Z")]
                internal static extern global::System.IntPtr NewVirtReg(global::System.IntPtr instance, uint typeId, uint signature, [MarshalAs(UnmanagedType.LPStr)] string name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_newReg@CodeCompiler@asmjit@@QEAAIAEAVReg@2@IPEBD@Z")]
                internal static extern uint NewReg(global::System.IntPtr instance, global::System.IntPtr @out, uint typeId, [MarshalAs(UnmanagedType.LPStr)] string name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_newReg@CodeCompiler@asmjit@@QEAAIAEAVReg@2@AEBV32@PEBD@Z")]
                internal static extern uint NewReg(global::System.IntPtr instance, global::System.IntPtr @out, global::System.IntPtr @ref, [MarshalAs(UnmanagedType.LPStr)] string name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_newStack@CodeCompiler@asmjit@@QEAAIAEAVMem@2@IIPEBD@Z")]
                internal static extern uint NewStack(global::System.IntPtr instance, global::System.IntPtr @out, uint size, uint alignment, [MarshalAs(UnmanagedType.LPStr)] string name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?_newConst@CodeCompiler@asmjit@@QEAAIAEAVMem@2@IPEBX_K@Z")]
                internal static extern uint NewConst(global::System.IntPtr instance, global::System.IntPtr @out, uint scope, global::System.IntPtr data, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVirtRegValid@CodeCompiler@asmjit@@QEBA_NAEBVReg@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVirtRegValid(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVirtRegValid@CodeCompiler@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVirtRegValid(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVirtReg@CodeCompiler@asmjit@@QEBAPEAUVirtReg@2@AEBVReg@2@@Z")]
                internal static extern global::System.IntPtr GetVirtReg(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVirtRegById@CodeCompiler@asmjit@@QEBAPEAUVirtReg@2@I@Z")]
                internal static extern global::System.IntPtr GetVirtRegById(global::System.IntPtr instance, uint id);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?alloc@CodeCompiler@asmjit@@QEAAIAEAVReg@2@@Z")]
                internal static extern uint Alloc(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?alloc@CodeCompiler@asmjit@@QEAAIAEAVReg@2@I@Z")]
                internal static extern uint Alloc(global::System.IntPtr instance, global::System.IntPtr reg, uint physId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?alloc@CodeCompiler@asmjit@@QEAAIAEAVReg@2@AEBV32@@Z")]
                internal static extern uint Alloc(global::System.IntPtr instance, global::System.IntPtr reg, global::System.IntPtr @ref);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?spill@CodeCompiler@asmjit@@QEAAIAEAVReg@2@@Z")]
                internal static extern uint Spill(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?save@CodeCompiler@asmjit@@QEAAIAEAVReg@2@@Z")]
                internal static extern uint Save(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?unuse@CodeCompiler@asmjit@@QEAAIAEAVReg@2@@Z")]
                internal static extern uint Unuse(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getPriority@CodeCompiler@asmjit@@QEBAIAEAVReg@2@@Z")]
                internal static extern uint GetPriority(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setPriority@CodeCompiler@asmjit@@QEAAXAEAVReg@2@I@Z")]
                internal static extern void SetPriority(global::System.IntPtr instance, global::System.IntPtr reg, uint priority);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSaveOnUnuse@CodeCompiler@asmjit@@QEBA_NAEAVReg@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetSaveOnUnuse(global::System.IntPtr instance, global::System.IntPtr reg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setSaveOnUnuse@CodeCompiler@asmjit@@QEAAXAEAVReg@2@_N@Z")]
                internal static extern void SetSaveOnUnuse(global::System.IntPtr instance, global::System.IntPtr reg, bool value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?rename@CodeCompiler@asmjit@@QEAAXAEAVReg@2@PEBDZZ")]
                internal static extern void Rename(global::System.IntPtr instance, global::System.IntPtr reg, [MarshalAs(UnmanagedType.LPStr)] string fmt);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFunc@CodeCompiler@asmjit@@QEBAPEAVCCFunc@2@XZ")]
                internal static extern global::System.IntPtr GetFunc(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.CodeCompiler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeCompilerInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.CodeCompiler __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.CodeCompiler.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.CodeCompilerInternal(native, skipVTables);
            }

            protected CodeCompiler(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a new `CodeCompiler` instance.</summary>
            protected CodeCompiler()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeCompiler.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.CodeCompiler");
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.CodeCompiler.__Internal*) __Instance)->vfptr_CodeEmitter = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public override uint OnAttach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                return base.OnAttach(code);
            }

            public override uint OnDetach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                return base.OnDetach(code);
            }

            /// <summary>Create a new `CCHint`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCHint NewHintNode(global::GraphEngine.Jit.Native.Asmjit.Reg reg, uint hint, uint value)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.NewHintNode((__Instance + __PointerAdjustment), __arg0, hint, value);
                global::GraphEngine.Jit.Native.Asmjit.CCHint __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCHint.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCHint) global::GraphEngine.Jit.Native.Asmjit.CCHint.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCHint.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Create a new `CCFunc`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFunc NewFunc(global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = sign.__Instance;
                var __ret = __Internal.NewFunc((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.CCFunc __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFunc.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFunc) global::GraphEngine.Jit.Native.Asmjit.CCFunc.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFunc.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Add a function `node` to the stream.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFunc AddFunc(global::GraphEngine.Jit.Native.Asmjit.CCFunc func)
            {
                var __arg0 = ReferenceEquals(func, null) ? global::System.IntPtr.Zero : func.__Instance;
                var __ret = __Internal.AddFunc((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.CCFunc __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFunc.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFunc) global::GraphEngine.Jit.Native.Asmjit.CCFunc.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFunc.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Add a new function.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFunc AddFunc(global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = sign.__Instance;
                var __ret = __Internal.AddFunc_1((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.CCFunc __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFunc.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFunc) global::GraphEngine.Jit.Native.Asmjit.CCFunc.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFunc.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Emit a sentinel that marks the end of the current function.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CBSentinel EndFunc()
            {
                var __ret = __Internal.EndFunc((__Instance + __PointerAdjustment));
                global::GraphEngine.Jit.Native.Asmjit.CBSentinel __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CBSentinel.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CBSentinel) global::GraphEngine.Jit.Native.Asmjit.CBSentinel.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CBSentinel.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Create a new `CCFuncRet`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFuncRet NewRet(global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o1.__Instance;
                var __ret = __Internal.NewRet((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncRet __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet) global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Add a new `CCFuncRet`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFuncRet AddRet(global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o1.__Instance;
                var __ret = __Internal.AddRet((__Instance + __PointerAdjustment), __arg0, __arg1);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncRet __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncRet) global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncRet.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Create a new `CCFuncCall`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFuncCall NewCall(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = sign.__Instance;
                var __ret = __Internal.NewCall((__Instance + __PointerAdjustment), instId, __arg1, __arg2);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall) global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Add a new `CCFuncCall`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFuncCall AddCall(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.FuncSignature sign)
            {
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(sign, null))
                    throw new global::System.ArgumentNullException("sign", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = sign.__Instance;
                var __ret = __Internal.AddCall((__Instance + __PointerAdjustment), instId, __arg1, __arg2);
                global::GraphEngine.Jit.Native.Asmjit.CCFuncCall __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFuncCall) global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFuncCall.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Set a function argument at `argIndex` to `reg`.</summary>
            public uint SetArg(uint argIndex, global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = reg.__Instance;
                var __ret = __Internal.SetArg((__Instance + __PointerAdjustment), argIndex, __arg1);
                return __ret;
            }

            /// <summary>Emit a new hint (purely informational node).</summary>
            public uint Hint(global::GraphEngine.Jit.Native.Asmjit.Reg reg, uint hint, uint value)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.Hint((__Instance + __PointerAdjustment), __arg0, hint, value);
                return __ret;
            }

            /// <summary>Create a new virtual register representing the given `vti` and `signature`.</summary>
            /// <remarks>
            /// <para>This function accepts either register type representing a machine-specific</para>
            /// <para>register, like `X86Reg`, or RegTag representation, which represents</para>
            /// <para>machine independent register, and from the machine-specific register</para>
            /// <para>is deduced.</para>
            /// </remarks>
            public global::GraphEngine.Jit.Native.Asmjit.VirtReg NewVirtReg(uint typeId, uint signature, string name)
            {
                var __ret = __Internal.NewVirtReg((__Instance + __PointerAdjustment), typeId, signature, name);
                global::GraphEngine.Jit.Native.Asmjit.VirtReg __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.VirtReg) global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.VirtReg.__CreateInstance(__ret);
                return __result0;
            }

            public uint NewReg(global::GraphEngine.Jit.Native.Asmjit.Reg @out, uint typeId, string name)
            {
                if (ReferenceEquals(@out, null))
                    throw new global::System.ArgumentNullException("@out", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @out.__Instance;
                var __ret = __Internal.NewReg((__Instance + __PointerAdjustment), __arg0, typeId, name);
                return __ret;
            }

            public uint NewReg(global::GraphEngine.Jit.Native.Asmjit.Reg @out, global::GraphEngine.Jit.Native.Asmjit.Reg @ref, string name)
            {
                if (ReferenceEquals(@out, null))
                    throw new global::System.ArgumentNullException("@out", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @out.__Instance;
                if (ReferenceEquals(@ref, null))
                    throw new global::System.ArgumentNullException("@ref", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = @ref.__Instance;
                var __ret = __Internal.NewReg((__Instance + __PointerAdjustment), __arg0, __arg1, name);
                return __ret;
            }

            public uint NewStack(global::GraphEngine.Jit.Native.Asmjit.Mem @out, uint size, uint alignment, string name)
            {
                if (ReferenceEquals(@out, null))
                    throw new global::System.ArgumentNullException("@out", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @out.__Instance;
                var __ret = __Internal.NewStack((__Instance + __PointerAdjustment), __arg0, size, alignment, name);
                return __ret;
            }

            public uint NewConst(global::GraphEngine.Jit.Native.Asmjit.Mem @out, uint scope, global::System.IntPtr data, ulong size)
            {
                if (ReferenceEquals(@out, null))
                    throw new global::System.ArgumentNullException("@out", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @out.__Instance;
                var __ret = __Internal.NewConst((__Instance + __PointerAdjustment), __arg0, scope, data, size);
                return __ret;
            }

            /// <summary>Get whether the virtual register `r` is valid.</summary>
            public bool IsVirtRegValid(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.IsVirtRegValid((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }


            public bool IsVirtRegValid(uint id)
            {
                var __ret = __Internal.IsVirtRegValid((__Instance + __PointerAdjustment), id);
                return __ret;
            }

            /// <summary>Get</summary>
            public global::GraphEngine.Jit.Native.Asmjit.VirtReg GetVirtReg(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.GetVirtReg((__Instance + __PointerAdjustment), __arg0);
                global::GraphEngine.Jit.Native.Asmjit.VirtReg __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.VirtReg) global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.VirtReg.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Get</summary>
            public global::GraphEngine.Jit.Native.Asmjit.VirtReg GetVirtRegById(uint id)
            {
                var __ret = __Internal.GetVirtRegById((__Instance + __PointerAdjustment), id);
                global::GraphEngine.Jit.Native.Asmjit.VirtReg __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.VirtReg) global::GraphEngine.Jit.Native.Asmjit.VirtReg.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.VirtReg.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Alloc a virtual register `reg`.</summary>
            public uint Alloc(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.Alloc((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Alloc a virtual register `reg` using `physId` as a register id.</summary>
            public uint Alloc(global::GraphEngine.Jit.Native.Asmjit.Reg reg, uint physId)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.Alloc((__Instance + __PointerAdjustment), __arg0, physId);
                return __ret;
            }

            /// <summary>Alloc a virtual register `reg` using `ref` as a register operand.</summary>
            public uint Alloc(global::GraphEngine.Jit.Native.Asmjit.Reg reg, global::GraphEngine.Jit.Native.Asmjit.Reg @ref)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                if (ReferenceEquals(@ref, null))
                    throw new global::System.ArgumentNullException("@ref", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = @ref.__Instance;
                var __ret = __Internal.Alloc((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }

            /// <summary>Spill a virtual register `reg`.</summary>
            public uint Spill(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.Spill((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Save a virtual register `reg` if the status is `modified` at this point.</summary>
            public uint Save(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.Save((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Unuse a virtual register `reg`.</summary>
            public uint Unuse(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.Unuse((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Get priority of a virtual register `reg`.</summary>
            public uint GetPriority(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.GetPriority((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Set priority of variable `reg` to `priority`.</summary>
            public void SetPriority(global::GraphEngine.Jit.Native.Asmjit.Reg reg, uint priority)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                __Internal.SetPriority((__Instance + __PointerAdjustment), __arg0, priority);
            }

            /// <summary>Get save-on-unuse `reg` property.</summary>
            public bool GetSaveOnUnuse(global::GraphEngine.Jit.Native.Asmjit.Reg reg)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                var __ret = __Internal.GetSaveOnUnuse((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }

            /// <summary>Set save-on-unuse `reg` property to `value`.</summary>
            public void SetSaveOnUnuse(global::GraphEngine.Jit.Native.Asmjit.Reg reg, bool value)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                __Internal.SetSaveOnUnuse((__Instance + __PointerAdjustment), __arg0, value);
            }

            /// <summary>Rename variable `reg` to `name`.</summary>
            /// <remarks>NOTE: Only new name will appear in the logger.</remarks>
            public void Rename(global::GraphEngine.Jit.Native.Asmjit.Reg reg, string fmt)
            {
                if (ReferenceEquals(reg, null))
                    throw new global::System.ArgumentNullException("reg", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = reg.__Instance;
                __Internal.Rename((__Instance + __PointerAdjustment), __arg0, fmt);
            }

            /// <summary>Get the current function.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.CCFunc Func
            {
                get
                {
                    var __ret = __Internal.GetFunc((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CCFunc __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CCFunc.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CCFunc) global::GraphEngine.Jit.Native.Asmjit.CCFunc.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CCFunc.__CreateInstance(__ret);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~CodeCompiler() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error onAttach(CodeHolder* code) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnAttachDelegateInstance;

            private static uint _OnAttachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnAttach(__result0);
                return __ret;
            }

            // Error onDetach(CodeHolder* code) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnDetachDelegateInstance;

            private static uint _OnDetachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnDetach(__result0);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3, const Operand_& o4, const Operand_& o5) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _EmitDelegateInstance;

            private static uint _EmitDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, global::System.IntPtr o5)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result5;
                if (o4 == IntPtr.Zero) __result5 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o4))
                    __result5 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o4];
                else __result5 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o4);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result6;
                if (o5 == IntPtr.Zero) __result6 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o5))
                    __result6 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o5];
                else __result6 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o5);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4, __result5, __result6);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr _Emit_1DelegateInstance;

            private static uint _Emit_1DelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4);
                return __ret;
            }

            // Error _emitOpArray(uint32_t instId, const Operand_* opArray, size_t opCount)
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_ulong _EmitOpArrayDelegateInstance;

            private static uint _EmitOpArrayDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr opArray, ulong opCount)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (opArray == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(opArray))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[opArray];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(opArray);
                var __ret = __target.EmitOpArray(instId, __result1, opCount);
                return __ret;
            }

            // Label newLabel() override
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr _NewLabelDelegateInstance;

            private static void _NewLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewLabel();
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Label newNamedLabel(const char* name, size_t nameLength = Globals::kInvalidIndex, uint32_t type = Label::kTypeGlobal, uint32_t parentId = kInvalidValue) override
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint _NewNamedLabelDelegateInstance;

            private static void _NewNamedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string name, ulong nameLength, uint type, uint parentId)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewNamedLabel(name, nameLength, type, parentId);
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Error bind(const Label& label) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _BindDelegateInstance;

            private static uint _BindDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.Bind(__result0);
                return __ret;
            }

            // Error align(uint32_t mode, uint32_t alignment) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint _AlignDelegateInstance;

            private static uint _AlignDelegateHook(global::System.IntPtr instance, uint mode, uint alignment)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Align(mode, alignment);
                return __ret;
            }

            // Error embed(const void* data, uint32_t size) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint _EmbedDelegateInstance;

            private static uint _EmbedDelegateHook(global::System.IntPtr instance, global::System.IntPtr data, uint size)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Embed(data, size);
                return __ret;
            }

            // Error embedLabel(const Label& label) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _EmbedLabelDelegateInstance;

            private static uint _EmbedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.EmbedLabel(__result0);
                return __ret;
            }

            // Error embedConstPool(const Label& label, const ConstPool& pool) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr _EmbedConstPoolDelegateInstance;

            private static uint _EmbedConstPoolDelegateHook(global::System.IntPtr instance, global::System.IntPtr label, global::System.IntPtr pool)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                global::GraphEngine.Jit.Native.Asmjit.ConstPool __result1;
                if (pool == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap.ContainsKey(pool))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.ConstPool) global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap[pool];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.ConstPool.__CreateInstance(pool);
                var __ret = __target.EmbedConstPool(__result0, __result1);
                return __ret;
            }

            // Error comment(const char* s, size_t len = Globals::kInvalidIndex) override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong _CommentDelegateInstance;

            private static uint _CommentDelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s, ulong len)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Comment(s, len);
                return __ret;
            }

            // Error finalize()
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr _FinalizeDelegateInstance;

            private static uint _FinalizeDelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Finalize();
                return __ret;
            }

            // Error serialize(CodeEmitter* dst)
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _SerializeDelegateInstance;

            private static uint _SerializeDelegateHook(global::System.IntPtr instance, global::System.IntPtr dst)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.CodeCompiler) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __result0;
                if (dst == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.NativeToManagedMap.ContainsKey(dst))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.NativeToManagedMap[dst];
                else __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeEmitter) global::GraphEngine.Jit.Native.Asmjit.CodeEmitter.__CreateInstance(dst, skipVTables: true);
                var __ret = __target.Serialize(__result0);
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[16];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _OnAttachDelegateInstance += _OnAttachDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnAttachDelegateInstance).ToPointer();
                    _OnDetachDelegateInstance += _OnDetachDelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnDetachDelegateInstance).ToPointer();
                    _EmitDelegateInstance += _EmitDelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EmitDelegateInstance).ToPointer();
                    _Emit_1DelegateInstance += _Emit_1DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Emit_1DelegateInstance).ToPointer();
                    _EmitOpArrayDelegateInstance += _EmitOpArrayDelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_EmitOpArrayDelegateInstance).ToPointer();
                    _NewLabelDelegateInstance += _NewLabelDelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewLabelDelegateInstance).ToPointer();
                    _NewNamedLabelDelegateInstance += _NewNamedLabelDelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewNamedLabelDelegateInstance).ToPointer();
                    _BindDelegateInstance += _BindDelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_BindDelegateInstance).ToPointer();
                    _AlignDelegateInstance += _AlignDelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_AlignDelegateInstance).ToPointer();
                    _EmbedDelegateInstance += _EmbedDelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_EmbedDelegateInstance).ToPointer();
                    _EmbedLabelDelegateInstance += _EmbedLabelDelegateHook;
                    _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_EmbedLabelDelegateInstance).ToPointer();
                    _EmbedConstPoolDelegateInstance += _EmbedConstPoolDelegateHook;
                    _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_EmbedConstPoolDelegateInstance).ToPointer();
                    _CommentDelegateInstance += _CommentDelegateHook;
                    _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_CommentDelegateInstance).ToPointer();
                    _FinalizeDelegateInstance += _FinalizeDelegateHook;
                    _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_FinalizeDelegateInstance).ToPointer();
                    _SerializeDelegateInstance += _SerializeDelegateHook;
                    _Thunks[15] = Marshal.GetFunctionPointerForDelegate(_SerializeDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(16 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                        *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                        *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                        *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                        *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                        *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                        *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                        *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                        *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                        *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                        *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                        *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                        *(void**) (vfptr0 + 104) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 104);
                        *(void**) (vfptr0 + 112) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 112);
                        *(void**) (vfptr0 + 120) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 120);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(16 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                        *(void**) (vfptr0 + 16) = _Thunks[2];
                        *(void**) (vfptr0 + 24) = _Thunks[3];
                        *(void**) (vfptr0 + 32) = _Thunks[4];
                        *(void**) (vfptr0 + 40) = _Thunks[5];
                        *(void**) (vfptr0 + 48) = _Thunks[6];
                        *(void**) (vfptr0 + 56) = _Thunks[7];
                        *(void**) (vfptr0 + 64) = _Thunks[8];
                        *(void**) (vfptr0 + 72) = _Thunks[9];
                        *(void**) (vfptr0 + 80) = _Thunks[10];
                        *(void**) (vfptr0 + 88) = _Thunks[11];
                        *(void**) (vfptr0 + 96) = _Thunks[12];
                        *(void**) (vfptr0 + 104) = _Thunks[13];
                        *(void**) (vfptr0 + 112) = _Thunks[14];
                        *(void**) (vfptr0 + 120) = _Thunks[15];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        public unsafe partial class CodeCompilerInternal : global::GraphEngine.Jit.Native.Asmjit.CodeCompiler, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.CodeCompiler.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.CodeCompiler.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.CodeCompiler.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CodeCompilerInternal(global::GraphEngine.Jit.Native.Asmjit.CodeCompiler.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal CodeCompilerInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Emit instruction having max 6 operands.</summary>
            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, global::GraphEngine.Jit.Native.Asmjit.Operand_ o5)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___EmitDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                if (ReferenceEquals(o5, null))
                    throw new global::System.ArgumentNullException("o5", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = o5.__Instance;
                var __ret = ___EmitDelegate((__Instance), instId, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                return __ret;
            }

            /// <summary>Emit instruction having max 4 operands.</summary>
            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___Emit_1Delegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = ___Emit_1Delegate((__Instance), instId, __arg1, __arg2, __arg3, __arg4);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        namespace X86defs
        {
            /// <summary>Flags describing special registers and/or their parts.</summary>
            [Flags]
            public enum SpecialRegs : uint
            {
                /// <summary>[R|E]FLAGS - Carry flag.</summary>
                kSpecialRegFLAGS_CF = 0x1,
                /// <summary>[R|E]FLAGS - Parity flag.</summary>
                kSpecialRegFLAGS_PF = 0x2,
                /// <summary>[R|E]FLAGS - Adjust flag.</summary>
                kSpecialRegFLAGS_AF = 0x4,
                /// <summary>[R|E]FLAGS - Zero flag.</summary>
                kSpecialRegFLAGS_ZF = 0x8,
                /// <summary>[R|E]FLAGS - Sign flag.</summary>
                kSpecialRegFLAGS_SF = 0x10,
                /// <summary>[R|E]FLAGS - Trap flag.</summary>
                kSpecialRegFLAGS_TF = 0x20,
                /// <summary>[R|E]FLAGS - Interrupt enable flag.</summary>
                kSpecialRegFLAGS_IF = 0x40,
                /// <summary>[R|E]FLAGS - Direction flag.</summary>
                kSpecialRegFLAGS_DF = 0x80,
                /// <summary>[R|E]FLAGS - Overflow flag.</summary>
                kSpecialRegFLAGS_OF = 0x100,
                /// <summary>[R|E]FLAGS - Alignment check.</summary>
                kSpecialRegFLAGS_AC = 0x200,
                /// <summary>[R|E]FLAGS - System flags.</summary>
                kSpecialRegFLAGS_SYS = 0x400,
                /// <summary>X87 Control Word - Exception control.</summary>
                kSpecialRegX87CW_EXC = 0x800,
                /// <summary>X87 Control Word - Precision control.</summary>
                kSpecialRegX87CW_PC = 0x1000,
                /// <summary>X87 Control Word - Rounding control.</summary>
                kSpecialRegX87CW_RC = 0x2000,
                /// <summary>X87 Status Word - Exception flags.</summary>
                kSpecialRegX87SW_EXC = 0x4000,
                /// <summary>X87 Status Word - C0 flag.</summary>
                kSpecialRegX87SW_C0 = 0x8000,
                /// <summary>X87 Status Word - C1 flag.</summary>
                kSpecialRegX87SW_C1 = 0x10000,
                /// <summary>X87 Status Word - C2 flag.</summary>
                kSpecialRegX87SW_C2 = 0x20000,
                /// <summary>X87 Status Word - Top of the FPU stack.</summary>
                kSpecialRegX87SW_TOP = 0x40000,
                /// <summary>X87 Status Word - C3 flag.</summary>
                kSpecialRegX87SW_C3 = 0x80000,
                /// <summary>MSR register.</summary>
                kSpecialRegMSR = 0x100000,
                /// <summary>XCR register.</summary>
                kSpecialRegXCR = 0x200000
            }

            /// <summary>FPU status word.</summary>
            public enum X87SW : uint
            {
                kX87SW_Invalid = 0x1,
                kX87SW_Denormalized = 0x2,
                kX87SW_DivByZero = 0x4,
                kX87SW_Overflow = 0x8,
                kX87SW_Underflow = 0x10,
                kX87SW_Precision = 0x20,
                kX87SW_StackFault = 0x40,
                kX87SW_Interrupt = 0x80,
                kX87SW_C0 = 0x100,
                kX87SW_C1 = 0x200,
                kX87SW_C2 = 0x400,
                kX87SW_Top = 0x3800,
                kX87SW_C3 = 0x4000,
                kX87SW_Busy = 0x8000
            }

            /// <summary>FPU control word.</summary>
            public enum X87CW : uint
            {
                kX87CW_EM_Mask = 0x3f,
                kX87CW_EM_Invalid = 0x1,
                kX87CW_EM_Denormal = 0x2,
                kX87CW_EM_DivByZero = 0x4,
                kX87CW_EM_Overflow = 0x8,
                kX87CW_EM_Underflow = 0x10,
                kX87CW_EM_Inexact = 0x20,
                kX87CW_PC_Mask = 0x300,
                kX87CW_PC_Float = 0x0,
                kX87CW_PC_Reserved = 0x100,
                kX87CW_PC_Double = 0x200,
                kX87CW_PC_Extended = 0x300,
                kX87CW_RC_Mask = 0xc00,
                kX87CW_RC_Nearest = 0x0,
                kX87CW_RC_Down = 0x400,
                kX87CW_RC_Up = 0x800,
                kX87CW_RC_Truncate = 0xc00,
                kX87CW_IC_Mask = 0x1000,
                kX87CW_IC_Projective = 0x0,
                kX87CW_IC_Affine = 0x1000
            }

            /// <summary>Condition codes.</summary>
            public enum Cond : uint
            {
                /// <summary>OF==1</summary>
                kCondO = 0x0,
                /// <summary>OF==0</summary>
                kCondNO = 0x1,
                /// <summary>CF==1                  (unsigned&lt;&gt;)</summary>
                kCondB = 0x2,
                /// <summary>CF==1</summary>
                kCondC = 0x2,
                /// <summary>CF==1                  (unsigned&lt;&gt;)</summary>
                kCondNAE = 0x2,
                /// <summary>CF==0                  (unsigned &gt;=)</summary>
                kCondAE = 0x3,
                /// <summary>CF==0                  (unsigned &gt;=)</summary>
                kCondNB = 0x3,
                /// <summary>CF==0</summary>
                kCondNC = 0x3,
                /// <summary>ZF==1          (any_sign ==)</summary>
                kCondE = 0x4,
                /// <summary>ZF==1          (any_sign ==)</summary>
                kCondZ = 0x4,
                /// <summary>ZF==0          (any_sign !=)</summary>
                kCondNE = 0x5,
                /// <summary>ZF==0          (any_sign !=)</summary>
                kCondNZ = 0x5,
                /// <summary>CF==1 | ZF==1          (unsigned&lt;&gt;=)</summary>
                kCondBE = 0x6,
                /// <summary>CF==1 | ZF==1          (unsigned&lt;&gt;=)</summary>
                kCondNA = 0x6,
                /// <summary>CF==0&amp;ZF==0          (unsigned &gt; )</summary>
                kCondA = 0x7,
                /// <summary>CF==0&amp;ZF==0          (unsigned &gt; )</summary>
                kCondNBE = 0x7,
                /// <summary>SF==1  (is negative)</summary>
                kCondS = 0x8,
                /// <summary>SF==0  (is positive or zero)</summary>
                kCondNS = 0x9,
                /// <summary>PF==1</summary>
                kCondP = 0xa,
                /// <summary>PF==1</summary>
                kCondPE = 0xa,
                /// <summary>PF==0</summary>
                kCondPO = 0xb,
                /// <summary>PF==0</summary>
                kCondNP = 0xb,
                /// <summary>SF!=OF (signed&lt;&gt;)</summary>
                kCondL = 0xc,
                /// <summary>SF!=OF (signed&lt;&gt;)</summary>
                kCondNGE = 0xc,
                /// <summary>SF==OF (signed   &gt;=)</summary>
                kCondGE = 0xd,
                /// <summary>SF==OF (signed   &gt;=)</summary>
                kCondNL = 0xd,
                /// <summary>ZF==1 | SF!=OF (signed&lt;&gt;=)</summary>
                kCondLE = 0xe,
                /// <summary>ZF==1 | SF!=OF (signed&lt;&gt;=)</summary>
                kCondNG = 0xe,
                /// <summary>ZF==0&amp;SF==OF (signed   &gt; )</summary>
                kCondG = 0xf,
                /// <summary>ZF==0&amp;SF==OF (signed   &gt; )</summary>
                kCondNLE = 0xf,
                kCondCount = 0x10,
                /// <summary>Sign.</summary>
                kCondSign = 8,
                /// <summary>Not Sign.</summary>
                kCondNotSign = 9,
                /// <summary>Signed overflow.</summary>
                kCondOverflow = 0,
                /// <summary>Not signed overflow.</summary>
                kCondNotOverflow = 1,
                /// <summary>Equal      `a == b`.</summary>
                kCondEqual = 4,
                /// <summary>Not Equal  `a != b`.</summary>
                kCondNotEqual = 5,
                /// <summary>Signed     `a&lt;&gt;b`.</summary>
                kCondSignedLT = 12,
                /// <summary>Signed     `a&lt;&gt;= b`.</summary>
                kCondSignedLE = 14,
                /// <summary>Signed     `a &gt;  b`.</summary>
                kCondSignedGT = 15,
                /// <summary>Signed     `a &gt;= b`.</summary>
                kCondSignedGE = 13,
                /// <summary>Unsigned   `a&lt;&gt;b`.</summary>
                kCondUnsignedLT = 2,
                /// <summary>Unsigned   `a&lt;&gt;= b`.</summary>
                kCondUnsignedLE = 6,
                /// <summary>Unsigned   `a &gt;  b`.</summary>
                kCondUnsignedGT = 7,
                /// <summary>Unsigned   `a &gt;= b`.</summary>
                kCondUnsignedGE = 3,
                kCondZero = 4,
                kCondNotZero = 5,
                kCondNegative = 8,
                kCondPositive = 9,
                kCondParityEven = 10,
                kCondParityOdd = 11
            }

            /// <summary>A predicate used by CMP[PD|PS|SD|SS] instructions.</summary>
            public enum CmpPredicate : uint
            {
                /// <summary>Equal             (Quiet).</summary>
                kCmpEQ = 0x0,
                /// <summary>Less              (Signaling).</summary>
                kCmpLT = 0x1,
                /// <summary>Less/Equal        (Signaling).</summary>
                kCmpLE = 0x2,
                /// <summary>Unordered         (Quiet).</summary>
                kCmpUNORD = 0x3,
                /// <summary>Not Equal         (Quiet).</summary>
                kCmpNEQ = 0x4,
                /// <summary>Not Less          (Signaling).</summary>
                kCmpNLT = 0x5,
                /// <summary>Not Less/Equal    (Signaling).</summary>
                kCmpNLE = 0x6,
                /// <summary>Ordered           (Quiet).</summary>
                kCmpORD = 0x7
            }

            /// <summary>A predicate used by VCMP[PD|PS|SD|SS] instructions.</summary>
            /// <remarks>The first 8 values are compatible with</remarks>
            public enum VCmpPredicate : uint
            {
                /// <summary>Equal             (Quiet    , Ordered).</summary>
                kVCmpEQ_OQ = 0x0,
                /// <summary>Less              (Signaling, Ordered).</summary>
                kVCmpLT_OS = 0x1,
                /// <summary>Less/Equal        (Signaling, Ordered).</summary>
                kVCmpLE_OS = 0x2,
                /// <summary>Unordered         (Quiet).</summary>
                kVCmpUNORD_Q = 0x3,
                /// <summary>Not Equal         (Quiet    , Unordered).</summary>
                kVCmpNEQ_UQ = 0x4,
                /// <summary>Not Less          (Signaling, Unordered).</summary>
                kVCmpNLT_US = 0x5,
                /// <summary>Not Less/Equal    (Signaling, Unordered).</summary>
                kVCmpNLE_US = 0x6,
                /// <summary>Ordered           (Quiet).</summary>
                kVCmpORD_Q = 0x7,
                /// <summary>Equal             (Quiet    , Unordered).</summary>
                kVCmpEQ_UQ = 0x8,
                /// <summary>Not Greater/Equal (Signaling, Unordered).</summary>
                kVCmpNGE_US = 0x9,
                /// <summary>Not Greater       (Signaling, Unordered).</summary>
                kVCmpNGT_US = 0xa,
                /// <summary>False             (Quiet    , Ordered).</summary>
                kVCmpFALSE_OQ = 0xb,
                /// <summary>Not Equal         (Quiet    , Ordered).</summary>
                kVCmpNEQ_OQ = 0xc,
                /// <summary>Greater/Equal     (Signaling, Ordered).</summary>
                kVCmpGE_OS = 0xd,
                /// <summary>Greater           (Signaling, Ordered).</summary>
                kVCmpGT_OS = 0xe,
                /// <summary>True              (Quiet    , Unordered).</summary>
                kVCmpTRUE_UQ = 0xf,
                /// <summary>Equal             (Signaling, Ordered).</summary>
                kVCmpEQ_OS = 0x10,
                /// <summary>Less              (Quiet    , Ordered).</summary>
                kVCmpLT_OQ = 0x11,
                /// <summary>Less/Equal        (Quiet    , Ordered).</summary>
                kVCmpLE_OQ = 0x12,
                /// <summary>Unordered         (Signaling).</summary>
                kVCmpUNORD_S = 0x13,
                /// <summary>Not Equal         (Signaling, Unordered).</summary>
                kVCmpNEQ_US = 0x14,
                /// <summary>Not Less          (Quiet    , Unordered).</summary>
                kVCmpNLT_UQ = 0x15,
                /// <summary>Not Less/Equal    (Quiet    , Unordered).</summary>
                kVCmpNLE_UQ = 0x16,
                /// <summary>Ordered           (Signaling).</summary>
                kVCmpORD_S = 0x17,
                /// <summary>Equal             (Signaling, Unordered).</summary>
                kVCmpEQ_US = 0x18,
                /// <summary>Not Greater/Equal (Quiet    , Unordered).</summary>
                kVCmpNGE_UQ = 0x19,
                /// <summary>Not Greater       (Quiet    , Unordered).</summary>
                kVCmpNGT_UQ = 0x1a,
                /// <summary>False             (Signaling, Ordered).</summary>
                kVCmpFALSE_OS = 0x1b,
                /// <summary>Not Equal         (Signaling, Ordered).</summary>
                kVCmpNEQ_OS = 0x1c,
                /// <summary>Greater/Equal     (Quiet    , Ordered).</summary>
                kVCmpGE_OQ = 0x1d,
                /// <summary>Greater           (Quiet    , Ordered).</summary>
                kVCmpGT_OQ = 0x1e,
                /// <summary>True              (Signaling, Unordered).</summary>
                kVCmpTRUE_US = 0x1f
            }

            /// <summary>A predicate used by [V]PCMP[I|E]STR[I|M] instructions.</summary>
            public enum PCmpStrPredicate : uint
            {
                /// <summary>The source data format is unsigned bytes.</summary>
                kPCmpStrUB = 0x0,
                /// <summary>The source data format is unsigned words.</summary>
                kPCmpStrUW = 0x1,
                /// <summary>The source data format is signed bytes.</summary>
                kPCmpStrSB = 0x2,
                /// <summary>The source data format is signed words.</summary>
                kPCmpStrSW = 0x3,
                /// <summary>The arithmetic comparison is &quot;equal&quot;.</summary>
                kPCmpStrEqualAny = 0x0,
                /// <summary>
                /// <para>The arithmetic comparison is “greater than or equal”</para>
                /// <para>between even indexed elements and “less than or equal”</para>
                /// <para>between odd indexed elements.</para>
                /// </summary>
                kPCmpStrRanges = 0x4,
                /// <summary>The arithmetic comparison is &quot;equal&quot;.</summary>
                kPCmpStrEqualEach = 0x8,
                /// <summary>The arithmetic comparison is &quot;equal&quot;.</summary>
                kPCmpStrEqualOrdered = 0xc,
                /// <summary>IntRes2 = IntRes1.</summary>
                kPCmpStrPosPolarity = 0x0,
                /// <summary>IntRes2 = -1 XOR IntRes1.</summary>
                kPCmpStrNegPolarity = 0x10,
                /// <summary>IntRes2 = IntRes1.</summary>
                kPCmpStrPosMasked = 0x20,
                /// <summary>IntRes2[i] = second[i] == invalid ? IntRes1[i] : ~IntRes1[i].</summary>
                kPCmpStrNegMasked = 0x30,
                /// <summary>The index returned to ECX is of the least significant set bit in IntRes2.</summary>
                kPCmpStrOutputLSI = 0x0,
                /// <summary>The index returned to ECX is of the most significant set bit in IntRes2.</summary>
                kPCmpStrOutputMSI = 0x40,
                /// <summary>IntRes2 is returned as the mask to the least significant bits of XMM0.</summary>
                kPCmpStrBitMask = 0x0,
                /// <summary>IntRes2 is expanded into a byte/word mask and placed in XMM0.</summary>
                kPCmpStrIndexMask = 0x40
            }

            /// <summary>A predicate used by VPCMP[U][B|W|D|Q] instructions (AVX-512).</summary>
            public enum VPCmpPredicate : uint
            {
                /// <summary>Equal.</summary>
                kVPCmpEQ = 0x0,
                /// <summary>Less.</summary>
                kVPCmpLT = 0x1,
                /// <summary>Less/Equal.</summary>
                kVPCmpLE = 0x2,
                /// <summary>False.</summary>
                kVPCmpFALSE = 0x3,
                /// <summary>Not Equal.</summary>
                kVPCmpNE = 0x4,
                /// <summary>Greater/Equal.</summary>
                kVPCmpGE = 0x5,
                /// <summary>Greater.</summary>
                kVPCmpGT = 0x6,
                /// <summary>True.</summary>
                kVPCmpTRUE = 0x7
            }

            /// <summary>A predicate used by VPCOM[U][B|W|D|Q] instructions (XOP).</summary>
            public enum VPComPredicate : uint
            {
                /// <summary>Less.</summary>
                kVPComLT = 0x0,
                /// <summary>Less/Equal</summary>
                kVPComLE = 0x1,
                /// <summary>Greater.</summary>
                kVPComGT = 0x2,
                /// <summary>Greater/Equal.</summary>
                kVPComGE = 0x3,
                /// <summary>Equal.</summary>
                kVPComEQ = 0x4,
                /// <summary>Not Equal.</summary>
                kVPComNE = 0x5,
                /// <summary>False.</summary>
                kVPComFALSE = 0x6,
                /// <summary>True.</summary>
                kVPComTRUE = 0x7
            }

            /// <summary>A predicate used by VFPCLASS[PD|PS|SD|SS] instructions (AVX-512).</summary>
            public enum VFPClassPredicate : uint
            {
                kVFPClassQNaN = 0x0,
                kVFPClassPZero = 0x1,
                kVFPClassNZero = 0x2,
                kVFPClassPInf = 0x3,
                kVFPClassNInf = 0x4,
                kVFPClassDenormal = 0x5,
                kVFPClassNegative = 0x6,
                kVFPClassSNaN = 0x7
            }

            /// <summary>A predicate used by VFIXUPIMM[PD|PS|SD|SS] instructions (AVX-512).</summary>
            [Flags]
            public enum VFixupImmPredicate : uint
            {
                kVFixupImmZEOnZero = 0x1,
                kVFixupImmIEOnZero = 0x2,
                kVFixupImmZEOnOne = 0x4,
                kVFixupImmIEOnOne = 0x8,
                kVFixupImmIEOnSNaN = 0x10,
                kVFixupImmIEOnNInf = 0x20,
                kVFixupImmIEOnNegative = 0x40,
                kVFixupImmIEOnPInf = 0x80
            }

            /// <summary>A predicate used by VGETMANT[PD|PS|SD|SS] instructions (AVX-512).</summary>
            public enum VGetMantPredicate : uint
            {
                kVGetMant1To2 = 0x0,
                kVGetMant1Div2To2 = 0x1,
                kVGetMant1Div2To1 = 0x2,
                kVGetMant3Div4To3Div2 = 0x3,
                kVGetMantNoSign = 0x4,
                kVGetMantQNaNIfSign = 0x8
            }

            /// <summary>A predicate used by VRANGE[PD|PS|SD|SS] instructions (AVX-512).</summary>
            public enum VRangePredicate : uint
            {
                /// <summary>Select minimum value.</summary>
                kVRangeSelectMin = 0x0,
                /// <summary>Select maximum value.</summary>
                kVRangeSelectMax = 0x1,
                /// <summary>Select minimum absolute value.</summary>
                kVRangeSelectAbsMin = 0x2,
                /// <summary>Select maximum absolute value.</summary>
                kVRangeSelectAbsMax = 0x3,
                /// <summary>Select sign of SRC1.</summary>
                kVRangeSignSrc1 = 0x0,
                /// <summary>Select sign of SRC2.</summary>
                kVRangeSignSrc2 = 0x4,
                /// <summary>Set sign to 0.</summary>
                kVRangeSign0 = 0x8,
                /// <summary>Set sign to 1.</summary>
                kVRangeSign1 = 0xc
            }

            /// <summary>A predicate used by VREDUCE[PD|PS|SD|SS] instructions (AVX-512).</summary>
            public enum VReducePredicate : uint
            {
                /// <summary>Round to the current mode set.</summary>
                kVReduceRoundCurrent = 0x0,
                /// <summary>Round to nearest even.</summary>
                kVReduceRoundEven = 0x4,
                /// <summary>Round down.</summary>
                kVReduceRoundDown = 0x5,
                /// <summary>Round up.</summary>
                kVReduceRoundUp = 0x6,
                /// <summary>Truncate.</summary>
                kVReduceRoundTrunc = 0x7,
                /// <summary>Suppress exceptions.</summary>
                kVReduceSuppress = 0x8
            }

            /// <summary>A predicate that can be used to create an immediate for VTERNLOG[D|Q].</summary>
            public enum TLogPredicate : uint
            {
                kTLog0 = 0x0,
                kTLog1 = 0xff,
                kTLogA = 0xf0,
                kTLogB = 0xcc,
                kTLogC = 0xaa,
                kTLogNotA = 0xf,
                kTLogNotB = 0x33,
                kTLogNotC = 0x55,
                kTLogAB = 192,
                kTLogAC = 160,
                kTLogBC = 136,
                kTLogNotAB = 0x3f,
                kTLogNotAC = 0x5f,
                kTLogNotBC = 0x77,
                kTLogABC = 128,
                kTLogNotABC = 0x7f
            }

            /// <summary>A predicate used by ROUND[PD|PS|SD|SS] instructions.</summary>
            public enum RoundPredicate : uint
            {
                /// <summary>Round to nearest (even).</summary>
                kRoundNearest = 0x0,
                /// <summary>Round to down toward -INF (floor),</summary>
                kRoundDown = 0x1,
                /// <summary>Round to up toward +INF (ceil).</summary>
                kRoundUp = 0x2,
                /// <summary>Round toward zero (truncate).</summary>
                kRoundTrunc = 0x3,
                /// <summary>Round to the current rounding mode set (ignores other RC bits).</summary>
                kRoundCurrent = 0x4,
                /// <summary>Avoids inexact exception, if set.</summary>
                kRoundInexact = 0x8
            }
        }

        namespace X86
        {
            public unsafe partial class x86globals
            {
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?shufImm@x86@asmjit@@YAHII@Z")]
                    internal static extern int ShufImm(uint a, uint b);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?shufImm@x86@asmjit@@YAHIIII@Z")]
                    internal static extern int ShufImm(uint a, uint b, uint c, uint d);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tlogImm@x86@asmjit@@YAHIIIIIIII@Z")]
                    internal static extern int TlogImm(uint b000, uint b001, uint b010, uint b011, uint b100, uint b101, uint b110, uint b111);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tlogVal@x86@asmjit@@YAHH@Z")]
                    internal static extern int TlogVal(int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tlogNot@x86@asmjit@@YAHH@Z")]
                    internal static extern int TlogNot(int x);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tlogIf@x86@asmjit@@YAHHHH@Z")]
                    internal static extern int TlogIf(int cond, int a, int b);
                }

                /// <summary>Pack a shuffle constant to be used by SSE/AVX/AVX-512 instructions (2 values).</summary>
                /// <param name="a">Position of the first  component [0, 1].</param>
                /// <param name="b">Position of the second component [0, 1].</param>
                /// <remarks>
                /// <para>Shuffle constants can be used to encode an immediate for these instructions:</para>
                /// <para>- `shufpd`</para>
                /// </remarks>
                public static int ShufImm(uint a, uint b)
                {
                    var __ret = __Internal.ShufImm(a, b);
                    return __ret;
                }

                /// <summary>Pack a shuffle constant to be used by SSE/AVX/AVX-512 instructions (4 values).</summary>
                /// <param name="a">Position of the first  component [0, 3].</param>
                /// <param name="b">Position of the second component [0, 3].</param>
                /// <param name="c">Position of the third  component [0, 3].</param>
                /// <param name="d">Position of the fourth component [0, 3].</param>
                /// <remarks>
                /// <para>Shuffle constants can be used to encode an immediate for these instructions:</para>
                /// <para>- `pshufw()`</para>
                /// <para>- `pshufd()`</para>
                /// <para>- `pshuflw()`</para>
                /// <para>- `pshufhw()`</para>
                /// <para>- `shufps()`</para>
                /// </remarks>
                public static int ShufImm(uint a, uint b, uint c, uint d)
                {
                    var __ret = __Internal.ShufImm(a, b, c, d);
                    return __ret;
                }

                /// <summary>Create an immediate that can be used by VTERNLOG[D|Q] instructions.</summary>
                public static int TlogImm(uint b000, uint b001, uint b010, uint b011, uint b100, uint b101, uint b110, uint b111)
                {
                    var __ret = __Internal.TlogImm(b000, b001, b010, b011, b100, b101, b110, b111);
                    return __ret;
                }

                /// <summary>Create an immediate that can be used by VTERNLOG[D|Q] instructions.</summary>
                public static int TlogVal(int x)
                {
                    var __ret = __Internal.TlogVal(x);
                    return __ret;
                }

                /// <summary>Negate an immediate that can be used by VTERNLOG[D|Q] instructions.</summary>
                public static int TlogNot(int x)
                {
                    var __ret = __Internal.TlogNot(x);
                    return __ret;
                }

                /// <summary>Create an if/else logic that can be used by VTERNLOG[D|Q] instructions.</summary>
                public static int TlogIf(int cond, int a, int b)
                {
                    var __ret = __Internal.TlogIf(cond, a, b);
                    return __ret;
                }
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>X86/X64 instruction data.</summary>
        public unsafe partial class X86Inst : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint _encodingType;

                [FieldOffset(1)]
                internal uint _nameDataIndex;

                [FieldOffset(2)]
                internal uint _commonDataIndex;

                [FieldOffset(4)]
                internal uint _operationDataIndex;

                [FieldOffset(5)]
                internal uint _sseToAvxDataIndex;

                [FieldOffset(5)]
                internal uint _reserved;

                [FieldOffset(8)]
                internal uint _mainOpCode;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Inst@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasFlag@X86Inst@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasFlag(global::System.IntPtr instance, uint flag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isDefinedId@X86Inst@asmjit@@SA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsDefinedId(uint instId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getInst@X86Inst@asmjit@@SAAEBU12@I@Z")]
                internal static extern global::System.IntPtr GetInst(uint instId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?negateCond@X86Inst@asmjit@@SAII@Z")]
                internal static extern uint NegateCond(uint cond);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reverseCond@X86Inst@asmjit@@SAII@Z")]
                internal static extern uint ReverseCond(uint cond);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?condToCmovcc@X86Inst@asmjit@@SAII@Z")]
                internal static extern uint CondToCmovcc(uint cond);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?condToJcc@X86Inst@asmjit@@SAII@Z")]
                internal static extern uint CondToJcc(uint cond);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?condToSetcc@X86Inst@asmjit@@SAII@Z")]
                internal static extern uint CondToSetcc(uint cond);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?kmovIdFromSize@X86Inst@asmjit@@SAII@Z")]
                internal static extern uint KmovIdFromSize(uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getIdByName@X86Inst@asmjit@@SAIPEBD_K@Z")]
                internal static extern uint GetIdByName([MarshalAs(UnmanagedType.LPStr)] string name, ulong len);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getNameById@X86Inst@asmjit@@SAPEBDI@Z")]
                internal static extern global::System.IntPtr GetNameById(uint instId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getName@X86Inst@asmjit@@QEBAPEBDXZ")]
                internal static extern global::System.IntPtr GetName(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getNameDataIndex@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetNameDataIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCommonData@X86Inst@asmjit@@QEBAAEBUCommonData@12@XZ")]
                internal static extern global::System.IntPtr GetCommonData(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCommonDataIndex@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetCommonDataIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOperationData@X86Inst@asmjit@@QEBAAEBUOperationData@12@XZ")]
                internal static extern global::System.IntPtr GetOperationData(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getOperationDataIndex@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetOperationDataIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSseToAvxData@X86Inst@asmjit@@QEBAAEBUSseToAvxData@12@XZ")]
                internal static extern global::System.IntPtr GetSseToAvxData(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSseToAvxDataIndex@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetSseToAvxDataIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getEncodingType@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetEncodingType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasMainOpCode@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasMainOpCode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getMainOpCode@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetMainOpCode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAltOpCode@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAltOpCode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAltOpCode@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetAltOpCode(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getFlags@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetFlags(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isFpu@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFpu(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isMmx@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMmx(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVec@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVec(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isSse@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSse(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isAvx@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAvx(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isLockEnabled@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsLockEnabled(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRepEnabled@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRepEnabled(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRepzEnabled@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRepzEnabled(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRepnzEnabled@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRepnzEnabled(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isMibOp@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMibOp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVsibOp@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVsibOp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isVex@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsVex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isEvex@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEvex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAvx512K@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAvx512K(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAvx512Z@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAvx512Z(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAvx512ER@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAvx512ER(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAvx512SAE@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAvx512SAE(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAvx512B@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAvx512B(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAvx512B32@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAvx512B32(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasAvx512B64@X86Inst@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasAvx512B64(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getISignatureIndex@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetISignatureIndex(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getISignatureCount@X86Inst@asmjit@@QEBAIXZ")]
                internal static extern uint GetISignatureCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getISignatureData@X86Inst@asmjit@@QEBAPEBUISignature@12@XZ")]
                internal static extern global::System.IntPtr GetISignatureData(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getISignatureEnd@X86Inst@asmjit@@QEBAPEBUISignature@12@XZ")]
                internal static extern global::System.IntPtr GetISignatureEnd(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getMiscData@X86Inst@asmjit@@SAAEBUMiscData@12@XZ")]
                internal static extern global::System.IntPtr GetMiscData();
            }

            /// <summary>Instruction id (AsmJit specific).</summary>
            /// <remarks>
            /// <para>Each instruction has a unique ID that is used as an index to AsmJit's</para>
            /// <para>instruction table. Instructions are sorted alphabetically.</para>
            /// </remarks>
            public enum Id : uint
            {
                kIdNone = 0,
                kIdAaa = 1,
                kIdAad = 2,
                kIdAam = 3,
                kIdAas = 4,
                kIdAdc = 5,
                kIdAdcx = 6,
                kIdAdd = 7,
                kIdAddpd = 8,
                kIdAddps = 9,
                kIdAddsd = 10,
                kIdAddss = 11,
                kIdAddsubpd = 12,
                kIdAddsubps = 13,
                kIdAdox = 14,
                kIdAesdec = 15,
                kIdAesdeclast = 16,
                kIdAesenc = 17,
                kIdAesenclast = 18,
                kIdAesimc = 19,
                kIdAeskeygenassist = 20,
                kIdAnd = 21,
                kIdAndn = 22,
                kIdAndnpd = 23,
                kIdAndnps = 24,
                kIdAndpd = 25,
                kIdAndps = 26,
                kIdArpl = 27,
                kIdBextr = 28,
                kIdBlcfill = 29,
                kIdBlci = 30,
                kIdBlcic = 31,
                kIdBlcmsk = 32,
                kIdBlcs = 33,
                kIdBlendpd = 34,
                kIdBlendps = 35,
                kIdBlendvpd = 36,
                kIdBlendvps = 37,
                kIdBlsfill = 38,
                kIdBlsi = 39,
                kIdBlsic = 40,
                kIdBlsmsk = 41,
                kIdBlsr = 42,
                kIdBndcl = 43,
                kIdBndcn = 44,
                kIdBndcu = 45,
                kIdBndldx = 46,
                kIdBndmk = 47,
                kIdBndmov = 48,
                kIdBndstx = 49,
                kIdBound = 50,
                kIdBsf = 51,
                kIdBsr = 52,
                kIdBswap = 53,
                kIdBt = 54,
                kIdBtc = 55,
                kIdBtr = 56,
                kIdBts = 57,
                kIdBzhi = 58,
                kIdCall = 59,
                kIdCbw = 60,
                kIdCdq = 61,
                kIdCdqe = 62,
                kIdClac = 63,
                kIdClc = 64,
                kIdCld = 65,
                kIdClflush = 66,
                kIdClflushopt = 67,
                kIdCli = 68,
                kIdClts = 69,
                kIdClwb = 70,
                kIdClzero = 71,
                kIdCmc = 72,
                kIdCmova = 73,
                kIdCmovae = 74,
                kIdCmovb = 75,
                kIdCmovbe = 76,
                kIdCmovc = 77,
                kIdCmove = 78,
                kIdCmovg = 79,
                kIdCmovge = 80,
                kIdCmovl = 81,
                kIdCmovle = 82,
                kIdCmovna = 83,
                kIdCmovnae = 84,
                kIdCmovnb = 85,
                kIdCmovnbe = 86,
                kIdCmovnc = 87,
                kIdCmovne = 88,
                kIdCmovng = 89,
                kIdCmovnge = 90,
                kIdCmovnl = 91,
                kIdCmovnle = 92,
                kIdCmovno = 93,
                kIdCmovnp = 94,
                kIdCmovns = 95,
                kIdCmovnz = 96,
                kIdCmovo = 97,
                kIdCmovp = 98,
                kIdCmovpe = 99,
                kIdCmovpo = 100,
                kIdCmovs = 101,
                kIdCmovz = 102,
                kIdCmp = 103,
                kIdCmppd = 104,
                kIdCmpps = 105,
                kIdCmps = 106,
                kIdCmpsd = 107,
                kIdCmpss = 108,
                kIdCmpxchg = 109,
                kIdCmpxchg16b = 110,
                kIdCmpxchg8b = 111,
                kIdComisd = 112,
                kIdComiss = 113,
                kIdCpuid = 114,
                kIdCqo = 115,
                kIdCrc32 = 116,
                kIdCvtdq2pd = 117,
                kIdCvtdq2ps = 118,
                kIdCvtpd2dq = 119,
                kIdCvtpd2pi = 120,
                kIdCvtpd2ps = 121,
                kIdCvtpi2pd = 122,
                kIdCvtpi2ps = 123,
                kIdCvtps2dq = 124,
                kIdCvtps2pd = 125,
                kIdCvtps2pi = 126,
                kIdCvtsd2si = 127,
                kIdCvtsd2ss = 128,
                kIdCvtsi2sd = 129,
                kIdCvtsi2ss = 130,
                kIdCvtss2sd = 131,
                kIdCvtss2si = 132,
                kIdCvttpd2dq = 133,
                kIdCvttpd2pi = 134,
                kIdCvttps2dq = 135,
                kIdCvttps2pi = 136,
                kIdCvttsd2si = 137,
                kIdCvttss2si = 138,
                kIdCwd = 139,
                kIdCwde = 140,
                kIdDaa = 141,
                kIdDas = 142,
                kIdDec = 143,
                kIdDiv = 144,
                kIdDivpd = 145,
                kIdDivps = 146,
                kIdDivsd = 147,
                kIdDivss = 148,
                kIdDppd = 149,
                kIdDpps = 150,
                kIdEmms = 151,
                kIdEnter = 152,
                kIdExtractps = 153,
                kIdExtrq = 154,
                kIdF2xm1 = 155,
                kIdFabs = 156,
                kIdFadd = 157,
                kIdFaddp = 158,
                kIdFbld = 159,
                kIdFbstp = 160,
                kIdFchs = 161,
                kIdFclex = 162,
                kIdFcmovb = 163,
                kIdFcmovbe = 164,
                kIdFcmove = 165,
                kIdFcmovnb = 166,
                kIdFcmovnbe = 167,
                kIdFcmovne = 168,
                kIdFcmovnu = 169,
                kIdFcmovu = 170,
                kIdFcom = 171,
                kIdFcomi = 172,
                kIdFcomip = 173,
                kIdFcomp = 174,
                kIdFcompp = 175,
                kIdFcos = 176,
                kIdFdecstp = 177,
                kIdFdiv = 178,
                kIdFdivp = 179,
                kIdFdivr = 180,
                kIdFdivrp = 181,
                kIdFemms = 182,
                kIdFfree = 183,
                kIdFiadd = 184,
                kIdFicom = 185,
                kIdFicomp = 186,
                kIdFidiv = 187,
                kIdFidivr = 188,
                kIdFild = 189,
                kIdFimul = 190,
                kIdFincstp = 191,
                kIdFinit = 192,
                kIdFist = 193,
                kIdFistp = 194,
                kIdFisttp = 195,
                kIdFisub = 196,
                kIdFisubr = 197,
                kIdFld = 198,
                kIdFld1 = 199,
                kIdFldcw = 200,
                kIdFldenv = 201,
                kIdFldl2e = 202,
                kIdFldl2t = 203,
                kIdFldlg2 = 204,
                kIdFldln2 = 205,
                kIdFldpi = 206,
                kIdFldz = 207,
                kIdFmul = 208,
                kIdFmulp = 209,
                kIdFnclex = 210,
                kIdFninit = 211,
                kIdFnop = 212,
                kIdFnsave = 213,
                kIdFnstcw = 214,
                kIdFnstenv = 215,
                kIdFnstsw = 216,
                kIdFpatan = 217,
                kIdFprem = 218,
                kIdFprem1 = 219,
                kIdFptan = 220,
                kIdFrndint = 221,
                kIdFrstor = 222,
                kIdFsave = 223,
                kIdFscale = 224,
                kIdFsin = 225,
                kIdFsincos = 226,
                kIdFsqrt = 227,
                kIdFst = 228,
                kIdFstcw = 229,
                kIdFstenv = 230,
                kIdFstp = 231,
                kIdFstsw = 232,
                kIdFsub = 233,
                kIdFsubp = 234,
                kIdFsubr = 235,
                kIdFsubrp = 236,
                kIdFtst = 237,
                kIdFucom = 238,
                kIdFucomi = 239,
                kIdFucomip = 240,
                kIdFucomp = 241,
                kIdFucompp = 242,
                kIdFwait = 243,
                kIdFxam = 244,
                kIdFxch = 245,
                kIdFxrstor = 246,
                kIdFxrstor64 = 247,
                kIdFxsave = 248,
                kIdFxsave64 = 249,
                kIdFxtract = 250,
                kIdFyl2x = 251,
                kIdFyl2xp1 = 252,
                kIdHaddpd = 253,
                kIdHaddps = 254,
                kIdHlt = 255,
                kIdHsubpd = 256,
                kIdHsubps = 257,
                kIdIdiv = 258,
                kIdImul = 259,
                kIdIn = 260,
                kIdInc = 261,
                kIdIns = 262,
                kIdInsertps = 263,
                kIdInsertq = 264,
                kIdInt = 265,
                kIdInt3 = 266,
                kIdInto = 267,
                kIdInvd = 268,
                kIdInvlpg = 269,
                kIdInvpcid = 270,
                kIdIret = 271,
                kIdIretd = 272,
                kIdIretq = 273,
                kIdIretw = 274,
                kIdJa = 275,
                kIdJae = 276,
                kIdJb = 277,
                kIdJbe = 278,
                kIdJc = 279,
                kIdJe = 280,
                kIdJecxz = 281,
                kIdJg = 282,
                kIdJge = 283,
                kIdJl = 284,
                kIdJle = 285,
                kIdJmp = 286,
                kIdJna = 287,
                kIdJnae = 288,
                kIdJnb = 289,
                kIdJnbe = 290,
                kIdJnc = 291,
                kIdJne = 292,
                kIdJng = 293,
                kIdJnge = 294,
                kIdJnl = 295,
                kIdJnle = 296,
                kIdJno = 297,
                kIdJnp = 298,
                kIdJns = 299,
                kIdJnz = 300,
                kIdJo = 301,
                kIdJp = 302,
                kIdJpe = 303,
                kIdJpo = 304,
                kIdJs = 305,
                kIdJz = 306,
                kIdKaddb = 307,
                kIdKaddd = 308,
                kIdKaddq = 309,
                kIdKaddw = 310,
                kIdKandb = 311,
                kIdKandd = 312,
                kIdKandnb = 313,
                kIdKandnd = 314,
                kIdKandnq = 315,
                kIdKandnw = 316,
                kIdKandq = 317,
                kIdKandw = 318,
                kIdKmovb = 319,
                kIdKmovd = 320,
                kIdKmovq = 321,
                kIdKmovw = 322,
                kIdKnotb = 323,
                kIdKnotd = 324,
                kIdKnotq = 325,
                kIdKnotw = 326,
                kIdKorb = 327,
                kIdKord = 328,
                kIdKorq = 329,
                kIdKortestb = 330,
                kIdKortestd = 331,
                kIdKortestq = 332,
                kIdKortestw = 333,
                kIdKorw = 334,
                kIdKshiftlb = 335,
                kIdKshiftld = 336,
                kIdKshiftlq = 337,
                kIdKshiftlw = 338,
                kIdKshiftrb = 339,
                kIdKshiftrd = 340,
                kIdKshiftrq = 341,
                kIdKshiftrw = 342,
                kIdKtestb = 343,
                kIdKtestd = 344,
                kIdKtestq = 345,
                kIdKtestw = 346,
                kIdKunpckbw = 347,
                kIdKunpckdq = 348,
                kIdKunpckwd = 349,
                kIdKxnorb = 350,
                kIdKxnord = 351,
                kIdKxnorq = 352,
                kIdKxnorw = 353,
                kIdKxorb = 354,
                kIdKxord = 355,
                kIdKxorq = 356,
                kIdKxorw = 357,
                kIdLahf = 358,
                kIdLar = 359,
                kIdLddqu = 360,
                kIdLdmxcsr = 361,
                kIdLds = 362,
                kIdLea = 363,
                kIdLeave = 364,
                kIdLes = 365,
                kIdLfence = 366,
                kIdLfs = 367,
                kIdLgdt = 368,
                kIdLgs = 369,
                kIdLidt = 370,
                kIdLldt = 371,
                kIdLmsw = 372,
                kIdLods = 373,
                kIdLoop = 374,
                kIdLoope = 375,
                kIdLoopne = 376,
                kIdLsl = 377,
                kIdLss = 378,
                kIdLtr = 379,
                kIdLzcnt = 380,
                kIdMaskmovdqu = 381,
                kIdMaskmovq = 382,
                kIdMaxpd = 383,
                kIdMaxps = 384,
                kIdMaxsd = 385,
                kIdMaxss = 386,
                kIdMfence = 387,
                kIdMinpd = 388,
                kIdMinps = 389,
                kIdMinsd = 390,
                kIdMinss = 391,
                kIdMonitor = 392,
                kIdMov = 393,
                kIdMovapd = 394,
                kIdMovaps = 395,
                kIdMovbe = 396,
                kIdMovd = 397,
                kIdMovddup = 398,
                kIdMovdq2q = 399,
                kIdMovdqa = 400,
                kIdMovdqu = 401,
                kIdMovhlps = 402,
                kIdMovhpd = 403,
                kIdMovhps = 404,
                kIdMovlhps = 405,
                kIdMovlpd = 406,
                kIdMovlps = 407,
                kIdMovmskpd = 408,
                kIdMovmskps = 409,
                kIdMovntdq = 410,
                kIdMovntdqa = 411,
                kIdMovnti = 412,
                kIdMovntpd = 413,
                kIdMovntps = 414,
                kIdMovntq = 415,
                kIdMovntsd = 416,
                kIdMovntss = 417,
                kIdMovq = 418,
                kIdMovq2dq = 419,
                kIdMovs = 420,
                kIdMovsd = 421,
                kIdMovshdup = 422,
                kIdMovsldup = 423,
                kIdMovss = 424,
                kIdMovsx = 425,
                kIdMovsxd = 426,
                kIdMovupd = 427,
                kIdMovups = 428,
                kIdMovzx = 429,
                kIdMpsadbw = 430,
                kIdMul = 431,
                kIdMulpd = 432,
                kIdMulps = 433,
                kIdMulsd = 434,
                kIdMulss = 435,
                kIdMulx = 436,
                kIdMwait = 437,
                kIdNeg = 438,
                kIdNop = 439,
                kIdNot = 440,
                kIdOr = 441,
                kIdOrpd = 442,
                kIdOrps = 443,
                kIdOut = 444,
                kIdOuts = 445,
                kIdPabsb = 446,
                kIdPabsd = 447,
                kIdPabsw = 448,
                kIdPackssdw = 449,
                kIdPacksswb = 450,
                kIdPackusdw = 451,
                kIdPackuswb = 452,
                kIdPaddb = 453,
                kIdPaddd = 454,
                kIdPaddq = 455,
                kIdPaddsb = 456,
                kIdPaddsw = 457,
                kIdPaddusb = 458,
                kIdPaddusw = 459,
                kIdPaddw = 460,
                kIdPalignr = 461,
                kIdPand = 462,
                kIdPandn = 463,
                kIdPause = 464,
                kIdPavgb = 465,
                kIdPavgusb = 466,
                kIdPavgw = 467,
                kIdPblendvb = 468,
                kIdPblendw = 469,
                kIdPclmulqdq = 470,
                kIdPcmpeqb = 471,
                kIdPcmpeqd = 472,
                kIdPcmpeqq = 473,
                kIdPcmpeqw = 474,
                kIdPcmpestri = 475,
                kIdPcmpestrm = 476,
                kIdPcmpgtb = 477,
                kIdPcmpgtd = 478,
                kIdPcmpgtq = 479,
                kIdPcmpgtw = 480,
                kIdPcmpistri = 481,
                kIdPcmpistrm = 482,
                kIdPcommit = 483,
                kIdPdep = 484,
                kIdPext = 485,
                kIdPextrb = 486,
                kIdPextrd = 487,
                kIdPextrq = 488,
                kIdPextrw = 489,
                kIdPf2id = 490,
                kIdPf2iw = 491,
                kIdPfacc = 492,
                kIdPfadd = 493,
                kIdPfcmpeq = 494,
                kIdPfcmpge = 495,
                kIdPfcmpgt = 496,
                kIdPfmax = 497,
                kIdPfmin = 498,
                kIdPfmul = 499,
                kIdPfnacc = 500,
                kIdPfpnacc = 501,
                kIdPfrcp = 502,
                kIdPfrcpit1 = 503,
                kIdPfrcpit2 = 504,
                kIdPfrcpv = 505,
                kIdPfrsqit1 = 506,
                kIdPfrsqrt = 507,
                kIdPfrsqrtv = 508,
                kIdPfsub = 509,
                kIdPfsubr = 510,
                kIdPhaddd = 511,
                kIdPhaddsw = 512,
                kIdPhaddw = 513,
                kIdPhminposuw = 514,
                kIdPhsubd = 515,
                kIdPhsubsw = 516,
                kIdPhsubw = 517,
                kIdPi2fd = 518,
                kIdPi2fw = 519,
                kIdPinsrb = 520,
                kIdPinsrd = 521,
                kIdPinsrq = 522,
                kIdPinsrw = 523,
                kIdPmaddubsw = 524,
                kIdPmaddwd = 525,
                kIdPmaxsb = 526,
                kIdPmaxsd = 527,
                kIdPmaxsw = 528,
                kIdPmaxub = 529,
                kIdPmaxud = 530,
                kIdPmaxuw = 531,
                kIdPminsb = 532,
                kIdPminsd = 533,
                kIdPminsw = 534,
                kIdPminub = 535,
                kIdPminud = 536,
                kIdPminuw = 537,
                kIdPmovmskb = 538,
                kIdPmovsxbd = 539,
                kIdPmovsxbq = 540,
                kIdPmovsxbw = 541,
                kIdPmovsxdq = 542,
                kIdPmovsxwd = 543,
                kIdPmovsxwq = 544,
                kIdPmovzxbd = 545,
                kIdPmovzxbq = 546,
                kIdPmovzxbw = 547,
                kIdPmovzxdq = 548,
                kIdPmovzxwd = 549,
                kIdPmovzxwq = 550,
                kIdPmuldq = 551,
                kIdPmulhrsw = 552,
                kIdPmulhrw = 553,
                kIdPmulhuw = 554,
                kIdPmulhw = 555,
                kIdPmulld = 556,
                kIdPmullw = 557,
                kIdPmuludq = 558,
                kIdPop = 559,
                kIdPopa = 560,
                kIdPopad = 561,
                kIdPopcnt = 562,
                kIdPopf = 563,
                kIdPopfd = 564,
                kIdPopfq = 565,
                kIdPor = 566,
                kIdPrefetch = 567,
                kIdPrefetchnta = 568,
                kIdPrefetcht0 = 569,
                kIdPrefetcht1 = 570,
                kIdPrefetcht2 = 571,
                kIdPrefetchw = 572,
                kIdPrefetchwt1 = 573,
                kIdPsadbw = 574,
                kIdPshufb = 575,
                kIdPshufd = 576,
                kIdPshufhw = 577,
                kIdPshuflw = 578,
                kIdPshufw = 579,
                kIdPsignb = 580,
                kIdPsignd = 581,
                kIdPsignw = 582,
                kIdPslld = 583,
                kIdPslldq = 584,
                kIdPsllq = 585,
                kIdPsllw = 586,
                kIdPsrad = 587,
                kIdPsraw = 588,
                kIdPsrld = 589,
                kIdPsrldq = 590,
                kIdPsrlq = 591,
                kIdPsrlw = 592,
                kIdPsubb = 593,
                kIdPsubd = 594,
                kIdPsubq = 595,
                kIdPsubsb = 596,
                kIdPsubsw = 597,
                kIdPsubusb = 598,
                kIdPsubusw = 599,
                kIdPsubw = 600,
                kIdPswapd = 601,
                kIdPtest = 602,
                kIdPunpckhbw = 603,
                kIdPunpckhdq = 604,
                kIdPunpckhqdq = 605,
                kIdPunpckhwd = 606,
                kIdPunpcklbw = 607,
                kIdPunpckldq = 608,
                kIdPunpcklqdq = 609,
                kIdPunpcklwd = 610,
                kIdPush = 611,
                kIdPusha = 612,
                kIdPushad = 613,
                kIdPushf = 614,
                kIdPushfd = 615,
                kIdPushfq = 616,
                kIdPxor = 617,
                kIdRcl = 618,
                kIdRcpps = 619,
                kIdRcpss = 620,
                kIdRcr = 621,
                kIdRdfsbase = 622,
                kIdRdgsbase = 623,
                kIdRdmsr = 624,
                kIdRdpmc = 625,
                kIdRdrand = 626,
                kIdRdseed = 627,
                kIdRdtsc = 628,
                kIdRdtscp = 629,
                kIdRet = 630,
                kIdRol = 631,
                kIdRor = 632,
                kIdRorx = 633,
                kIdRoundpd = 634,
                kIdRoundps = 635,
                kIdRoundsd = 636,
                kIdRoundss = 637,
                kIdRsm = 638,
                kIdRsqrtps = 639,
                kIdRsqrtss = 640,
                kIdSahf = 641,
                kIdSal = 642,
                kIdSar = 643,
                kIdSarx = 644,
                kIdSbb = 645,
                kIdScas = 646,
                kIdSeta = 647,
                kIdSetae = 648,
                kIdSetb = 649,
                kIdSetbe = 650,
                kIdSetc = 651,
                kIdSete = 652,
                kIdSetg = 653,
                kIdSetge = 654,
                kIdSetl = 655,
                kIdSetle = 656,
                kIdSetna = 657,
                kIdSetnae = 658,
                kIdSetnb = 659,
                kIdSetnbe = 660,
                kIdSetnc = 661,
                kIdSetne = 662,
                kIdSetng = 663,
                kIdSetnge = 664,
                kIdSetnl = 665,
                kIdSetnle = 666,
                kIdSetno = 667,
                kIdSetnp = 668,
                kIdSetns = 669,
                kIdSetnz = 670,
                kIdSeto = 671,
                kIdSetp = 672,
                kIdSetpe = 673,
                kIdSetpo = 674,
                kIdSets = 675,
                kIdSetz = 676,
                kIdSfence = 677,
                kIdSgdt = 678,
                kIdSha1msg1 = 679,
                kIdSha1msg2 = 680,
                kIdSha1nexte = 681,
                kIdSha1rnds4 = 682,
                kIdSha256msg1 = 683,
                kIdSha256msg2 = 684,
                kIdSha256rnds2 = 685,
                kIdShl = 686,
                kIdShld = 687,
                kIdShlx = 688,
                kIdShr = 689,
                kIdShrd = 690,
                kIdShrx = 691,
                kIdShufpd = 692,
                kIdShufps = 693,
                kIdSidt = 694,
                kIdSldt = 695,
                kIdSmsw = 696,
                kIdSqrtpd = 697,
                kIdSqrtps = 698,
                kIdSqrtsd = 699,
                kIdSqrtss = 700,
                kIdStac = 701,
                kIdStc = 702,
                kIdStd = 703,
                kIdSti = 704,
                kIdStmxcsr = 705,
                kIdStos = 706,
                kIdStr = 707,
                kIdSub = 708,
                kIdSubpd = 709,
                kIdSubps = 710,
                kIdSubsd = 711,
                kIdSubss = 712,
                kIdSwapgs = 713,
                kIdSyscall = 714,
                kIdSysenter = 715,
                kIdSysexit = 716,
                kIdSysexit64 = 717,
                kIdSysret = 718,
                kIdSysret64 = 719,
                kIdT1mskc = 720,
                kIdTest = 721,
                kIdTzcnt = 722,
                kIdTzmsk = 723,
                kIdUcomisd = 724,
                kIdUcomiss = 725,
                kIdUd2 = 726,
                kIdUnpckhpd = 727,
                kIdUnpckhps = 728,
                kIdUnpcklpd = 729,
                kIdUnpcklps = 730,
                kIdV4fmaddps = 731,
                kIdV4fnmaddps = 732,
                kIdVaddpd = 733,
                kIdVaddps = 734,
                kIdVaddsd = 735,
                kIdVaddss = 736,
                kIdVaddsubpd = 737,
                kIdVaddsubps = 738,
                kIdVaesdec = 739,
                kIdVaesdeclast = 740,
                kIdVaesenc = 741,
                kIdVaesenclast = 742,
                kIdVaesimc = 743,
                kIdVaeskeygenassist = 744,
                kIdValignd = 745,
                kIdValignq = 746,
                kIdVandnpd = 747,
                kIdVandnps = 748,
                kIdVandpd = 749,
                kIdVandps = 750,
                kIdVblendmb = 751,
                kIdVblendmd = 752,
                kIdVblendmpd = 753,
                kIdVblendmps = 754,
                kIdVblendmq = 755,
                kIdVblendmw = 756,
                kIdVblendpd = 757,
                kIdVblendps = 758,
                kIdVblendvpd = 759,
                kIdVblendvps = 760,
                kIdVbroadcastf128 = 761,
                kIdVbroadcastf32x2 = 762,
                kIdVbroadcastf32x4 = 763,
                kIdVbroadcastf32x8 = 764,
                kIdVbroadcastf64x2 = 765,
                kIdVbroadcastf64x4 = 766,
                kIdVbroadcasti128 = 767,
                kIdVbroadcasti32x2 = 768,
                kIdVbroadcasti32x4 = 769,
                kIdVbroadcasti32x8 = 770,
                kIdVbroadcasti64x2 = 771,
                kIdVbroadcasti64x4 = 772,
                kIdVbroadcastsd = 773,
                kIdVbroadcastss = 774,
                kIdVcmppd = 775,
                kIdVcmpps = 776,
                kIdVcmpsd = 777,
                kIdVcmpss = 778,
                kIdVcomisd = 779,
                kIdVcomiss = 780,
                kIdVcompresspd = 781,
                kIdVcompressps = 782,
                kIdVcvtdq2pd = 783,
                kIdVcvtdq2ps = 784,
                kIdVcvtpd2dq = 785,
                kIdVcvtpd2ps = 786,
                kIdVcvtpd2qq = 787,
                kIdVcvtpd2udq = 788,
                kIdVcvtpd2uqq = 789,
                kIdVcvtph2ps = 790,
                kIdVcvtps2dq = 791,
                kIdVcvtps2pd = 792,
                kIdVcvtps2ph = 793,
                kIdVcvtps2qq = 794,
                kIdVcvtps2udq = 795,
                kIdVcvtps2uqq = 796,
                kIdVcvtqq2pd = 797,
                kIdVcvtqq2ps = 798,
                kIdVcvtsd2si = 799,
                kIdVcvtsd2ss = 800,
                kIdVcvtsd2usi = 801,
                kIdVcvtsi2sd = 802,
                kIdVcvtsi2ss = 803,
                kIdVcvtss2sd = 804,
                kIdVcvtss2si = 805,
                kIdVcvtss2usi = 806,
                kIdVcvttpd2dq = 807,
                kIdVcvttpd2qq = 808,
                kIdVcvttpd2udq = 809,
                kIdVcvttpd2uqq = 810,
                kIdVcvttps2dq = 811,
                kIdVcvttps2qq = 812,
                kIdVcvttps2udq = 813,
                kIdVcvttps2uqq = 814,
                kIdVcvttsd2si = 815,
                kIdVcvttsd2usi = 816,
                kIdVcvttss2si = 817,
                kIdVcvttss2usi = 818,
                kIdVcvtudq2pd = 819,
                kIdVcvtudq2ps = 820,
                kIdVcvtuqq2pd = 821,
                kIdVcvtuqq2ps = 822,
                kIdVcvtusi2sd = 823,
                kIdVcvtusi2ss = 824,
                kIdVdbpsadbw = 825,
                kIdVdivpd = 826,
                kIdVdivps = 827,
                kIdVdivsd = 828,
                kIdVdivss = 829,
                kIdVdppd = 830,
                kIdVdpps = 831,
                kIdVerr = 832,
                kIdVerw = 833,
                kIdVexp2pd = 834,
                kIdVexp2ps = 835,
                kIdVexpandpd = 836,
                kIdVexpandps = 837,
                kIdVextractf128 = 838,
                kIdVextractf32x4 = 839,
                kIdVextractf32x8 = 840,
                kIdVextractf64x2 = 841,
                kIdVextractf64x4 = 842,
                kIdVextracti128 = 843,
                kIdVextracti32x4 = 844,
                kIdVextracti32x8 = 845,
                kIdVextracti64x2 = 846,
                kIdVextracti64x4 = 847,
                kIdVextractps = 848,
                kIdVfixupimmpd = 849,
                kIdVfixupimmps = 850,
                kIdVfixupimmsd = 851,
                kIdVfixupimmss = 852,
                kIdVfmadd132pd = 853,
                kIdVfmadd132ps = 854,
                kIdVfmadd132sd = 855,
                kIdVfmadd132ss = 856,
                kIdVfmadd213pd = 857,
                kIdVfmadd213ps = 858,
                kIdVfmadd213sd = 859,
                kIdVfmadd213ss = 860,
                kIdVfmadd231pd = 861,
                kIdVfmadd231ps = 862,
                kIdVfmadd231sd = 863,
                kIdVfmadd231ss = 864,
                kIdVfmaddpd = 865,
                kIdVfmaddps = 866,
                kIdVfmaddsd = 867,
                kIdVfmaddss = 868,
                kIdVfmaddsub132pd = 869,
                kIdVfmaddsub132ps = 870,
                kIdVfmaddsub213pd = 871,
                kIdVfmaddsub213ps = 872,
                kIdVfmaddsub231pd = 873,
                kIdVfmaddsub231ps = 874,
                kIdVfmaddsubpd = 875,
                kIdVfmaddsubps = 876,
                kIdVfmsub132pd = 877,
                kIdVfmsub132ps = 878,
                kIdVfmsub132sd = 879,
                kIdVfmsub132ss = 880,
                kIdVfmsub213pd = 881,
                kIdVfmsub213ps = 882,
                kIdVfmsub213sd = 883,
                kIdVfmsub213ss = 884,
                kIdVfmsub231pd = 885,
                kIdVfmsub231ps = 886,
                kIdVfmsub231sd = 887,
                kIdVfmsub231ss = 888,
                kIdVfmsubadd132pd = 889,
                kIdVfmsubadd132ps = 890,
                kIdVfmsubadd213pd = 891,
                kIdVfmsubadd213ps = 892,
                kIdVfmsubadd231pd = 893,
                kIdVfmsubadd231ps = 894,
                kIdVfmsubaddpd = 895,
                kIdVfmsubaddps = 896,
                kIdVfmsubpd = 897,
                kIdVfmsubps = 898,
                kIdVfmsubsd = 899,
                kIdVfmsubss = 900,
                kIdVfnmadd132pd = 901,
                kIdVfnmadd132ps = 902,
                kIdVfnmadd132sd = 903,
                kIdVfnmadd132ss = 904,
                kIdVfnmadd213pd = 905,
                kIdVfnmadd213ps = 906,
                kIdVfnmadd213sd = 907,
                kIdVfnmadd213ss = 908,
                kIdVfnmadd231pd = 909,
                kIdVfnmadd231ps = 910,
                kIdVfnmadd231sd = 911,
                kIdVfnmadd231ss = 912,
                kIdVfnmaddpd = 913,
                kIdVfnmaddps = 914,
                kIdVfnmaddsd = 915,
                kIdVfnmaddss = 916,
                kIdVfnmsub132pd = 917,
                kIdVfnmsub132ps = 918,
                kIdVfnmsub132sd = 919,
                kIdVfnmsub132ss = 920,
                kIdVfnmsub213pd = 921,
                kIdVfnmsub213ps = 922,
                kIdVfnmsub213sd = 923,
                kIdVfnmsub213ss = 924,
                kIdVfnmsub231pd = 925,
                kIdVfnmsub231ps = 926,
                kIdVfnmsub231sd = 927,
                kIdVfnmsub231ss = 928,
                kIdVfnmsubpd = 929,
                kIdVfnmsubps = 930,
                kIdVfnmsubsd = 931,
                kIdVfnmsubss = 932,
                kIdVfpclasspd = 933,
                kIdVfpclassps = 934,
                kIdVfpclasssd = 935,
                kIdVfpclassss = 936,
                kIdVfrczpd = 937,
                kIdVfrczps = 938,
                kIdVfrczsd = 939,
                kIdVfrczss = 940,
                kIdVgatherdpd = 941,
                kIdVgatherdps = 942,
                kIdVgatherpf0dpd = 943,
                kIdVgatherpf0dps = 944,
                kIdVgatherpf0qpd = 945,
                kIdVgatherpf0qps = 946,
                kIdVgatherpf1dpd = 947,
                kIdVgatherpf1dps = 948,
                kIdVgatherpf1qpd = 949,
                kIdVgatherpf1qps = 950,
                kIdVgatherqpd = 951,
                kIdVgatherqps = 952,
                kIdVgetexppd = 953,
                kIdVgetexpps = 954,
                kIdVgetexpsd = 955,
                kIdVgetexpss = 956,
                kIdVgetmantpd = 957,
                kIdVgetmantps = 958,
                kIdVgetmantsd = 959,
                kIdVgetmantss = 960,
                kIdVhaddpd = 961,
                kIdVhaddps = 962,
                kIdVhsubpd = 963,
                kIdVhsubps = 964,
                kIdVinsertf128 = 965,
                kIdVinsertf32x4 = 966,
                kIdVinsertf32x8 = 967,
                kIdVinsertf64x2 = 968,
                kIdVinsertf64x4 = 969,
                kIdVinserti128 = 970,
                kIdVinserti32x4 = 971,
                kIdVinserti32x8 = 972,
                kIdVinserti64x2 = 973,
                kIdVinserti64x4 = 974,
                kIdVinsertps = 975,
                kIdVlddqu = 976,
                kIdVldmxcsr = 977,
                kIdVmaskmovdqu = 978,
                kIdVmaskmovpd = 979,
                kIdVmaskmovps = 980,
                kIdVmaxpd = 981,
                kIdVmaxps = 982,
                kIdVmaxsd = 983,
                kIdVmaxss = 984,
                kIdVminpd = 985,
                kIdVminps = 986,
                kIdVminsd = 987,
                kIdVminss = 988,
                kIdVmovapd = 989,
                kIdVmovaps = 990,
                kIdVmovd = 991,
                kIdVmovddup = 992,
                kIdVmovdqa = 993,
                kIdVmovdqa32 = 994,
                kIdVmovdqa64 = 995,
                kIdVmovdqu = 996,
                kIdVmovdqu16 = 997,
                kIdVmovdqu32 = 998,
                kIdVmovdqu64 = 999,
                kIdVmovdqu8 = 1000,
                kIdVmovhlps = 1001,
                kIdVmovhpd = 1002,
                kIdVmovhps = 1003,
                kIdVmovlhps = 1004,
                kIdVmovlpd = 1005,
                kIdVmovlps = 1006,
                kIdVmovmskpd = 1007,
                kIdVmovmskps = 1008,
                kIdVmovntdq = 1009,
                kIdVmovntdqa = 1010,
                kIdVmovntpd = 1011,
                kIdVmovntps = 1012,
                kIdVmovq = 1013,
                kIdVmovsd = 1014,
                kIdVmovshdup = 1015,
                kIdVmovsldup = 1016,
                kIdVmovss = 1017,
                kIdVmovupd = 1018,
                kIdVmovups = 1019,
                kIdVmpsadbw = 1020,
                kIdVmulpd = 1021,
                kIdVmulps = 1022,
                kIdVmulsd = 1023,
                kIdVmulss = 1024,
                kIdVorpd = 1025,
                kIdVorps = 1026,
                kIdVp4dpwssd = 1027,
                kIdVp4dpwssds = 1028,
                kIdVpabsb = 1029,
                kIdVpabsd = 1030,
                kIdVpabsq = 1031,
                kIdVpabsw = 1032,
                kIdVpackssdw = 1033,
                kIdVpacksswb = 1034,
                kIdVpackusdw = 1035,
                kIdVpackuswb = 1036,
                kIdVpaddb = 1037,
                kIdVpaddd = 1038,
                kIdVpaddq = 1039,
                kIdVpaddsb = 1040,
                kIdVpaddsw = 1041,
                kIdVpaddusb = 1042,
                kIdVpaddusw = 1043,
                kIdVpaddw = 1044,
                kIdVpalignr = 1045,
                kIdVpand = 1046,
                kIdVpandd = 1047,
                kIdVpandn = 1048,
                kIdVpandnd = 1049,
                kIdVpandnq = 1050,
                kIdVpandq = 1051,
                kIdVpavgb = 1052,
                kIdVpavgw = 1053,
                kIdVpblendd = 1054,
                kIdVpblendvb = 1055,
                kIdVpblendw = 1056,
                kIdVpbroadcastb = 1057,
                kIdVpbroadcastd = 1058,
                kIdVpbroadcastmb2d = 1059,
                kIdVpbroadcastmb2q = 1060,
                kIdVpbroadcastq = 1061,
                kIdVpbroadcastw = 1062,
                kIdVpclmulqdq = 1063,
                kIdVpcmov = 1064,
                kIdVpcmpb = 1065,
                kIdVpcmpd = 1066,
                kIdVpcmpeqb = 1067,
                kIdVpcmpeqd = 1068,
                kIdVpcmpeqq = 1069,
                kIdVpcmpeqw = 1070,
                kIdVpcmpestri = 1071,
                kIdVpcmpestrm = 1072,
                kIdVpcmpgtb = 1073,
                kIdVpcmpgtd = 1074,
                kIdVpcmpgtq = 1075,
                kIdVpcmpgtw = 1076,
                kIdVpcmpistri = 1077,
                kIdVpcmpistrm = 1078,
                kIdVpcmpq = 1079,
                kIdVpcmpub = 1080,
                kIdVpcmpud = 1081,
                kIdVpcmpuq = 1082,
                kIdVpcmpuw = 1083,
                kIdVpcmpw = 1084,
                kIdVpcomb = 1085,
                kIdVpcomd = 1086,
                kIdVpcompressd = 1087,
                kIdVpcompressq = 1088,
                kIdVpcomq = 1089,
                kIdVpcomub = 1090,
                kIdVpcomud = 1091,
                kIdVpcomuq = 1092,
                kIdVpcomuw = 1093,
                kIdVpcomw = 1094,
                kIdVpconflictd = 1095,
                kIdVpconflictq = 1096,
                kIdVperm2f128 = 1097,
                kIdVperm2i128 = 1098,
                kIdVpermb = 1099,
                kIdVpermd = 1100,
                kIdVpermi2b = 1101,
                kIdVpermi2d = 1102,
                kIdVpermi2pd = 1103,
                kIdVpermi2ps = 1104,
                kIdVpermi2q = 1105,
                kIdVpermi2w = 1106,
                kIdVpermil2pd = 1107,
                kIdVpermil2ps = 1108,
                kIdVpermilpd = 1109,
                kIdVpermilps = 1110,
                kIdVpermpd = 1111,
                kIdVpermps = 1112,
                kIdVpermq = 1113,
                kIdVpermt2b = 1114,
                kIdVpermt2d = 1115,
                kIdVpermt2pd = 1116,
                kIdVpermt2ps = 1117,
                kIdVpermt2q = 1118,
                kIdVpermt2w = 1119,
                kIdVpermw = 1120,
                kIdVpexpandd = 1121,
                kIdVpexpandq = 1122,
                kIdVpextrb = 1123,
                kIdVpextrd = 1124,
                kIdVpextrq = 1125,
                kIdVpextrw = 1126,
                kIdVpgatherdd = 1127,
                kIdVpgatherdq = 1128,
                kIdVpgatherqd = 1129,
                kIdVpgatherqq = 1130,
                kIdVphaddbd = 1131,
                kIdVphaddbq = 1132,
                kIdVphaddbw = 1133,
                kIdVphaddd = 1134,
                kIdVphadddq = 1135,
                kIdVphaddsw = 1136,
                kIdVphaddubd = 1137,
                kIdVphaddubq = 1138,
                kIdVphaddubw = 1139,
                kIdVphaddudq = 1140,
                kIdVphadduwd = 1141,
                kIdVphadduwq = 1142,
                kIdVphaddw = 1143,
                kIdVphaddwd = 1144,
                kIdVphaddwq = 1145,
                kIdVphminposuw = 1146,
                kIdVphsubbw = 1147,
                kIdVphsubd = 1148,
                kIdVphsubdq = 1149,
                kIdVphsubsw = 1150,
                kIdVphsubw = 1151,
                kIdVphsubwd = 1152,
                kIdVpinsrb = 1153,
                kIdVpinsrd = 1154,
                kIdVpinsrq = 1155,
                kIdVpinsrw = 1156,
                kIdVplzcntd = 1157,
                kIdVplzcntq = 1158,
                kIdVpmacsdd = 1159,
                kIdVpmacsdqh = 1160,
                kIdVpmacsdql = 1161,
                kIdVpmacssdd = 1162,
                kIdVpmacssdqh = 1163,
                kIdVpmacssdql = 1164,
                kIdVpmacsswd = 1165,
                kIdVpmacssww = 1166,
                kIdVpmacswd = 1167,
                kIdVpmacsww = 1168,
                kIdVpmadcsswd = 1169,
                kIdVpmadcswd = 1170,
                kIdVpmadd52huq = 1171,
                kIdVpmadd52luq = 1172,
                kIdVpmaddubsw = 1173,
                kIdVpmaddwd = 1174,
                kIdVpmaskmovd = 1175,
                kIdVpmaskmovq = 1176,
                kIdVpmaxsb = 1177,
                kIdVpmaxsd = 1178,
                kIdVpmaxsq = 1179,
                kIdVpmaxsw = 1180,
                kIdVpmaxub = 1181,
                kIdVpmaxud = 1182,
                kIdVpmaxuq = 1183,
                kIdVpmaxuw = 1184,
                kIdVpminsb = 1185,
                kIdVpminsd = 1186,
                kIdVpminsq = 1187,
                kIdVpminsw = 1188,
                kIdVpminub = 1189,
                kIdVpminud = 1190,
                kIdVpminuq = 1191,
                kIdVpminuw = 1192,
                kIdVpmovb2m = 1193,
                kIdVpmovd2m = 1194,
                kIdVpmovdb = 1195,
                kIdVpmovdw = 1196,
                kIdVpmovm2b = 1197,
                kIdVpmovm2d = 1198,
                kIdVpmovm2q = 1199,
                kIdVpmovm2w = 1200,
                kIdVpmovmskb = 1201,
                kIdVpmovq2m = 1202,
                kIdVpmovqb = 1203,
                kIdVpmovqd = 1204,
                kIdVpmovqw = 1205,
                kIdVpmovsdb = 1206,
                kIdVpmovsdw = 1207,
                kIdVpmovsqb = 1208,
                kIdVpmovsqd = 1209,
                kIdVpmovsqw = 1210,
                kIdVpmovswb = 1211,
                kIdVpmovsxbd = 1212,
                kIdVpmovsxbq = 1213,
                kIdVpmovsxbw = 1214,
                kIdVpmovsxdq = 1215,
                kIdVpmovsxwd = 1216,
                kIdVpmovsxwq = 1217,
                kIdVpmovusdb = 1218,
                kIdVpmovusdw = 1219,
                kIdVpmovusqb = 1220,
                kIdVpmovusqd = 1221,
                kIdVpmovusqw = 1222,
                kIdVpmovuswb = 1223,
                kIdVpmovw2m = 1224,
                kIdVpmovwb = 1225,
                kIdVpmovzxbd = 1226,
                kIdVpmovzxbq = 1227,
                kIdVpmovzxbw = 1228,
                kIdVpmovzxdq = 1229,
                kIdVpmovzxwd = 1230,
                kIdVpmovzxwq = 1231,
                kIdVpmuldq = 1232,
                kIdVpmulhrsw = 1233,
                kIdVpmulhuw = 1234,
                kIdVpmulhw = 1235,
                kIdVpmulld = 1236,
                kIdVpmullq = 1237,
                kIdVpmullw = 1238,
                kIdVpmultishiftqb = 1239,
                kIdVpmuludq = 1240,
                kIdVpopcntd = 1241,
                kIdVpopcntq = 1242,
                kIdVpor = 1243,
                kIdVpord = 1244,
                kIdVporq = 1245,
                kIdVpperm = 1246,
                kIdVprold = 1247,
                kIdVprolq = 1248,
                kIdVprolvd = 1249,
                kIdVprolvq = 1250,
                kIdVprord = 1251,
                kIdVprorq = 1252,
                kIdVprorvd = 1253,
                kIdVprorvq = 1254,
                kIdVprotb = 1255,
                kIdVprotd = 1256,
                kIdVprotq = 1257,
                kIdVprotw = 1258,
                kIdVpsadbw = 1259,
                kIdVpscatterdd = 1260,
                kIdVpscatterdq = 1261,
                kIdVpscatterqd = 1262,
                kIdVpscatterqq = 1263,
                kIdVpshab = 1264,
                kIdVpshad = 1265,
                kIdVpshaq = 1266,
                kIdVpshaw = 1267,
                kIdVpshlb = 1268,
                kIdVpshld = 1269,
                kIdVpshlq = 1270,
                kIdVpshlw = 1271,
                kIdVpshufb = 1272,
                kIdVpshufd = 1273,
                kIdVpshufhw = 1274,
                kIdVpshuflw = 1275,
                kIdVpsignb = 1276,
                kIdVpsignd = 1277,
                kIdVpsignw = 1278,
                kIdVpslld = 1279,
                kIdVpslldq = 1280,
                kIdVpsllq = 1281,
                kIdVpsllvd = 1282,
                kIdVpsllvq = 1283,
                kIdVpsllvw = 1284,
                kIdVpsllw = 1285,
                kIdVpsrad = 1286,
                kIdVpsraq = 1287,
                kIdVpsravd = 1288,
                kIdVpsravq = 1289,
                kIdVpsravw = 1290,
                kIdVpsraw = 1291,
                kIdVpsrld = 1292,
                kIdVpsrldq = 1293,
                kIdVpsrlq = 1294,
                kIdVpsrlvd = 1295,
                kIdVpsrlvq = 1296,
                kIdVpsrlvw = 1297,
                kIdVpsrlw = 1298,
                kIdVpsubb = 1299,
                kIdVpsubd = 1300,
                kIdVpsubq = 1301,
                kIdVpsubsb = 1302,
                kIdVpsubsw = 1303,
                kIdVpsubusb = 1304,
                kIdVpsubusw = 1305,
                kIdVpsubw = 1306,
                kIdVpternlogd = 1307,
                kIdVpternlogq = 1308,
                kIdVptest = 1309,
                kIdVptestmb = 1310,
                kIdVptestmd = 1311,
                kIdVptestmq = 1312,
                kIdVptestmw = 1313,
                kIdVptestnmb = 1314,
                kIdVptestnmd = 1315,
                kIdVptestnmq = 1316,
                kIdVptestnmw = 1317,
                kIdVpunpckhbw = 1318,
                kIdVpunpckhdq = 1319,
                kIdVpunpckhqdq = 1320,
                kIdVpunpckhwd = 1321,
                kIdVpunpcklbw = 1322,
                kIdVpunpckldq = 1323,
                kIdVpunpcklqdq = 1324,
                kIdVpunpcklwd = 1325,
                kIdVpxor = 1326,
                kIdVpxord = 1327,
                kIdVpxorq = 1328,
                kIdVrangepd = 1329,
                kIdVrangeps = 1330,
                kIdVrangesd = 1331,
                kIdVrangess = 1332,
                kIdVrcp14pd = 1333,
                kIdVrcp14ps = 1334,
                kIdVrcp14sd = 1335,
                kIdVrcp14ss = 1336,
                kIdVrcp28pd = 1337,
                kIdVrcp28ps = 1338,
                kIdVrcp28sd = 1339,
                kIdVrcp28ss = 1340,
                kIdVrcpps = 1341,
                kIdVrcpss = 1342,
                kIdVreducepd = 1343,
                kIdVreduceps = 1344,
                kIdVreducesd = 1345,
                kIdVreducess = 1346,
                kIdVrndscalepd = 1347,
                kIdVrndscaleps = 1348,
                kIdVrndscalesd = 1349,
                kIdVrndscaless = 1350,
                kIdVroundpd = 1351,
                kIdVroundps = 1352,
                kIdVroundsd = 1353,
                kIdVroundss = 1354,
                kIdVrsqrt14pd = 1355,
                kIdVrsqrt14ps = 1356,
                kIdVrsqrt14sd = 1357,
                kIdVrsqrt14ss = 1358,
                kIdVrsqrt28pd = 1359,
                kIdVrsqrt28ps = 1360,
                kIdVrsqrt28sd = 1361,
                kIdVrsqrt28ss = 1362,
                kIdVrsqrtps = 1363,
                kIdVrsqrtss = 1364,
                kIdVscalefpd = 1365,
                kIdVscalefps = 1366,
                kIdVscalefsd = 1367,
                kIdVscalefss = 1368,
                kIdVscatterdpd = 1369,
                kIdVscatterdps = 1370,
                kIdVscatterpf0dpd = 1371,
                kIdVscatterpf0dps = 1372,
                kIdVscatterpf0qpd = 1373,
                kIdVscatterpf0qps = 1374,
                kIdVscatterpf1dpd = 1375,
                kIdVscatterpf1dps = 1376,
                kIdVscatterpf1qpd = 1377,
                kIdVscatterpf1qps = 1378,
                kIdVscatterqpd = 1379,
                kIdVscatterqps = 1380,
                kIdVshuff32x4 = 1381,
                kIdVshuff64x2 = 1382,
                kIdVshufi32x4 = 1383,
                kIdVshufi64x2 = 1384,
                kIdVshufpd = 1385,
                kIdVshufps = 1386,
                kIdVsqrtpd = 1387,
                kIdVsqrtps = 1388,
                kIdVsqrtsd = 1389,
                kIdVsqrtss = 1390,
                kIdVstmxcsr = 1391,
                kIdVsubpd = 1392,
                kIdVsubps = 1393,
                kIdVsubsd = 1394,
                kIdVsubss = 1395,
                kIdVtestpd = 1396,
                kIdVtestps = 1397,
                kIdVucomisd = 1398,
                kIdVucomiss = 1399,
                kIdVunpckhpd = 1400,
                kIdVunpckhps = 1401,
                kIdVunpcklpd = 1402,
                kIdVunpcklps = 1403,
                kIdVxorpd = 1404,
                kIdVxorps = 1405,
                kIdVzeroall = 1406,
                kIdVzeroupper = 1407,
                kIdWbinvd = 1408,
                kIdWrfsbase = 1409,
                kIdWrgsbase = 1410,
                kIdWrmsr = 1411,
                kIdXabort = 1412,
                kIdXadd = 1413,
                kIdXbegin = 1414,
                kIdXchg = 1415,
                kIdXend = 1416,
                kIdXgetbv = 1417,
                kIdXlatb = 1418,
                kIdXor = 1419,
                kIdXorpd = 1420,
                kIdXorps = 1421,
                kIdXrstor = 1422,
                kIdXrstor64 = 1423,
                kIdXrstors = 1424,
                kIdXrstors64 = 1425,
                kIdXsave = 1426,
                kIdXsave64 = 1427,
                kIdXsavec = 1428,
                kIdXsavec64 = 1429,
                kIdXsaveopt = 1430,
                kIdXsaveopt64 = 1431,
                kIdXsaves = 1432,
                kIdXsaves64 = 1433,
                kIdXsetbv = 1434,
                kIdXtest = 1435,
                KIdCount = 1436
            }

            /// <summary>Instruction encodings, used by</summary>
            public enum EncodingType : uint
            {
                /// <summary>Never used.</summary>
                kEncodingNone = 0,
                /// <summary>X86 [OP].</summary>
                kEncodingX86Op = 1,
                /// <summary>X86 [OP] (opcode and /0-7).</summary>
                kEncodingX86OpO = 2,
                /// <summary>X86 [OP] (opcode and /0-7 + 8-bit immediate).</summary>
                kEncodingX86OpO_I8 = 3,
                /// <summary>X86 [OP] (implicit or explicit '?AX' form).</summary>
                kEncodingX86OpXAX = 4,
                /// <summary>X86 [OP] (implicit or explicit '?DX, ?AX' form).</summary>
                kEncodingX86OpXDX_xAX = 5,
                /// <summary>X86 [OP] (implicit or explicit '[EAX|RDX]' form).</summary>
                kEncodingX86OpZAX = 6,
                /// <summary>X86 [I] (implicit or explicit '?AX' form).</summary>
                kEncodingX86I_xAX = 7,
                /// <summary>X86 [M] (handles 2|4|8-bytes size).</summary>
                kEncodingX86M = 8,
                /// <summary>X86 [M] (handles single-byte size).</summary>
                kEncodingX86M_GPB = 9,
                /// <summary>X86 [M] (like GPB, handles implicit|explicit MUL|DIV|IDIV).</summary>
                kEncodingX86M_GPB_MulDiv = 10,
                /// <summary>X86 [M] (restricted to memory operand of any size).</summary>
                kEncodingX86M_Only = 11,
                /// <summary>X86 [RM] (doesn't handle single-byte size).</summary>
                kEncodingX86Rm = 12,
                /// <summary>X86 [RM] (used by LZCNT, POPCNT, and TZCNT).</summary>
                kEncodingX86RmRaw66H = 13,
                /// <summary>X86 [RM] (doesn't add REX.W prefix if 64-bit reg is used).</summary>
                kEncodingX86RmNoRexW = 14,
                /// <summary>X86 [MR] (doesn't handle single-byte size).</summary>
                kEncodingX86Mr = 15,
                /// <summary>X86 [MR] (doesn't handle any size).</summary>
                kEncodingX86MrNoSize = 16,
                /// <summary>X86 adc, add, and, cmp, or, sbb, sub, xor.</summary>
                kEncodingX86Arith = 17,
                /// <summary>X86 bswap.</summary>
                kEncodingX86Bswap = 18,
                /// <summary>X86 bt, btc, btr, bts.</summary>
                kEncodingX86Bt = 19,
                /// <summary>X86 call.</summary>
                kEncodingX86Call = 20,
                /// <summary>X86 [MR] cmpxchg.</summary>
                kEncodingX86Cmpxchg = 21,
                /// <summary>X86 crc32.</summary>
                kEncodingX86Crc = 22,
                /// <summary>X86 enter.</summary>
                kEncodingX86Enter = 23,
                /// <summary>X86 imul.</summary>
                kEncodingX86Imul = 24,
                /// <summary>X86 in.</summary>
                kEncodingX86In = 25,
                /// <summary>X86 ins[b|q|d].</summary>
                kEncodingX86Ins = 26,
                /// <summary>X86 inc, dec.</summary>
                kEncodingX86IncDec = 27,
                /// <summary>X86 int (interrupt).</summary>
                kEncodingX86Int = 28,
                /// <summary>X86 jcc.</summary>
                kEncodingX86Jcc = 29,
                /// <summary>X86 jcxz, jecxz, jrcxz, loop, loope, loopne.</summary>
                kEncodingX86JecxzLoop = 30,
                /// <summary>X86 jmp.</summary>
                kEncodingX86Jmp = 31,
                /// <summary>X86 xbegin.</summary>
                kEncodingX86JmpRel = 32,
                /// <summary>X86 lea.</summary>
                kEncodingX86Lea = 33,
                /// <summary>X86 mov (all possible cases).</summary>
                kEncodingX86Mov = 34,
                /// <summary>X86 movsx, movzx.</summary>
                kEncodingX86MovsxMovzx = 35,
                /// <summary>X86 out.</summary>
                kEncodingX86Out = 36,
                /// <summary>X86 out[b|q|d].</summary>
                kEncodingX86Outs = 37,
                /// <summary>X86 push.</summary>
                kEncodingX86Push = 38,
                /// <summary>X86 pop.</summary>
                kEncodingX86Pop = 39,
                /// <summary>X86 ret.</summary>
                kEncodingX86Ret = 40,
                /// <summary>X86 rcl, rcr, rol, ror, sal, sar, shl, shr.</summary>
                kEncodingX86Rot = 41,
                /// <summary>X86 setcc.</summary>
                kEncodingX86Set = 42,
                /// <summary>X86 shld, shrd.</summary>
                kEncodingX86ShldShrd = 43,
                /// <summary>X86 lods.</summary>
                kEncodingX86StrRm = 44,
                /// <summary>X86 scas, stos.</summary>
                kEncodingX86StrMr = 45,
                /// <summary>X86 cmps, movs.</summary>
                kEncodingX86StrMm = 46,
                /// <summary>X86 test.</summary>
                kEncodingX86Test = 47,
                /// <summary>X86 xadd.</summary>
                kEncodingX86Xadd = 48,
                /// <summary>X86 xchg.</summary>
                kEncodingX86Xchg = 49,
                /// <summary>X86 lfence, mfence, sfence.</summary>
                kEncodingX86Fence = 50,
                /// <summary>X86 [RM|MR] (used by BNDMOV).</summary>
                kEncodingX86Bndmov = 51,
                /// <summary>FPU [OP].</summary>
                kEncodingFpuOp = 52,
                /// <summary>FPU fadd, fdiv, fdivr, fmul, fsub, fsubr.</summary>
                kEncodingFpuArith = 53,
                /// <summary>FPU fcom, fcomp.</summary>
                kEncodingFpuCom = 54,
                /// <summary>FPU fld, fst, fstp.</summary>
                kEncodingFpuFldFst = 55,
                /// <summary>FPU fiadd, ficom, ficomp, fidiv, fidivr, fild, fimul, fist, fistp, fisttp, fisub, fisubr.</summary>
                kEncodingFpuM = 56,
                /// <summary>FPU fcmov, fcomi, fcomip, ffree, fucom, fucomi, fucomip, fucomp, fxch.</summary>
                kEncodingFpuR = 57,
                /// <summary>FPU faddp, fdivp, fdivrp, fmulp, fsubp, fsubrp.</summary>
                kEncodingFpuRDef = 58,
                /// <summary>FPU fnstsw, Fstsw.</summary>
                kEncodingFpuStsw = 59,
                /// <summary>EXT [RM].</summary>
                kEncodingExtRm = 60,
                /// <summary>EXT [RM].</summary>
                kEncodingExtRmXMM0 = 61,
                /// <summary>EXT [RM].</summary>
                kEncodingExtRmZDI = 62,
                /// <summary>EXT [RM] (propagates 66H if the instruction uses XMM register).</summary>
                kEncodingExtRmP = 63,
                /// <summary>EXT [RM] (propagates REX.W if GPQ is used).</summary>
                kEncodingExtRmWx = 64,
                /// <summary>EXT [RM|RI].</summary>
                kEncodingExtRmRi = 65,
                /// <summary>EXT [RM|RI] (propagates 66H if the instruction uses XMM register).</summary>
                kEncodingExtRmRiP = 66,
                /// <summary>EXT [RMI].</summary>
                kEncodingExtRmi = 67,
                /// <summary>EXT [RMI] (propagates 66H if the instruction uses XMM register).</summary>
                kEncodingExtRmiP = 68,
                /// <summary>EXT pextrw.</summary>
                kEncodingExtPextrw = 69,
                /// <summary>EXT pextrb, pextrd, pextrq, extractps.</summary>
                kEncodingExtExtract = 70,
                /// <summary>EXT mov?? - #1:[MM|XMM, MM|XMM|Mem] #2:[MM|XMM|Mem, MM|XMM].</summary>
                kEncodingExtMov = 71,
                /// <summary>EXT movnti.</summary>
                kEncodingExtMovnti = 72,
                /// <summary>EXT movbe.</summary>
                kEncodingExtMovbe = 73,
                /// <summary>EXT movd.</summary>
                kEncodingExtMovd = 74,
                /// <summary>EXT movq.</summary>
                kEncodingExtMovq = 75,
                /// <summary>EXT extrq (SSE4A).</summary>
                kEncodingExtExtrq = 76,
                /// <summary>EXT insrq (SSE4A).</summary>
                kEncodingExtInsertq = 77,
                /// <summary>EXT [RMI] (3DNOW specific).</summary>
                kEncodingExt3dNow = 78,
                /// <summary>VEX [OP].</summary>
                kEncodingVexOp = 79,
                /// <summary>VEX [RM|MR] (used by kmov[b|w|d|q]).</summary>
                kEncodingVexKmov = 80,
                /// <summary>VEX|EVEX [M].</summary>
                kEncodingVexM = 81,
                /// <summary>VEX|EVEX [M] (propagates VEX|EVEX.L, VSIB support).</summary>
                kEncodingVexM_VM = 82,
                /// <summary>VEX|EVEX [MR] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexMrLx = 83,
                /// <summary>VEX|EVEX [MR] (propagates VEX|EVEX.L, VSIB support).</summary>
                kEncodingVexMrVM = 84,
                /// <summary>VEX|EVEX [MRI].</summary>
                kEncodingVexMri = 85,
                /// <summary>VEX|EVEX [MRI] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexMriLx = 86,
                /// <summary>VEX|EVEX [RM].</summary>
                kEncodingVexRm = 87,
                /// <summary>VEX|EVEX [RM].</summary>
                kEncodingVexRmZDI = 88,
                /// <summary>VEX|EVEX [RM] (propagates VEX|EVEX.W if GPQ used).</summary>
                kEncodingVexRmWx = 89,
                /// <summary>VEX|EVEX [RM] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRmLx = 90,
                /// <summary>VEX|EVEX [RM] (propagates VEX|EVEX.L, VSIB support).</summary>
                kEncodingVexRmVM = 91,
                /// <summary>EVEX [RM] (used by NN instructions that use RM-T1_4X encoding).</summary>
                kEncodingVexRmT1_4X = 92,
                /// <summary>VEX|EVEX [RMI].</summary>
                kEncodingVexRmi = 93,
                /// <summary>VEX|EVEX [RMI] (propagates VEX|EVEX.W if GPQ used).</summary>
                kEncodingVexRmiWx = 94,
                /// <summary>VEX|EVEX [RMI] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRmiLx = 95,
                /// <summary>VEX|EVEX [RVM].</summary>
                kEncodingVexRvm = 96,
                /// <summary>VEX|EVEX [RVM] (propagates VEX|EVEX.W if GPQ used).</summary>
                kEncodingVexRvmWx = 97,
                /// <summary>VEX|EVEX [RVM] (propagates VEX|EVEX.W if GPQ used).</summary>
                kEncodingVexRvmZDX_Wx = 98,
                /// <summary>VEX|EVEX [RVM] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRvmLx = 99,
                /// <summary>VEX|EVEX [RVMR].</summary>
                kEncodingVexRvmr = 100,
                /// <summary>VEX|EVEX [RVMR] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRvmrLx = 101,
                /// <summary>VEX|EVEX [RVMI].</summary>
                kEncodingVexRvmi = 102,
                /// <summary>VEX|EVEX [RVMI] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRvmiLx = 103,
                /// <summary>VEX|EVEX [RMV].</summary>
                kEncodingVexRmv = 104,
                /// <summary>VEX|EVEX [RMV] (propagates VEX|EVEX.W if GPQ used).</summary>
                kEncodingVexRmvWx = 105,
                /// <summary>VEX|EVEX [RMV] (propagates VEX|EVEX.L, VSIB support).</summary>
                kEncodingVexRmvVM = 106,
                /// <summary>VEX|EVEX [RMV|RM] (propagates VEX|EVEX.L, VSIB support).</summary>
                kEncodingVexRmvRmVM = 107,
                /// <summary>VEX|EVEX [RMVI].</summary>
                kEncodingVexRmvi = 108,
                /// <summary>VEX|EVEX [RM|MR].</summary>
                kEncodingVexRmMr = 109,
                /// <summary>VEX|EVEX [RM|MR] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRmMrLx = 110,
                /// <summary>VEX|EVEX [RVM|RMV].</summary>
                kEncodingVexRvmRmv = 111,
                /// <summary>VEX|EVEX [RVM|RMI].</summary>
                kEncodingVexRvmRmi = 112,
                /// <summary>VEX|EVEX [RVM|RMI] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRvmRmiLx = 113,
                /// <summary>VEX|EVEX [RVM|RMV|RMI].</summary>
                kEncodingVexRvmRmvRmi = 114,
                /// <summary>VEX|EVEX [RVM|MR].</summary>
                kEncodingVexRvmMr = 115,
                /// <summary>VEX|EVEX [RVM|MVR].</summary>
                kEncodingVexRvmMvr = 116,
                /// <summary>VEX|EVEX [RVM|MVR] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRvmMvrLx = 117,
                /// <summary>VEX|EVEX [RVM|VMI].</summary>
                kEncodingVexRvmVmi = 118,
                /// <summary>VEX|EVEX [RVM|VMI] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRvmVmiLx = 119,
                /// <summary>VEX|EVEX [VM].</summary>
                kEncodingVexVm = 120,
                /// <summary>VEX|EVEX [VM] (propagates VEX|EVEX.W if GPQ used).</summary>
                kEncodingVexVmWx = 121,
                /// <summary>VEX|EVEX [VMI].</summary>
                kEncodingVexVmi = 122,
                /// <summary>VEX|EVEX [VMI] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexVmiLx = 123,
                /// <summary>VEX|EVEX [VMI] (special, used by vpsrldq and vpslldq)</summary>
                kEncodingVexEvexVmiLx = 124,
                /// <summary>VEX|EVEX [RVRM|RVMR].</summary>
                kEncodingVexRvrmRvmr = 125,
                /// <summary>VEX|EVEX [RVRM|RVMR] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRvrmRvmrLx = 126,
                /// <summary>VEX|EVEX [RVRMI|RVMRI] (propagates VEX|EVEX.L if YMM used).</summary>
                kEncodingVexRvrmiRvmriLx = 127,
                /// <summary>VEX|EVEX vmovd, vmovq.</summary>
                kEncodingVexMovdMovq = 128,
                /// <summary>VEX|EVEX vmovss, vmovsd.</summary>
                kEncodingVexMovssMovsd = 129,
                /// <summary>FMA4 [R, R, R/M, R/M].</summary>
                kEncodingFma4 = 130,
                /// <summary>FMA4 [R, R, R/M, R/M] (propagates AVX.L if YMM used).</summary>
                kEncodingFma4Lx = 131,
                /// <summary>Count of instruction encodings.</summary>
                KEncodingCount = 132
            }

            /// <summary>Describes a meaning of all bits of AsmJit's 32-bit opcode (AsmJit specific).</summary>
            /// <remarks>
            /// <para>This schema is AsmJit specific and has been designed to allow encoding of</para>
            /// <para>all X86 instructions available. X86, MMX, and SSE+ instructions always use</para>
            /// <para>`MM` and `PP` fields, which are encoded to corresponding prefixes needed</para>
            /// <para>by X86 or SIMD instructions. AVX+ instructions embed `MMMMM` and `PP` fields</para>
            /// <para>in a VEX prefix, and AVX-512 instructions embed `MM` and `PP` in EVEX prefix.</para>
            /// <para>The instruction opcode definition uses 1 or 2 bytes as an opcode value. 1</para>
            /// <para>byte is needed by most of the instructions, 2 bytes are only used by legacy</para>
            /// <para>X87-FPU instructions. This means that a second byte is free to by used by</para>
            /// <para>instructions encoded by using VEX and/or EVEX prefix.</para>
            /// <para>The fields description:</para>
            /// <para>- `MM` field is used to encode prefixes needed by the instruction or as</para>
            /// <para>a part of VEX/EVEX prefix. Described as `mm` and `mmmmm` in instruction</para>
            /// <para>manuals.</para>
            /// <para>NOTE: Since `MM` field is defined as `mmmmm` (5 bits), but only 2 least</para>
            /// <para>significant bits are used by VEX and EVEX prefixes, and additional 4th</para>
            /// <para>bit is used by XOP prefix, AsmJit uses the 3rd and 5th bit for it's own</para>
            /// <para>purposes. These bits will probably never be used in future encodings as</para>
            /// <para>AVX512 uses only `000mm` from `mmmmm`.</para>
            /// <para>- `PP` field is used to encode prefixes needed by the instruction or as a</para>
            /// <para>part of VEX/EVEX prefix. Described as `pp` in instruction manuals.</para>
            /// <para>- `LL` field is used exclusively by AVX+ and AVX512+ instruction sets. It</para>
            /// <para>describes vector size, which is `L.128` for XMM register, `L.256` for</para>
            /// <para>for YMM register, and `L.512` for ZMM register. The `LL` field is omitted</para>
            /// <para>in case that instruction supports multiple vector lengths, however, if the</para>
            /// <para>instruction requires specific `L` value it must be specified as a part of</para>
            /// <para>the opcode.</para>
            /// <para>NOTE: `LL` having value `11` is not defined yet.</para>
            /// <para>- `W` field is the most complicated. It was added by 64-bit architecture</para>
            /// <para>to promote default operation width (instructions that perform 32-bit</para>
            /// <para>operation by default require to override the width to 64-bit explicitly).</para>
            /// <para>There is nothing wrong on this, however, some instructions introduced</para>
            /// <para>implicit `W` override, for example a `cdqe` instruction is basically a</para>
            /// <para>`cwde` instruction with overridden `W` (set to 1). There are some others</para>
            /// <para>in the base X86 instruction set. More recent instruction sets started</para>
            /// <para>using `W` field more often:</para>
            /// <para>- AVX instructions started using `W` field as an extended opcode for FMA,</para>
            /// <para>GATHER, PERM, and other instructions. It also uses `W` field to override</para>
            /// <para>the default operation width in instructions like `vmovq`.</para>
            /// <para>- AVX-512 instructions started using `W` field as an extended opcode for</para>
            /// <para>all new instructions. This wouldn't have been an issue if the `W` field</para>
            /// <para>of AVX-512 have matched AVX, but this is not always the case.</para>
            /// <para>- `O` field is an extended opcode field (3 bits) embedded in ModR/M BYTE.</para>
            /// <para>- `CDSHL` and `CDTT` fields describe 'compressed-displacement'. `CDSHL` is</para>
            /// <para>defined for each instruction that is AVX-512 encodable (EVEX) and contains</para>
            /// <para>a base N shift (base shift to perform the calculation). The `CDTT` field</para>
            /// <para>is derived from instruction specification and describes additional shift</para>
            /// <para>to calculate the final `CDSHL` that will be used in SIB byte.</para>
            /// <para>NOTE: Don't reorder any fields here, the shifts and masks were defined</para>
            /// <para>carefully to make encoding of X86|X64 instructions fast, especially to</para>
            /// <para>construct REX, VEX, and EVEX prefixes in the most efficient way. Changing</para>
            /// <para>values defined by these enums many cause AsmJit to emit invalid binary</para>
            /// <para>representations of instructions passed to `X86Assembler::_emit`.</para>
            /// </remarks>
            public enum OpCodeBits : uint
            {
                kOpCodeMM_Shift = 8,
                kOpCodeMM_Mask = 0x1f00,
                kOpCodeMM_00 = 0x0,
                kOpCodeMM_0F = 0x100,
                kOpCodeMM_0F38 = 0x200,
                kOpCodeMM_0F3A = 0x300,
                kOpCodeMM_0F01 = 0x400,
                kOpCodeMM_XOP08 = 0x800,
                kOpCodeMM_XOP09 = 0x900,
                kOpCodeMM_IsXOP_Shift = 11,
                kOpCodeMM_IsXOP = 2048,
                kOpCodeMM_ForceVex3 = 0x400,
                kOpCodeMM_ForceEvex = 0x1000,
                kOpCodeFPU_2B_Shift = 10,
                kOpCodeFPU_2B_Mask = 0x3fc00,
                kOpCodeCDSHL_Shift = 13,
                kOpCodeCDSHL_Mask = 0xe000,
                kOpCodeCDTT_Shift = 16,
                kOpCodeCDTT_Mask = 0x30000,
                kOpCodeCDTT_None = 0x0,
                kOpCodeCDTT_ByLL = 0x10000,
                kOpCodeCDTT_T1W = 0x20000,
                kOpCodeCDTT_DUP = 0x30000,
                kOpCodeCDTT_FV = 65536,
                kOpCodeCDTT_HV = 65536,
                kOpCodeCDTT_FVM = 65536,
                kOpCodeCDTT_T1S = 0,
                kOpCodeCDTT_T1F = 0,
                kOpCodeCDTT_T1_4X = 0,
                kOpCodeCDTT_T2 = 0,
                kOpCodeCDTT_T4 = 0,
                kOpCodeCDTT_T8 = 0,
                kOpCodeCDTT_HVM = 65536,
                kOpCodeCDTT_QVM = 65536,
                kOpCodeCDTT_OVM = 65536,
                kOpCodeCDTT_128 = 0,
                kOpCodeO_Shift = 18,
                kOpCodeO_Mask = 0x1c0000,
                kOpCodePP_Shift = 21,
                kOpCodePP_VEXMask = 0x600000,
                kOpCodePP_FPUMask = 0xe00000,
                kOpCodePP_00 = 0x0,
                kOpCodePP_66 = 0x200000,
                kOpCodePP_F3 = 0x400000,
                kOpCodePP_F2 = 0x600000,
                kOpCodePP_9B = 0xe00000,
                kOpCodeEW_Shift = 24,
                kOpCodeEW = 0x1000000,
                kOpCodeREX_Shift = 25,
                kOpCodeREX_Mask = 0x1e000000,
                kOpCodeB = 0x2000000,
                kOpCodeX = 0x4000000,
                kOpCodeR = 0x8000000,
                kOpCodeW = 0x10000000,
                kOpCodeW_Shift = 28,
                kOpCodeLL_Shift = 29,
                kOpCodeLL_Mask = 0x60000000,
                kOpCodeLL_128 = 0x0,
                kOpCodeLL_256 = 0x20000000,
                kOpCodeLL_512 = 0x40000000
            }

            /// <summary>Instruction flags.</summary>
            /// <remarks>Details about instruction encoding, operation, features, and some limitations.</remarks>
            public enum Flags : uint
            {
                /// <summary>No flags.</summary>
                kFlagNone = 0x0,
                /// <summary>Use flags are 'A'mbiguous as USE information couldn't be flattened.</summary>
                kFlagUseA = 0x1,
                /// <summary>1st operand is R (read), read-only if `kFlagOpW` isn't set.</summary>
                kFlagUseR = 0x2,
                /// <summary>1st operand is W (written), write-only if `kFlagOpR` isn't set.</summary>
                kFlagUseW = 0x4,
                /// <summary>1st operand is X (read-write).</summary>
                kFlagUseX = 0x6,
                /// <summary>1st and 2nd operands are XX (read&amp;written) (XCHG, XADD).</summary>
                kFlagUseXX = 0x8,
                /// <summary>Some operand uses fixed register.</summary>
                kFlagFixedReg = 0x10,
                /// <summary>Some operand uses fixed register to access memory (EAX|RAX, EDI|RDI, ESI|RSI).</summary>
                kFlagFixedMem = 0x20,
                /// <summary>Combination of `kFlagUseFixedReg` and `kFlagUseFixedMem`.</summary>
                kFlagFixedRM = 0x30,
                /// <summary>Instruction that accesses FPU registers.</summary>
                kFlagFpu = 0x100,
                /// <summary>Instruction that accesses MMX registers (including 3DNOW and GEODE) and EMMS.</summary>
                kFlagMmx = 0x200,
                /// <summary>Instruction that accesses XMM registers (SSE, AVX, AVX512).</summary>
                kFlagVec = 0x400,
                /// <summary>Instruction can be prefixed by using the REP/REPZ/REPE prefix.</summary>
                kFlagRep = 0x1000,
                /// <summary>Instruction can be prefixed by using the REPNZ/REPNE prefix.</summary>
                kFlagRepnz = 0x2000,
                /// <summary>Instruction can be prefixed by using the LOCK prefix.</summary>
                kFlagLock = 0x4000,
                /// <summary>Instruction can be prefixed by using the XACQUIRE prefix.</summary>
                kFlagXAcquire = 0x8000,
                /// <summary>Instruction can be prefixed by using the XRELEASE prefix.</summary>
                kFlagXRelease = 0x10000,
                /// <summary>Instruction uses MIB (BNDLDX|BNDSTX) to encode two registers.</summary>
                kFlagMib = 0x20000,
                /// <summary>Instruction uses VSIB instead of legacy SIB.</summary>
                kFlagVsib = 0x40000,
                /// <summary>Instruction can be encoded by VEX|XOP (AVX|AVX2|BMI|XOP|...).</summary>
                kFlagVex = 0x80000,
                /// <summary>Instruction can be encoded by EVEX (AVX512).</summary>
                kFlagEvex = 0x100000,
                /// <summary>FPU instruction can address `word_ptr` (shared with M10).</summary>
                kFlagFpuM16 = 0x200000,
                /// <summary>FPU instruction can address `dword_ptr`.</summary>
                kFlagFpuM32 = 0x400000,
                /// <summary>FPU instruction can address `qword_ptr`.</summary>
                kFlagFpuM64 = 0x800000,
                /// <summary>FPU instruction can address `tword_ptr` (shared with M2).</summary>
                kFlagFpuM80 = 0x200000,
                /// <summary>Internally used in tables, has no meaning.</summary>
                kFlagAvx512 = 0x0,
                /// <summary>Supports masking {k0..k7}.</summary>
                kFlagAvx512K = 0x1000000,
                /// <summary>Supports zeroing {z}, must be used together with `kAvx512k`.</summary>
                kFlagAvx512Z = 0x2000000,
                /// <summary>Supports 'embedded-rounding' {er} with implicit {sae},</summary>
                kFlagAvx512ER = 0x4000000,
                /// <summary>Supports 'suppress-all-exceptions' {sae}.</summary>
                kFlagAvx512SAE = 0x8000000,
                /// <summary>Supports 32-bit broadcast 'b32'.</summary>
                kFlagAvx512B32 = 0x10000000,
                /// <summary>Supports 64-bit broadcast 'b64'.</summary>
                kFlagAvx512B64 = 0x20000000,
                /// <summary>Operates on a vector of consecutive registers (AVX512_4FMAPS and AVX512_4VNNIW).</summary>
                kFlagAvx512T4X = 0x80000000,
                kFlagAvx512KZ = 50331648,
                kFlagAvx512ER_SAE = 201326592,
                kFlagAvx512KZ_SAE = 184549376,
                kFlagAvx512KZ_SAE_B32 = 452984832,
                kFlagAvx512KZ_SAE_B64 = 721420288,
                kFlagAvx512KZ_ER_SAE = 251658240,
                kFlagAvx512KZ_ER_SAE_B32 = 520093696,
                kFlagAvx512KZ_ER_SAE_B64 = 788529152,
                kFlagAvx512K_B32 = 285212672,
                kFlagAvx512K_B64 = 553648128,
                kFlagAvx512KZ_B32 = 318767104,
                kFlagAvx512KZ_B64 = 587202560
            }

            /// <summary>Used to describe what the instruction does and some of its quirks.</summary>
            public enum OperationFlags
            {
                /// <summary>`MOV REG&lt;&gt;-&gt; CREG|DREG` - OS|SF|ZF|AF|PF|CF flags are undefined.</summary>
                kOperationMovCrDr = 1,
                /// <summary>`MOVSS|MOVSD XMM, [MEM]` - Sestination operand is completely overwritten.</summary>
                kOperationMovSsSd = 2,
                /// <summary>Instruction does hardware prefetch.</summary>
                kOperationPrefetch = 268435456,
                /// <summary>Instruction acts as a barrier / fence.</summary>
                kOperationBarrier = 536870912,
                /// <summary>Hint for instruction schedulers to never reorder this instruction (side effects, memory barrier, etc).</summary>
                kOperationVolatile = 1073741824,
                /// <summary>This is a privileged operation that cannot run in user mode (system instruction).</summary>
                kOperationPrivileged = -2147483648
            }

            /// <summary>SSE to AVX conversion mode.</summary>
            public enum SseToAvxMode
            {
                /// <summary>No conversion possible.</summary>
                kSseToAvxNone = 0,
                /// <summary>No change (no operands changed).</summary>
                kSseToAvxMove = 1,
                /// <summary>No change if the second operand is mem, extend otherwise.</summary>
                kSseToAvxMoveIfMem = 2,
                /// <summary>The first SSE operand becomes first and second AVX operand.</summary>
                kSseToAvxExtend = 3,
                /// <summary>Special case for 'vblendvpd', 'vblendvps', and 'vpblendvb'.</summary>
                kSseToAvxBlend = 4
            }

            /// <summary>Instruction options (AsmJit specific).</summary>
            public enum Options : uint
            {
                kOptionOp4Op5Used = 8,
                /// <summary>Emit short-form of the instruction.</summary>
                kOptionShortForm = 0x40,
                /// <summary>Emit long-form of the instruction.</summary>
                kOptionLongForm = 0x80,
                /// <summary>Conditional jump is likely to be taken.</summary>
                kOptionTaken = 0x100,
                /// <summary>Conditional jump is unlikely to be taken.</summary>
                kOptionNotTaken = 0x200,
                /// <summary>Use 3-byte VEX prefix if possible (AVX) (must be 0x00000400).</summary>
                kOptionVex3 = 0x400,
                /// <summary>Use ModMR instead of ModRM when it's available.</summary>
                kOptionModMR = 0x800,
                /// <summary>Use 4-byte EVEX prefix if possible (AVX-512) (must be 0x00001000).</summary>
                kOptionEvex = 0x1000,
                /// <summary>LOCK prefix (lock-enabled instructions only).</summary>
                kOptionLock = 0x2000,
                /// <summary>REP/REPZ prefix (string instructions only).</summary>
                kOptionRep = 0x4000,
                /// <summary>REPNZ prefix (string instructions only).</summary>
                kOptionRepnz = 0x8000,
                /// <summary>XACQUIRE prefix (only allowed instructions).</summary>
                kOptionXAcquire = 0x10000,
                /// <summary>XRELEASE prefix (only allowed instructions).</summary>
                kOptionXRelease = 0x20000,
                /// <summary>AVX-512: 'embedded-rounding' {er} and {sae}.</summary>
                kOptionER = 0x40000,
                /// <summary>AVX-512: 'suppress-all-exceptions' {sae}.</summary>
                kOptionSAE = 0x80000,
                /// <summary>AVX-512: broadcast the first element to all {1tox}.</summary>
                kOption1ToX = 0x100000,
                /// <summary>AVX-512: round-to-nearest (even)      {rn-sae} (bits 00).</summary>
                kOptionRN_SAE = 0x0,
                /// <summary>AVX-512: round-down (toward -inf)     {rd-sae} (bits 01).</summary>
                kOptionRD_SAE = 0x200000,
                /// <summary>AVX-512: round-up (toward +inf)       {ru-sae} (bits 10).</summary>
                kOptionRU_SAE = 0x400000,
                /// <summary>AVX-512: round-toward-zero (truncate) {rz-sae} (bits 11).</summary>
                kOptionRZ_SAE = 0x600000,
                /// <summary>AVX-512: Use zeroing {k}{z} instead of merging {k}.</summary>
                kOptionZMask = 0x800000,
                /// <summary>AVX-512: Mask of all possible AVX-512 options except EVEX prefix flag.</summary>
                KOptionAvx512Mask = 0xfc0000,
                /// <summary>REX prefix can't be emitted (internal).</summary>
                KOptionInvalidRex = 0x1000000,
                /// <summary>REX.B and/or VEX.B field (X64).</summary>
                kOptionOpCodeB = 0x2000000,
                /// <summary>REX.X and/or VEX.X field (X64).</summary>
                kOptionOpCodeX = 0x4000000,
                /// <summary>REX.R and/or VEX.R field (X64).</summary>
                kOptionOpCodeR = 0x8000000,
                /// <summary>REX.W and/or VEX.W field (X64).</summary>
                kOptionOpCodeW = 0x10000000,
                /// <summary>Use REX prefix (X64) (must be 0x80000000).</summary>
                kOptionRex = 0x80000000
            }

            /// <summary>Supported architectures.</summary>
            public enum ArchMask : uint
            {
                /// <summary>X86 mode supported.</summary>
                kArchMaskX86 = 0x1,
                /// <summary>X64 mode supported.</summary>
                kArchMaskX64 = 0x2
            }

            public enum SingleRegCase : uint
            {
                /// <summary>No special handling.</summary>
                kSingleRegNone = 0,
                /// <summary>Operands become read-only  - `REG&amp;REG` and similar.</summary>
                kSingleRegRO = 1,
                /// <summary>Operands become write-only - `REG ^ REG` and similar.</summary>
                kSingleRegWO = 2
            }

            /// <summary>Instruction's operand flags.</summary>
            public enum OpFlags : uint
            {
                /// <summary>No operand.</summary>
                kOpNone = 0x0,
                /// <summary>Operand can be a low 8-bit GPB register.</summary>
                kOpGpbLo = 0x1,
                /// <summary>Operand can be a high 8-bit GPB register.</summary>
                kOpGpbHi = 0x2,
                /// <summary>Operand can be a 16-bit GPW register.</summary>
                kOpGpw = 0x4,
                /// <summary>Operand can be a 32-bit GPD register.</summary>
                kOpGpd = 0x8,
                /// <summary>Operand can be a 64-bit GPQ register.</summary>
                kOpGpq = 0x10,
                /// <summary>Operand can be an FPU register.</summary>
                kOpFp = 0x20,
                /// <summary>Operand can be a 64-bit MM register.</summary>
                kOpMm = 0x40,
                /// <summary>Operand can be a 64-bit K register.</summary>
                kOpK = 0x80,
                /// <summary>Operand can be a control register.</summary>
                kOpCr = 0x100,
                /// <summary>Operand can be a debug register.</summary>
                kOpDr = 0x200,
                /// <summary>Operand can be a BND register.</summary>
                kOpBnd = 0x400,
                /// <summary>Operand can be a segment register.</summary>
                kOpSeg = 0x800,
                /// <summary>Operand can be a 128-bit XMM register.</summary>
                kOpXmm = 0x1000,
                /// <summary>Operand can be a 256-bit YMM register.</summary>
                kOpYmm = 0x2000,
                /// <summary>Operand can be a 512-bit ZMM register.</summary>
                kOpZmm = 0x4000,
                /// <summary>Combination of all possible registers.</summary>
                kOpAllRegs = 0x7fff,
                /// <summary>Operand can be a scalar memory pointer.</summary>
                kOpMem = 0x10000,
                /// <summary>Operand can be a vector memory pointer.</summary>
                kOpVm = 0x20000,
                /// <summary>Operand can be unsigned 4-bit  immediate.</summary>
                kOpU4 = 0x40000,
                /// <summary>Operand can be signed   8-bit  immediate.</summary>
                kOpI8 = 0x80000,
                /// <summary>Operand can be unsigned 8-bit  immediate.</summary>
                kOpU8 = 0x100000,
                /// <summary>Operand can be signed   16-bit immediate.</summary>
                kOpI16 = 0x200000,
                /// <summary>Operand can be unsigned 16-bit immediate.</summary>
                kOpU16 = 0x400000,
                /// <summary>Operand can be signed   32-bit immediate.</summary>
                kOpI32 = 0x800000,
                /// <summary>Operand can be unsigned 32-bit immediate.</summary>
                kOpU32 = 0x1000000,
                /// <summary>Operand can be signed   64-bit immediate.</summary>
                kOpI64 = 0x2000000,
                /// <summary>Operand can be unsigned 64-bit immediate.</summary>
                kOpU64 = 0x4000000,
                /// <summary>Operand can be any immediate.</summary>
                kOpAllImm = 0x7fc0000,
                /// <summary>Operand can be relative 8-bit  displacement.</summary>
                kOpRel8 = 0x8000000,
                /// <summary>Operand can be relative 32-bit displacement.</summary>
                kOpRel32 = 0x10000000,
                /// <summary>Operand is read.</summary>
                kOpR = 0x20000000,
                /// <summary>Operand is written.</summary>
                kOpW = 0x40000000,
                /// <summary>Operand is read&amp;written.</summary>
                kOpX = 0x60000000,
                /// <summary>Operand is implicit.</summary>
                kOpImplicit = 0x80000000
            }

            /// <summary>Instruction's memory operand flags.</summary>
            [Flags]
            public enum MemOpFlags : uint
            {
                /// <summary>Operand can be an 8-bit memory pointer.</summary>
                kMemOpM8 = 0x1,
                /// <summary>Operand can be a 16-bit memory pointer.</summary>
                kMemOpM16 = 0x2,
                /// <summary>Operand can be a 32-bit memory pointer.</summary>
                kMemOpM32 = 0x4,
                /// <summary>Operand can be a 32-bit memory pointer.</summary>
                kMemOpM48 = 0x8,
                /// <summary>Operand can be a 64-bit memory pointer.</summary>
                kMemOpM64 = 0x10,
                /// <summary>Operand can be an 80-bit memory pointer.</summary>
                kMemOpM80 = 0x20,
                /// <summary>Operand can be a 128-bit memory pointer.</summary>
                kMemOpM128 = 0x40,
                /// <summary>Operand can be a 256-bit memory pointer.</summary>
                kMemOpM256 = 0x80,
                /// <summary>Operand can be a 512-bit memory pointer.</summary>
                kMemOpM512 = 0x100,
                /// <summary>Operand can be a 1024-bit memory pointer.</summary>
                kMemOpM1024 = 0x200,
                /// <summary>Operand can be a vm32x (vector) pointer.</summary>
                kMemOpVm32x = 0x1,
                /// <summary>Operand can be a vm32y (vector) pointer.</summary>
                kMemOpVm32y = 0x2,
                /// <summary>Operand can be a vm32z (vector) pointer.</summary>
                kMemOpVm32z = 0x4,
                /// <summary>Operand can be a vm64x (vector) pointer.</summary>
                kMemOpVm64x = 0x10,
                /// <summary>Operand can be a vm64y (vector) pointer.</summary>
                kMemOpVm64y = 0x20,
                /// <summary>Operand can be a vm64z (vector) pointer.</summary>
                kMemOpVm64z = 0x40,
                /// <summary>Only memory base is allowed (no index, no offset).</summary>
                kMemOpBaseOnly = 0x800,
                /// <summary>Implicit memory operand's DS segment.</summary>
                kMemOpDs = 0x1000,
                /// <summary>Implicit memory operand's ES segment.</summary>
                kMemOpEs = 0x2000,
                /// <summary>Operand must be MIB (base+index) pointer.</summary>
                kMemOpMib = 0x4000,
                /// <summary>Operand can be any scalar memory pointer.</summary>
                kMemOpAny = 0x8000
            }

            /// <summary>Instruction signature.</summary>
            /// <remarks>
            /// <para>Contains a sequence of operands' combinations and other metadata that defines</para>
            /// <para>a single instruction. This data is used by instruction validator.</para>
            /// </remarks>
            public unsafe partial class ISignature : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal byte opCount;

                    [FieldOffset(0)]
                    internal byte archMask;

                    [FieldOffset(0)]
                    internal byte @implicit;

                    [FieldOffset(1)]
                    internal byte reserved;

                    [FieldOffset(2)]
                    internal fixed byte operands[6];

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ISignature@X86Inst@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ISignature(global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ISignature(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ISignature()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public ISignature(global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            /// <summary>Operand signature, used by</summary>
            /// <remarks>
            /// <para>Contains all possible operand combinations, memory size information,</para>
            /// <para>and register index (or</para>
            /// </remarks>
            public unsafe partial class OSignature : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint flags;

                    [FieldOffset(4)]
                    internal ushort memFlags;

                    [FieldOffset(6)]
                    internal byte extFlags;

                    [FieldOffset(7)]
                    internal byte regMask;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0OSignature@X86Inst@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private OSignature(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected OSignature(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public OSignature()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public OSignature(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.OSignature __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            /// <summary>Common data - aggregated data that is shared across many instructions.</summary>
            public unsafe partial class CommonData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint _flags;

                    [FieldOffset(4)]
                    internal uint _writeIndex;

                    [FieldOffset(5)]
                    internal uint _writeSize;

                    [FieldOffset(8)]
                    internal uint _altOpCodeIndex;

                    [FieldOffset(9)]
                    internal uint _iSignatureIndex;

                    [FieldOffset(10)]
                    internal uint _iSignatureCount;

                    [FieldOffset(10)]
                    internal uint _jumpType;

                    [FieldOffset(11)]
                    internal uint _singleRegCase;

                    [FieldOffset(11)]
                    internal uint _reserved;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0CommonData@X86Inst@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasFlag@CommonData@X86Inst@asmjit@@QEBA_NI@Z")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasFlag(global::System.IntPtr instance, uint flag);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?doesJump@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool DoesJump(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFlags@CommonData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetFlags(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isUseR@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsUseR(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isUseW@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsUseW(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isUseX@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsUseX(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isUseXX@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsUseXX(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasFixedReg@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasFixedReg(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasFixedMem@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasFixedMem(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasFixedRM@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasFixedRM(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isFpu@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsFpu(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isMmx@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsMmx(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isVec@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsVec(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isSse@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsSse(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isAvx@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsAvx(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isLockEnabled@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsLockEnabled(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isRepEnabled@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsRepEnabled(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isRepzEnabled@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsRepzEnabled(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isRepnzEnabled@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsRepnzEnabled(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isMibOp@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsMibOp(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isVsibOp@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsVsibOp(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isVex@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsVex(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isEvex@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsEvex(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isVexOrEvex@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsVexOrEvex(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasAvx512K@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasAvx512K(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasAvx512Z@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasAvx512Z(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasAvx512ER@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasAvx512ER(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasAvx512SAE@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasAvx512SAE(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasAvx512B@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasAvx512B(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasAvx512B32@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasAvx512B32(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasAvx512B64@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasAvx512B64(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getWriteIndex@CommonData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetWriteIndex(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getWriteSize@CommonData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetWriteSize(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasAltOpCode@CommonData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasAltOpCode(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getAltOpCode@CommonData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetAltOpCode(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getISignatureIndex@CommonData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetISignatureIndex(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getISignatureCount@CommonData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetISignatureCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getISignatureData@CommonData@X86Inst@asmjit@@QEBAPEBUISignature@23@XZ")]
                    internal static extern global::System.IntPtr GetISignatureData(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getISignatureEnd@CommonData@X86Inst@asmjit@@QEBAPEBUISignature@23@XZ")]
                    internal static extern global::System.IntPtr GetISignatureEnd(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getJumpType@CommonData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetJumpType(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSingleRegCase@CommonData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetSingleRegCase(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CommonData(global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CommonData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CommonData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public CommonData(global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                /// <summary>Get if the instruction has a `flag`, see</summary>
                public bool HasFlag(uint flag)
                {
                    var __ret = __Internal.HasFlag((__Instance + __PointerAdjustment), flag);
                    return __ret;
                }

                /// <summary>Get if the instruction may or will jump (returns true also for calls and returns).</summary>
                public bool DoesJump()
                {
                    var __ret = __Internal.DoesJump((__Instance + __PointerAdjustment));
                    return __ret;
                }

                /// <summary>Get all instruction flags, see</summary>
                public uint Flags
                {
                    get
                    {
                        var __ret = __Internal.GetFlags((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if 1st operand is read-only.</summary>
                public bool IsUseR
                {
                    get
                    {
                        var __ret = __Internal.IsUseR((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if 1st operand is write-only.</summary>
                public bool IsUseW
                {
                    get
                    {
                        var __ret = __Internal.IsUseW((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if 1st operand is read-write.</summary>
                public bool IsUseX
                {
                    get
                    {
                        var __ret = __Internal.IsUseX((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if 1st and 2nd operands are read-write.</summary>
                public bool IsUseXX
                {
                    get
                    {
                        var __ret = __Internal.IsUseXX((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool HasFixedReg
                {
                    get
                    {
                        var __ret = __Internal.HasFixedReg((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool HasFixedMem
                {
                    get
                    {
                        var __ret = __Internal.HasFixedMem((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool HasFixedRM
                {
                    get
                    {
                        var __ret = __Internal.HasFixedRM((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction is FPU instruction.</summary>
                public bool IsFpu
                {
                    get
                    {
                        var __ret = __Internal.IsFpu((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction is MMX|3DNOW instruction that accesses MMX registers (includes EMMS).</summary>
                public bool IsMmx
                {
                    get
                    {
                        var __ret = __Internal.IsMmx((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction is SSE|AVX|AVX512 instruction that accesses XMM|YMM|ZMM registers (includes VZEROALL|VZEROUPPER).</summary>
                public bool IsVec
                {
                    get
                    {
                        var __ret = __Internal.IsVec((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction is SSE+ (SSE4.2, AES, SHA included) instruction that accesses XMM registers.</summary>
                public bool IsSse
                {
                    get
                    {
                        var __ret = __Internal.IsSse((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction is AVX+ (FMA included) instruction that accesses XMM|YMM|ZMM registers.</summary>
                public bool IsAvx
                {
                    get
                    {
                        var __ret = __Internal.IsAvx((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction can be prefixed by LOCK prefix.</summary>
                public bool IsLockEnabled
                {
                    get
                    {
                        var __ret = __Internal.IsLockEnabled((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction can be prefixed by REP prefix.</summary>
                public bool IsRepEnabled
                {
                    get
                    {
                        var __ret = __Internal.IsRepEnabled((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction can be prefixed by REPZ prefix.</summary>
                public bool IsRepzEnabled
                {
                    get
                    {
                        var __ret = __Internal.IsRepzEnabled((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction can be prefixed by REPNZ prefix.</summary>
                public bool IsRepnzEnabled
                {
                    get
                    {
                        var __ret = __Internal.IsRepnzEnabled((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction uses MIB.</summary>
                public bool IsMibOp
                {
                    get
                    {
                        var __ret = __Internal.IsMibOp((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction uses VSIB.</summary>
                public bool IsVsibOp
                {
                    get
                    {
                        var __ret = __Internal.IsVsibOp((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction uses VEX (can be set together with EVEX if both are encodable).</summary>
                public bool IsVex
                {
                    get
                    {
                        var __ret = __Internal.IsVex((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction uses EVEX (can be set together with VEX if both are encodable).</summary>
                public bool IsEvex
                {
                    get
                    {
                        var __ret = __Internal.IsEvex((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction uses VEX and/or EVEX.</summary>
                public bool IsVexOrEvex
                {
                    get
                    {
                        var __ret = __Internal.IsVexOrEvex((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction supports AVX512 masking {k}.</summary>
                public bool HasAvx512K
                {
                    get
                    {
                        var __ret = __Internal.HasAvx512K((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction supports AVX512 zeroing {k}{z}.</summary>
                public bool HasAvx512Z
                {
                    get
                    {
                        var __ret = __Internal.HasAvx512Z((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction supports AVX512 embedded-rounding {er}.</summary>
                public bool HasAvx512ER
                {
                    get
                    {
                        var __ret = __Internal.HasAvx512ER((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction supports AVX512 suppress-all-exceptions {sae}.</summary>
                public bool HasAvx512SAE
                {
                    get
                    {
                        var __ret = __Internal.HasAvx512SAE((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction supports AVX512 broadcast (either 32-bit or 64-bit).</summary>
                public bool HasAvx512B
                {
                    get
                    {
                        var __ret = __Internal.HasAvx512B((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction supports AVX512 broadcast (32-bit).</summary>
                public bool HasAvx512B32
                {
                    get
                    {
                        var __ret = __Internal.HasAvx512B32((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction supports AVX512 broadcast (64-bit).</summary>
                public bool HasAvx512B64
                {
                    get
                    {
                        var __ret = __Internal.HasAvx512B64((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get the destination index of WRITE operation.</summary>
                public uint WriteIndex
                {
                    get
                    {
                        var __ret = __Internal.GetWriteIndex((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get the number of bytes that will be written by a WRITE operation.</summary>
                /// <remarks>
                /// <para>This information is required by a liveness analysis to mark virtual</para>
                /// <para>registers dead even if the instruction doesn't completely overwrite</para>
                /// <para>the whole register. If the analysis keeps which bytes are completely</para>
                /// <para>overwritten by the instruction it can find the where a register becomes</para>
                /// <para>dead by simply checking if the instruction overwrites all remaining</para>
                /// <para>bytes.</para>
                /// </remarks>
                public uint WriteSize
                {
                    get
                    {
                        var __ret = __Internal.GetWriteSize((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get if the instruction has alternative opcode.</summary>
                public bool HasAltOpCode
                {
                    get
                    {
                        var __ret = __Internal.HasAltOpCode((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                /// <summary>Get alternative opcode, see</summary>
                public uint AltOpCode
                {
                    get
                    {
                        var __ret = __Internal.GetAltOpCode((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint ISignatureIndex
                {
                    get
                    {
                        var __ret = __Internal.GetISignatureIndex((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint ISignatureCount
                {
                    get
                    {
                        var __ret = __Internal.GetISignatureCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature ISignatureData
                {
                    get
                    {
                        var __ret = __Internal.GetISignatureData((__Instance + __PointerAdjustment));
                        global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature __result0;
                        if (__ret == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.NativeToManagedMap.ContainsKey(__ret))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature) global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.NativeToManagedMap[__ret];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__CreateInstance(__ret);
                        return __result0;
                    }
                }

                public global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature ISignatureEnd
                {
                    get
                    {
                        var __ret = __Internal.GetISignatureEnd((__Instance + __PointerAdjustment));
                        global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature __result0;
                        if (__ret == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.NativeToManagedMap.ContainsKey(__ret))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature) global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.NativeToManagedMap[__ret];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__CreateInstance(__ret);
                        return __result0;
                    }
                }

                public uint JumpType
                {
                    get
                    {
                        var __ret = __Internal.GetJumpType((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint SingleRegCase
                {
                    get
                    {
                        var __ret = __Internal.GetSingleRegCase((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            /// <summary>Detailed data about instruction's operation, requirements, and side-effects.</summary>
            public unsafe partial class OperationData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint _flags;

                    [FieldOffset(4)]
                    internal fixed byte _features[4];

                    [FieldOffset(8)]
                    internal uint _specialRegsR;

                    [FieldOffset(12)]
                    internal uint _specialRegsW;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0OperationData@X86Inst@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasOperationFlag@OperationData@X86Inst@asmjit@@QEBA_NI@Z")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasOperationFlag(global::System.IntPtr instance, uint flag);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?hasFeature@OperationData@X86Inst@asmjit@@QEBA_NI@Z")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool HasFeature(global::System.IntPtr instance, uint feature);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getOperationFlags@OperationData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetOperationFlags(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isMovCrDr@OperationData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsMovCrDr(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isMovSsSd@OperationData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsMovSsSd(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isPrefetch@OperationData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsPrefetch(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isBarrier@OperationData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsBarrier(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isVolatile@OperationData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsVolatile(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?isPrivileged@OperationData@X86Inst@asmjit@@QEBA_NXZ")]
                    [return: MarshalAs(UnmanagedType.I1)]
                    internal static extern bool IsPrivileged(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecialRegsR@OperationData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetSpecialRegsR(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecialRegsW@OperationData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetSpecialRegsW(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFeaturesData@OperationData@X86Inst@asmjit@@QEBAPEBEXZ")]
                    internal static extern byte* GetFeaturesData(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFeaturesEnd@OperationData@X86Inst@asmjit@@QEBAPEBEXZ")]
                    internal static extern byte* GetFeaturesEnd(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private OperationData(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected OperationData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public OperationData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public OperationData(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool HasOperationFlag(uint flag)
                {
                    var __ret = __Internal.HasOperationFlag((__Instance + __PointerAdjustment), flag);
                    return __ret;
                }

                public bool HasFeature(uint feature)
                {
                    var __ret = __Internal.HasFeature((__Instance + __PointerAdjustment), feature);
                    return __ret;
                }

                public uint OperationFlags
                {
                    get
                    {
                        var __ret = __Internal.GetOperationFlags((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsMovCrDr
                {
                    get
                    {
                        var __ret = __Internal.IsMovCrDr((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsMovSsSd
                {
                    get
                    {
                        var __ret = __Internal.IsMovSsSd((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsPrefetch
                {
                    get
                    {
                        var __ret = __Internal.IsPrefetch((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsBarrier
                {
                    get
                    {
                        var __ret = __Internal.IsBarrier((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsVolatile
                {
                    get
                    {
                        var __ret = __Internal.IsVolatile((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsPrivileged
                {
                    get
                    {
                        var __ret = __Internal.IsPrivileged((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint SpecialRegsR
                {
                    get
                    {
                        var __ret = __Internal.GetSpecialRegsR((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint SpecialRegsW
                {
                    get
                    {
                        var __ret = __Internal.GetSpecialRegsW((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public byte* FeaturesData
                {
                    get
                    {
                        var __ret = __Internal.GetFeaturesData((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public byte* FeaturesEnd
                {
                    get
                    {
                        var __ret = __Internal.GetFeaturesEnd((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            /// <summary>Contains data that can be used to convert SSE to AVX (or back).</summary>
            public unsafe partial class SseToAvxData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 2)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal ushort _mode;

                    [FieldOffset(0)]
                    internal short _delta;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0SseToAvxData@X86Inst@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMode@SseToAvxData@X86Inst@asmjit@@QEBAIXZ")]
                    internal static extern uint GetMode(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getDelta@SseToAvxData@X86Inst@asmjit@@QEBAHXZ")]
                    internal static extern int GetDelta(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SseToAvxData(global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SseToAvxData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SseToAvxData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public SseToAvxData(global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public uint Mode
                {
                    get
                    {
                        var __ret = __Internal.GetMode((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public int Delta
                {
                    get
                    {
                        var __ret = __Internal.GetDelta((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            /// <summary>
            /// <para>Data that is not related to a specific X86 instruction (not referenced by</para>
            /// <para>any tables).</para>
            /// </summary>
            public unsafe partial class MiscData : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 256)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed uint condToJcc[16];

                    [FieldOffset(64)]
                    internal fixed uint condToSetcc[16];

                    [FieldOffset(128)]
                    internal fixed uint condToCmovcc[16];

                    [FieldOffset(192)]
                    internal fixed uint reversedCond[16];

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MiscData@X86Inst@asmjit@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private MiscData(global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MiscData(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MiscData()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public MiscData(global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86Inst>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Inst(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Inst __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Inst.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Inst(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Inst.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.X86Inst.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private X86Inst(global::GraphEngine.Jit.Native.Asmjit.X86Inst.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Inst(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Inst()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public X86Inst(global::GraphEngine.Jit.Native.Asmjit.X86Inst _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Inst.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.X86Inst.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.X86Inst __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get if the instruction has flag `flag`, see</summary>
            public bool HasFlag(uint flag)
            {
                var __ret = __Internal.HasFlag((__Instance + __PointerAdjustment), flag);
                return __ret;
            }

            /// <summary>Get if the `instId` is defined (counts also Inst::kIdNone, which must be zero).</summary>
            public static bool IsDefinedId(uint instId)
            {
                var __ret = __Internal.IsDefinedId(instId);
                return __ret;
            }

            /// <summary>Get instruction information based on the instruction `instId`.</summary>
            /// <remarks>
            /// <para>NOTE: `instId` has to be a valid instruction ID, it can't be greater than</para>
            /// <para>or equal to `X86Inst::_kIdCount`. It asserts in debug mode.</para>
            /// </remarks>
            public static global::GraphEngine.Jit.Native.Asmjit.X86Inst GetInst(uint instId)
            {
                var __ret = __Internal.GetInst(instId);
                global::GraphEngine.Jit.Native.Asmjit.X86Inst __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.X86Inst.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Inst) global::GraphEngine.Jit.Native.Asmjit.X86Inst.NativeToManagedMap[__ret];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Inst.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>Get the equivalent of a negated condition code.</summary>
            public static uint NegateCond(uint cond)
            {
                var __ret = __Internal.NegateCond(cond);
                return __ret;
            }

            /// <summary>
            /// <para>Convert a condition code into a condition code that reverses the</para>
            /// <para>corresponding operands of a comparison.</para>
            /// </summary>
            public static uint ReverseCond(uint cond)
            {
                var __ret = __Internal.ReverseCond(cond);
                return __ret;
            }

            /// <summary>Translate a condition code `cc` to a &quot;cmovcc&quot; instruction id.</summary>
            public static uint CondToCmovcc(uint cond)
            {
                var __ret = __Internal.CondToCmovcc(cond);
                return __ret;
            }

            /// <summary>Translate a condition code `cc` to a &quot;jcc&quot; instruction id.</summary>
            public static uint CondToJcc(uint cond)
            {
                var __ret = __Internal.CondToJcc(cond);
                return __ret;
            }

            /// <summary>Translate a condition code `cc` to a &quot;setcc&quot; instruction id.</summary>
            public static uint CondToSetcc(uint cond)
            {
                var __ret = __Internal.CondToSetcc(cond);
                return __ret;
            }

            /// <summary>Get a 'kmov?' instruction by register `size`.</summary>
            public static uint KmovIdFromSize(uint size)
            {
                var __ret = __Internal.KmovIdFromSize(size);
                return __ret;
            }

            /// <summary>Get an instruction ID from a given instruction `name`.</summary>
            /// <remarks>
            /// <para>NOTE: Instruction name MUST BE in lowercase, otherwise there will be no</para>
            /// <para>match. If there is an exact match the instruction id is returned, otherwise</para>
            /// <para>`kInvalidInstId` (zero) is returned instead. The given `name` doesn't have</para>
            /// <para>to be null-terminated if `len` is provided.</para>
            /// </remarks>
            public static uint GetIdByName(string name, ulong len)
            {
                var __ret = __Internal.GetIdByName(name, len);
                return __ret;
            }

            /// <summary>Get an instruction name from a given instruction id `instId`.</summary>
            public static string GetNameById(uint instId)
            {
                var __ret = __Internal.GetNameById(instId);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>Get instruction name (null terminated).</summary>
            /// <remarks>
            /// <para>NOTE: If AsmJit was compiled with `ASMJIT_DISABLE_TEXT` then this will</para>
            /// <para>return an empty string (null terminated string of zero length).</para>
            /// </remarks>
            public string Name
            {
                get
                {
                    var __ret = __Internal.GetName((__Instance + __PointerAdjustment));
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            /// <summary>Get index to `X86InstDB::nameData` of this instruction.</summary>
            /// <remarks>
            /// <para>NOTE: If AsmJit was compiled with `ASMJIT_DISABLE_TEXT` then this will</para>
            /// <para>always return zero.</para>
            /// </remarks>
            public uint NameDataIndex
            {
                get
                {
                    var __ret = __Internal.GetNameDataIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData commonData
            {
                get
                {
                    var __ret = __Internal.GetCommonData((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData) global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Inst.CommonData.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get index to `X86InstDB::commonData` of this instruction.</summary>
            public uint CommonDataIndex
            {
                get
                {
                    var __ret = __Internal.GetCommonDataIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData operationData
            {
                get
                {
                    var __ret = __Internal.GetOperationData((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData) global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Inst.OperationData.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get index to `X86InstDB::operationData` of this instruction.</summary>
            public uint OperationDataIndex
            {
                get
                {
                    var __ret = __Internal.GetOperationDataIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get data that can be used to convert SSE instruction to AVX (or back).</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData sseToAvxData
            {
                get
                {
                    var __ret = __Internal.GetSseToAvxData((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData) global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Inst.SseToAvxData.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get index to `X86InstDB::sseToAvxData` of this instruction.</summary>
            public uint SseToAvxDataIndex
            {
                get
                {
                    var __ret = __Internal.GetSseToAvxDataIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get instruction encoding, see</summary>
            public uint encodingType
            {
                get
                {
                    var __ret = __Internal.GetEncodingType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction has main opcode (rare, but it's possible it doesn't have).</summary>
            public bool HasMainOpCode
            {
                get
                {
                    var __ret = __Internal.HasMainOpCode((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get main opcode, see</summary>
            public uint MainOpCode
            {
                get
                {
                    var __ret = __Internal.GetMainOpCode((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction has alternative opcode.</summary>
            public bool HasAltOpCode
            {
                get
                {
                    var __ret = __Internal.HasAltOpCode((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get alternative opcode, see</summary>
            public uint AltOpCode
            {
                get
                {
                    var __ret = __Internal.GetAltOpCode((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get instruction flags, see</summary>
            public uint flags
            {
                get
                {
                    var __ret = __Internal.GetFlags((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction is FPU instruction.</summary>
            public bool IsFpu
            {
                get
                {
                    var __ret = __Internal.IsFpu((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction is MMX instruction that accesses MMX registersm, including EMMS.</summary>
            public bool IsMmx
            {
                get
                {
                    var __ret = __Internal.IsMmx((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction is SSE|AVX|AVX512 instruction that accesses XMM|YMM|ZMM registers.</summary>
            public bool IsVec
            {
                get
                {
                    var __ret = __Internal.IsVec((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction is SSE+ (SSE4.2, AES, SHA included) instruction that accesses XMM registers.</summary>
            public bool IsSse
            {
                get
                {
                    var __ret = __Internal.IsSse((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction is AVX+ (FMA included) instruction that accesses XMM|YMM|ZMM registers.</summary>
            public bool IsAvx
            {
                get
                {
                    var __ret = __Internal.IsAvx((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction can be prefixed by LOCK prefix.</summary>
            public bool IsLockEnabled
            {
                get
                {
                    var __ret = __Internal.IsLockEnabled((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction can be prefixed by REP prefix.</summary>
            public bool IsRepEnabled
            {
                get
                {
                    var __ret = __Internal.IsRepEnabled((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction can be prefixed by REPZ prefix.</summary>
            public bool IsRepzEnabled
            {
                get
                {
                    var __ret = __Internal.IsRepzEnabled((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction can be prefixed by REPNZ prefix.</summary>
            public bool IsRepnzEnabled
            {
                get
                {
                    var __ret = __Internal.IsRepnzEnabled((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction uses MIB.</summary>
            public bool IsMibOp
            {
                get
                {
                    var __ret = __Internal.IsMibOp((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction uses VSIB.</summary>
            public bool IsVsibOp
            {
                get
                {
                    var __ret = __Internal.IsVsibOp((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction uses VEX (can be set together with EVEX if both are encodable).</summary>
            public bool IsVex
            {
                get
                {
                    var __ret = __Internal.IsVex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction uses EVEX (can be set together with VEX if both are encodable).</summary>
            public bool IsEvex
            {
                get
                {
                    var __ret = __Internal.IsEvex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction supports AVX512 masking {k}.</summary>
            public bool HasAvx512K
            {
                get
                {
                    var __ret = __Internal.HasAvx512K((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction supports AVX512 zeroing {k}{z}.</summary>
            public bool HasAvx512Z
            {
                get
                {
                    var __ret = __Internal.HasAvx512Z((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction supports AVX512 embedded-rounding {er}.</summary>
            public bool HasAvx512ER
            {
                get
                {
                    var __ret = __Internal.HasAvx512ER((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction supports AVX512 suppress-all-exceptions {sae}.</summary>
            public bool HasAvx512SAE
            {
                get
                {
                    var __ret = __Internal.HasAvx512SAE((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction supports AVX512 broadcast (either 32-bit or 64-bit).</summary>
            public bool HasAvx512B
            {
                get
                {
                    var __ret = __Internal.HasAvx512B((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction supports AVX512 broadcast (32-bit).</summary>
            public bool HasAvx512B32
            {
                get
                {
                    var __ret = __Internal.HasAvx512B32((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the instruction supports AVX512 broadcast (64-bit).</summary>
            public bool HasAvx512B64
            {
                get
                {
                    var __ret = __Internal.HasAvx512B64((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint ISignatureIndex
            {
                get
                {
                    var __ret = __Internal.GetISignatureIndex((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint ISignatureCount
            {
                get
                {
                    var __ret = __Internal.GetISignatureCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature ISignatureData
            {
                get
                {
                    var __ret = __Internal.GetISignatureData((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature) global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature ISignatureEnd
            {
                get
                {
                    var __ret = __Internal.GetISignatureEnd((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature) global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Inst.ISignature.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData miscData
            {
                get
                {
                    var __ret = __Internal.GetMiscData();
                    global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData) global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Inst.MiscData.__CreateInstance(__ret);
                    return __result0;
                }
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Memory operand (X86).</summary>
        public unsafe partial class X86Mem : global::GraphEngine.Jit.Native.Asmjit.Mem, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@AEBVLabel@1@HII@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr @base, int off, uint size, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@AEBVLabel@1@AEBVReg@1@IHII@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int off, uint size, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@AEBVReg@1@HII@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr @base, int off, uint size, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@AEBVReg@1@0IHII@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int off, uint size, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@_KII@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong @base, uint size, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@_KAEBVReg@1@III@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong @base, global::System.IntPtr index, uint shift, uint size, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@AEBU_Init@1@IIIIHII@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint baseType, uint baseId, uint indexType, uint indexId, int off, uint size, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mem@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Mem@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setIndex@X86Mem@asmjit@@QEAAXAEBVReg@2@I@Z")]
                internal static extern void SetIndex(global::System.IntPtr instance, global::System.IntPtr index, uint shift);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetShift@X86Mem@asmjit@@QEAAXXZ")]
                internal static extern void ResetShift(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?resetSegment@X86Mem@asmjit@@QEAAXXZ")]
                internal static extern void ResetSegment(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?adjusted@X86Mem@asmjit@@QEBA?AV12@_J@Z")]
                internal static extern void Adjusted(global::System.IntPtr instance, global::System.IntPtr @return, long off);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getShift@X86Mem@asmjit@@QEBAIXZ")]
                internal static extern uint GetShift(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setShift@X86Mem@asmjit@@QEAAXI@Z")]
                internal static extern void SetShift(global::System.IntPtr instance, uint shift);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSegment@X86Mem@asmjit@@QEBA?AVX86Seg@2@XZ")]
                internal static extern void GetSegment(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setSegment@X86Mem@asmjit@@QEAAXAEBVX86Seg@2@@Z")]
                internal static extern void SetSegment(global::System.IntPtr instance, global::System.IntPtr seg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSegmentId@X86Mem@asmjit@@QEBAIXZ")]
                internal static extern uint GetSegmentId(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setSegmentId@X86Mem@asmjit@@QEAAXI@Z")]
                internal static extern void SetSegmentId(global::System.IntPtr instance, uint sId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasShift@X86Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasShift(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasSegment@X86Mem@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasSegment(global::System.IntPtr instance);
            }

            /// <summary>Additional bits of operand's signature used by `X86Mem`.</summary>
            public enum AdditionalBits : uint
            {
                kSignatureMemShiftShift = 19,
                kSignatureMemShiftBits = 0x3,
                kSignatureMemShiftMask = 1572864,
                kSignatureMemSegmentShift = 21,
                kSignatureMemSegmentBits = 0x7,
                kSignatureMemSegmentMask = 14680064
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Mem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Mem(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Mem __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Mem(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Mem(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Mem(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Construct a default `X86Mem` operand, that points to [0].</summary>
            public X86Mem()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Mem(global::GraphEngine.Jit.Native.Asmjit.X86Mem other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Mem(global::GraphEngine.Jit.Native.Asmjit.Label @base, int off, uint size, uint flags)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(@base, null))
                    throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @base.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, off, size, flags);
            }

            public X86Mem(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.Reg index, uint shift, int off, uint size, uint flags)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(@base, null))
                    throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @base.__Instance;
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = index.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, shift, off, size, flags);
            }

            public X86Mem(global::GraphEngine.Jit.Native.Asmjit.Reg @base, int off, uint size, uint flags)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(@base, null))
                    throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @base.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0, off, size, flags);
            }

            public X86Mem(global::GraphEngine.Jit.Native.Asmjit.Reg @base, global::GraphEngine.Jit.Native.Asmjit.Reg index, uint shift, int off, uint size, uint flags)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(@base, null))
                    throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @base.__Instance;
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = index.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0, __arg1, shift, off, size, flags);
            }

            public X86Mem(ulong @base, uint size, uint flags)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), @base, size, flags);
            }

            public X86Mem(ulong @base, global::GraphEngine.Jit.Native.Asmjit.Reg index, uint shift, uint size, uint flags)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = index.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), @base, __arg1, shift, size, flags);
            }

            public X86Mem(global::GraphEngine.Jit.Native.Asmjit._Init init, uint baseType, uint baseId, uint indexType, uint indexId, int off, uint size, uint flags)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, baseType, baseId, indexType, indexId, off, size, flags);
            }

            public X86Mem(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Clone the memory operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            public void SetIndex(global::GraphEngine.Jit.Native.Asmjit.Reg index, uint shift)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                __Internal.SetIndex((__Instance + __PointerAdjustment), __arg0, shift);
            }

            /// <summary>Reset the memory operand's shift (aka scale) constant to zero.</summary>
            public void ResetShift()
            {
                __Internal.ResetShift((__Instance + __PointerAdjustment));
            }

            /// <summary>Reset the segment override.</summary>
            public void ResetSegment()
            {
                __Internal.ResetSegment((__Instance + __PointerAdjustment));
            }

            /// <summary>Get new memory operand adjusted by `off`.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem Adjusted(long off)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.Adjusted((__Instance + __PointerAdjustment), new IntPtr(&__ret), off);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Get the memory operand's shift (aka scale) constant.</summary>
            /// <remarks>Set the memory operand's shift (aka scale) constant.</remarks>
            public uint Shift
            {
                get
                {
                    var __ret = __Internal.GetShift((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetShift((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get associated segment override as `X86Seg` operand.</summary>
            /// <remarks>Set the segment override to `seg`.</remarks>
            public global::GraphEngine.Jit.Native.Asmjit.X86Seg Segment
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal();
                    __Internal.GetSegment((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(__ret);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetSegment((__Instance + __PointerAdjustment), __arg0);
                }
            }

            /// <summary>Get segment override as id, see</summary>
            /// <remarks>Set the segment override to `id`.</remarks>
            public uint SegmentId
            {
                get
                {
                    var __ret = __Internal.GetSegmentId((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetSegmentId((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get if the memory operand has shift (aka scale) constant.</summary>
            public bool HasShift
            {
                get
                {
                    var __ret = __Internal.HasShift((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get if the memory operand has a segment override.</summary>
            public bool HasSegment
            {
                get
                {
                    var __ret = __Internal.HasSegment((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Register (X86/X64).</summary>
        public unsafe partial class X86Reg : global::GraphEngine.Jit.Native.Asmjit.Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Reg@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Reg@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Reg@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Reg@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Reg@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Reg@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Reg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Reg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpb@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpb(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRip@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRip(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isSeg@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSeg(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpbLo@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpbLo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpbHi@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpbHi(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpw@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpw(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpd@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpd(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpq@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpq(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isFp@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isMm@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMm(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isK@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsK(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isXmm@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsXmm(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isYmm@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsYmm(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isZmm@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsZmm(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isBnd@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsBnd(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isCr@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsCr(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isDr@X86Reg@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsDr(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setTypeAndId@X86Reg@asmjit@@QEAAXII@Z")]
                internal static extern void SetTypeAndId(global::System.IntPtr instance, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?kindOf@X86Reg@asmjit@@SAII@Z")]
                internal static extern uint KindOf(uint rType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?signatureOf@X86Reg@asmjit@@SAII@Z")]
                internal static extern uint SignatureOf(uint rType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?signatureOfVecByType@X86Reg@asmjit@@SAII@Z")]
                internal static extern uint SignatureOfVecByType(uint typeId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?signatureOfVecBySize@X86Reg@asmjit@@SAII@Z")]
                internal static extern uint SignatureOfVecBySize(uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpb@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpb_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRip@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRip_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isSeg@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSeg_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpbLo@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpbLo_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpbHi@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpbHi_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpw@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpw_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpd@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpd_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpq@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpq_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isFp@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFp_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isMm@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMm_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isK@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsK_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isXmm@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsXmm_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isYmm@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsYmm_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isZmm@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsZmm_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isBnd@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsBnd_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isCr@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsCr_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isDr@X86Reg@asmjit@@SA_NAEBUOperand_@2@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsDr_1(global::System.IntPtr op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpb@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpb(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isRip@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRip(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isSeg@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSeg(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpbLo@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpbLo(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpbHi@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpbHi(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpw@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpw(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpd@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpd(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isGpq@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsGpq(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isFp@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFp(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isMm@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMm(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isK@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsK(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isXmm@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsXmm(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isYmm@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsYmm(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isZmm@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsZmm(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isBnd@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsBnd(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isCr@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsCr(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isDr@X86Reg@asmjit@@SA_NAEBUOperand_@2@I@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsDr(global::System.IntPtr op, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m@X86Reg@asmjit@@QEBA?AVX86Mem@2@H@Z")]
                internal static extern void M(global::System.IntPtr instance, global::System.IntPtr @return, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m@X86Reg@asmjit@@QEBA?AVX86Mem@2@AEBV12@IH@Z")]
                internal static extern void M(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr index, uint shift, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m8@X86Reg@asmjit@@QEBA?AVX86Mem@2@H@Z")]
                internal static extern void M8(global::System.IntPtr instance, global::System.IntPtr @return, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m8@X86Reg@asmjit@@QEBA?AVX86Mem@2@AEBV12@IH@Z")]
                internal static extern void M8(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr index, uint shift, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m16@X86Reg@asmjit@@QEBA?AVX86Mem@2@H@Z")]
                internal static extern void M16(global::System.IntPtr instance, global::System.IntPtr @return, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m16@X86Reg@asmjit@@QEBA?AVX86Mem@2@AEBV12@IH@Z")]
                internal static extern void M16(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr index, uint shift, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m32@X86Reg@asmjit@@QEBA?AVX86Mem@2@H@Z")]
                internal static extern void M32(global::System.IntPtr instance, global::System.IntPtr @return, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m32@X86Reg@asmjit@@QEBA?AVX86Mem@2@AEBV12@IH@Z")]
                internal static extern void M32(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr index, uint shift, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m64@X86Reg@asmjit@@QEBA?AVX86Mem@2@H@Z")]
                internal static extern void M64(global::System.IntPtr instance, global::System.IntPtr @return, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m64@X86Reg@asmjit@@QEBA?AVX86Mem@2@AEBV12@IH@Z")]
                internal static extern void M64(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr index, uint shift, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m80@X86Reg@asmjit@@QEBA?AVX86Mem@2@H@Z")]
                internal static extern void M80(global::System.IntPtr instance, global::System.IntPtr @return, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m80@X86Reg@asmjit@@QEBA?AVX86Mem@2@AEBV12@IH@Z")]
                internal static extern void M80(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr index, uint shift, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m128@X86Reg@asmjit@@QEBA?AVX86Mem@2@H@Z")]
                internal static extern void M128(global::System.IntPtr instance, global::System.IntPtr @return, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m128@X86Reg@asmjit@@QEBA?AVX86Mem@2@AEBV12@IH@Z")]
                internal static extern void M128(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr index, uint shift, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m256@X86Reg@asmjit@@QEBA?AVX86Mem@2@H@Z")]
                internal static extern void M256(global::System.IntPtr instance, global::System.IntPtr @return, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m256@X86Reg@asmjit@@QEBA?AVX86Mem@2@AEBV12@IH@Z")]
                internal static extern void M256(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr index, uint shift, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m512@X86Reg@asmjit@@QEBA?AVX86Mem@2@H@Z")]
                internal static extern void M512(global::System.IntPtr instance, global::System.IntPtr @return, int disp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?m512@X86Reg@asmjit@@QEBA?AVX86Mem@2@AEBV12@IH@Z")]
                internal static extern void M512(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr index, uint shift, int disp);
            }

            /// <summary>Register type.</summary>
            /// <remarks>Don't change these constants; they are essential to some built-in tables.</remarks>
            public enum RegType : uint
            {
                /// <summary>No register type or invalid register.</summary>
                kRegNone = 0,
                /// <summary>Low GPB register (AL, BL, CL, DL, ...).</summary>
                kRegGpbLo = 2,
                /// <summary>High GPB register (AH, BH, CH, DH only).</summary>
                kRegGpbHi = 3,
                /// <summary>GPW register.</summary>
                kRegGpw = 4,
                /// <summary>GPD register.</summary>
                kRegGpd = 5,
                /// <summary>GPQ register (X64).</summary>
                kRegGpq = 6,
                /// <summary>XMM register (SSE+).</summary>
                kRegXmm = 9,
                /// <summary>YMM register (AVX+).</summary>
                kRegYmm = 10,
                /// <summary>ZMM register (AVX512+).</summary>
                kRegZmm = 11,
                /// <summary>Instruction pointer (EIP, RIP).</summary>
                kRegRip = 14,
                /// <summary>Segment register (None, ES, CS, SS, DS, FS, GS).</summary>
                kRegSeg = 15,
                /// <summary>FPU (x87) register.</summary>
                kRegFp = 16,
                /// <summary>MMX register.</summary>
                kRegMm = 17,
                /// <summary>K register (AVX512+).</summary>
                kRegK = 18,
                /// <summary>Bound register (BND).</summary>
                kRegBnd = 19,
                /// <summary>Control register (CR).</summary>
                kRegCr = 20,
                /// <summary>Debug register (DR).</summary>
                kRegDr = 21,
                /// <summary>Count of register types.</summary>
                kRegCount = 22
            }

            /// <summary>Register kind.</summary>
            public enum Kind : uint
            {
                /// <summary>GP register kind or none (universal).</summary>
                kKindGp = 0,
                /// <summary>XMM|YMM|ZMM register kind (universal).</summary>
                kKindVec = 1,
                /// <summary>MMX register kind (legacy).</summary>
                kKindMm = 2,
                /// <summary>K register kind.</summary>
                kKindK = 3,
                /// <summary>FPU (x87) register kind.</summary>
                kKindFp = 4,
                /// <summary>Control register kind.</summary>
                kKindCr = 5,
                /// <summary>Debug register kind.</summary>
                kKindDr = 6,
                /// <summary>Bound register kind.</summary>
                kKindBnd = 7,
                /// <summary>Segment register kind.</summary>
                kKindSeg = 8,
                /// <summary>Instrucion pointer (IP).</summary>
                kKindRip = 9,
                /// <summary>Count of all register kinds.</summary>
                kKindCount = 10
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Reg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Reg(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Reg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Reg(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Reg(global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Reg(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Reg()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Reg(global::GraphEngine.Jit.Native.Asmjit.X86Reg other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Reg(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Reg(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Reg(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Reg Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Reg.__CreateInstance(__ret);
            }

            /// <summary>Get if the register is a GPB register (8-bit).</summary>
            public bool IsGpb()
            {
                var __ret = __Internal.IsGpb((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is RIP.</summary>
            public bool IsRip()
            {
                var __ret = __Internal.IsRip((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a segment register.</summary>
            public bool IsSeg()
            {
                var __ret = __Internal.IsSeg((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a low GPB register (8-bit).</summary>
            public bool IsGpbLo()
            {
                var __ret = __Internal.IsGpbLo((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a high GPB register (8-bit).</summary>
            public bool IsGpbHi()
            {
                var __ret = __Internal.IsGpbHi((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a GPW register (16-bit).</summary>
            public bool IsGpw()
            {
                var __ret = __Internal.IsGpw((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a GPD register (32-bit).</summary>
            public bool IsGpd()
            {
                var __ret = __Internal.IsGpd((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a GPQ register (64-bit).</summary>
            public bool IsGpq()
            {
                var __ret = __Internal.IsGpq((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is an FPU register (80-bit).</summary>
            public bool IsFp()
            {
                var __ret = __Internal.IsFp((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is an MMX register (64-bit).</summary>
            public bool IsMm()
            {
                var __ret = __Internal.IsMm((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a K register (64-bit).</summary>
            public bool IsK()
            {
                var __ret = __Internal.IsK((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is an XMM register (128-bit).</summary>
            public bool IsXmm()
            {
                var __ret = __Internal.IsXmm((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a YMM register (256-bit).</summary>
            public bool IsYmm()
            {
                var __ret = __Internal.IsYmm((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a ZMM register (512-bit).</summary>
            public bool IsZmm()
            {
                var __ret = __Internal.IsZmm((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a bound register.</summary>
            public bool IsBnd()
            {
                var __ret = __Internal.IsBnd((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a control register.</summary>
            public bool IsCr()
            {
                var __ret = __Internal.IsCr((__Instance + __PointerAdjustment));
                return __ret;
            }

            /// <summary>Get if the register is a debug register.</summary>
            public bool IsDr()
            {
                var __ret = __Internal.IsDr((__Instance + __PointerAdjustment));
                return __ret;
            }

            public void SetTypeAndId(uint rType, uint rId)
            {
                __Internal.SetTypeAndId((__Instance + __PointerAdjustment), rType, rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M(int disp)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M((__Instance + __PointerAdjustment), new IntPtr(&__ret), disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }


            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M(global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, int disp)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, shift, disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Cast this variable to 8-bit memory operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M8(int disp)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M8((__Instance + __PointerAdjustment), new IntPtr(&__ret), disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }


            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M8(global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, int disp)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M8((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, shift, disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Cast this variable to 16-bit memory operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M16(int disp)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M16((__Instance + __PointerAdjustment), new IntPtr(&__ret), disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }


            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M16(global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, int disp)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M16((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, shift, disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Cast this variable to 32-bit memory operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M32(int disp)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M32((__Instance + __PointerAdjustment), new IntPtr(&__ret), disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }


            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M32(global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, int disp)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M32((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, shift, disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Cast this variable to 64-bit memory operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M64(int disp)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M64((__Instance + __PointerAdjustment), new IntPtr(&__ret), disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }


            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M64(global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, int disp)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M64((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, shift, disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Cast this variable to 80-bit memory operand (long double).</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M80(int disp)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M80((__Instance + __PointerAdjustment), new IntPtr(&__ret), disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }


            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M80(global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, int disp)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M80((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, shift, disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Cast this variable to 128-bit memory operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M128(int disp)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M128((__Instance + __PointerAdjustment), new IntPtr(&__ret), disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }


            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M128(global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, int disp)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M128((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, shift, disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Cast this variable to 256-bit memory operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M256(int disp)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M256((__Instance + __PointerAdjustment), new IntPtr(&__ret), disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }


            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M256(global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, int disp)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M256((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, shift, disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            /// <summary>Cast this variable to 256-bit memory operand.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M512(int disp)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M512((__Instance + __PointerAdjustment), new IntPtr(&__ret), disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }


            public global::GraphEngine.Jit.Native.Asmjit.X86Mem M512(global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, int disp)
            {
                if (ReferenceEquals(index, null))
                    throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = index.__Instance;
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                __Internal.M512((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, shift, disp);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Reg FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Reg.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Reg FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Reg.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Reg.__CreateInstance(__ret);
            }

            public static uint KindOf(uint rType)
            {
                var __ret = __Internal.KindOf(rType);
                return __ret;
            }

            public static uint SignatureOf(uint rType)
            {
                var __ret = __Internal.SignatureOf(rType);
                return __ret;
            }

            public static uint SignatureOfVecByType(uint typeId)
            {
                var __ret = __Internal.SignatureOfVecByType(typeId);
                return __ret;
            }

            public static uint SignatureOfVecBySize(uint size)
            {
                var __ret = __Internal.SignatureOfVecBySize(size);
                return __ret;
            }

            /// <summary>Get if the `op` operand is either a low or high 8-bit GPB register.</summary>
            public static bool IsGpb(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpb_1(__arg0);
                return __ret;
            }

            public static bool IsRip(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsRip_1(__arg0);
                return __ret;
            }

            public static bool IsSeg(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsSeg_1(__arg0);
                return __ret;
            }

            public static bool IsGpbLo(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpbLo_1(__arg0);
                return __ret;
            }

            public static bool IsGpbHi(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpbHi_1(__arg0);
                return __ret;
            }

            public static bool IsGpw(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpw_1(__arg0);
                return __ret;
            }

            public static bool IsGpd(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpd_1(__arg0);
                return __ret;
            }

            public static bool IsGpq(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpq_1(__arg0);
                return __ret;
            }

            public static bool IsFp(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsFp_1(__arg0);
                return __ret;
            }

            public static bool IsMm(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsMm_1(__arg0);
                return __ret;
            }

            public static bool IsK(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsK_1(__arg0);
                return __ret;
            }

            public static bool IsXmm(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsXmm_1(__arg0);
                return __ret;
            }

            public static bool IsYmm(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsYmm_1(__arg0);
                return __ret;
            }

            public static bool IsZmm(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsZmm_1(__arg0);
                return __ret;
            }

            public static bool IsBnd(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsBnd_1(__arg0);
                return __ret;
            }

            public static bool IsCr(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsCr_1(__arg0);
                return __ret;
            }

            public static bool IsDr(global::GraphEngine.Jit.Native.Asmjit.Operand_ op)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsDr_1(__arg0);
                return __ret;
            }

            public static bool IsGpb(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpb(__arg0, rId);
                return __ret;
            }

            public static bool IsRip(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsRip(__arg0, rId);
                return __ret;
            }

            public static bool IsSeg(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsSeg(__arg0, rId);
                return __ret;
            }

            public static bool IsGpbLo(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpbLo(__arg0, rId);
                return __ret;
            }

            public static bool IsGpbHi(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpbHi(__arg0, rId);
                return __ret;
            }

            public static bool IsGpw(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpw(__arg0, rId);
                return __ret;
            }

            public static bool IsGpd(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpd(__arg0, rId);
                return __ret;
            }

            public static bool IsGpq(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsGpq(__arg0, rId);
                return __ret;
            }

            public static bool IsFp(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsFp(__arg0, rId);
                return __ret;
            }

            public static bool IsMm(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsMm(__arg0, rId);
                return __ret;
            }

            public static bool IsK(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsK(__arg0, rId);
                return __ret;
            }

            public static bool IsXmm(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsXmm(__arg0, rId);
                return __ret;
            }

            public static bool IsYmm(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsYmm(__arg0, rId);
                return __ret;
            }

            public static bool IsZmm(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsZmm(__arg0, rId);
                return __ret;
            }

            public static bool IsBnd(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsBnd(__arg0, rId);
                return __ret;
            }

            public static bool IsCr(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsCr(__arg0, rId);
                return __ret;
            }

            public static bool IsDr(global::GraphEngine.Jit.Native.Asmjit.Operand_ op, uint rId)
            {
                if (ReferenceEquals(op, null))
                    throw new global::System.ArgumentNullException("op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = op.__Instance;
                var __ret = __Internal.IsDr(__arg0, rId);
                return __ret;
            }
        }

        /// <summary>General purpose register (X86/X64).</summary>
        public unsafe partial class X86Gp : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gp@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gp@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gp@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gp@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gp@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Gp@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Gp@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Gp@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?r8@X86Gp@asmjit@@QEBA?AVX86GpbLo@2@XZ")]
                internal static extern void R8(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?r8Lo@X86Gp@asmjit@@QEBA?AVX86GpbLo@2@XZ")]
                internal static extern void R8Lo(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?r8Hi@X86Gp@asmjit@@QEBA?AVX86GpbHi@2@XZ")]
                internal static extern void R8Hi(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?r16@X86Gp@asmjit@@QEBA?AVX86Gpw@2@XZ")]
                internal static extern void R16(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?r32@X86Gp@asmjit@@QEBA?AVX86Gpd@2@XZ")]
                internal static extern void R32(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?r64@X86Gp@asmjit@@QEBA?AVX86Gpq@2@XZ")]
                internal static extern void R64(global::System.IntPtr instance, global::System.IntPtr @return);
            }

            /// <summary>X86/X64 physical id.</summary>
            /// <remarks>
            /// <para>NOTE: Register indexes have been reduced to only support general purpose</para>
            /// <para>registers. There is no need to have enumerations with number suffix that</para>
            /// <para>expands to the exactly same value as the suffix value itself.</para>
            /// </remarks>
            public enum Id : uint
            {
                /// <summary>Physical id of AL|AH|AX|EAX|RAX registers.</summary>
                kIdAx = 0,
                /// <summary>Physical id of CL|CH|CX|ECX|RCX registers.</summary>
                kIdCx = 1,
                /// <summary>Physical id of DL|DH|DX|EDX|RDX registers.</summary>
                kIdDx = 2,
                /// <summary>Physical id of BL|BH|BX|EBX|RBX registers.</summary>
                kIdBx = 3,
                /// <summary>Physical id of SPL|SP|ESP|RSP registers.</summary>
                kIdSp = 4,
                /// <summary>Physical id of BPL|BP|EBP|RBP registers.</summary>
                kIdBp = 5,
                /// <summary>Physical id of SIL|SI|ESI|RSI registers.</summary>
                kIdSi = 6,
                /// <summary>Physical id of DIL|DI|EDI|RDI registers.</summary>
                kIdDi = 7,
                /// <summary>Physical id of R8B|R8W|R8D|R8 registers (64-bit only).</summary>
                kIdR8 = 8,
                /// <summary>Physical id of R9B|R9W|R9D|R9 registers (64-bit only).</summary>
                kIdR9 = 9,
                /// <summary>Physical id of R10B|R10W|R10D|R10 registers (64-bit only).</summary>
                kIdR10 = 10,
                /// <summary>Physical id of R11B|R11W|R11D|R11 registers (64-bit only).</summary>
                kIdR11 = 11,
                /// <summary>Physical id of R12B|R12W|R12D|R12 registers (64-bit only).</summary>
                kIdR12 = 12,
                /// <summary>Physical id of R13B|R13W|R13D|R13 registers (64-bit only).</summary>
                kIdR13 = 13,
                /// <summary>Physical id of R14B|R14W|R14D|R14 registers (64-bit only).</summary>
                kIdR14 = 14,
                /// <summary>Physical id of R15B|R15W|R15D|R15 registers (64-bit only).</summary>
                kIdR15 = 15
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Gp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gp(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Gp __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gp(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Gp(global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Gp(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Gp()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Gp(global::GraphEngine.Jit.Native.Asmjit.X86Gp other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Gp(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Gp(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Gp(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gp Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gp FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gp FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gp.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(__ret);
            }

            /// <summary>Cast this register to 8-bit (LO) part.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86GpbLo R8
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal();
                    __Internal.R8((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__CreateInstance(__ret);
                }
            }

            /// <summary>Cast this register to 8-bit (LO) part.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86GpbLo R8Lo
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal();
                    __Internal.R8Lo((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__CreateInstance(__ret);
                }
            }

            /// <summary>Cast this register to 8-bit (HI) part.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86GpbHi R8Hi
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal();
                    __Internal.R8Hi((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__CreateInstance(__ret);
                }
            }

            /// <summary>Cast this register to 16-bit.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Gpw R16
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal();
                    __Internal.R16((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__CreateInstance(__ret);
                }
            }

            /// <summary>Cast this register to 32-bit.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Gpd R32
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal();
                    __Internal.R32((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__CreateInstance(__ret);
                }
            }

            /// <summary>Cast this register to 64-bit.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Gpq R64
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal();
                    __Internal.R64((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__CreateInstance(__ret);
                }
            }
        }

        /// <summary>XMM|YMM|ZMM register (X86/X64).</summary>
        public unsafe partial class X86Vec : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Vec@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Vec@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Vec@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Vec@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Vec@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Vec@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Vec@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Vec@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?xmm@X86Vec@asmjit@@QEBA?AVX86Xmm@2@XZ")]
                internal static extern void Xmm(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ymm@X86Vec@asmjit@@QEBA?AVX86Ymm@2@XZ")]
                internal static extern void Ymm(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?zmm@X86Vec@asmjit@@QEBA?AVX86Zmm@2@XZ")]
                internal static extern void Zmm(global::System.IntPtr instance, global::System.IntPtr @return);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Vec __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Vec(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Vec __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Vec(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Vec(global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Vec(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Vec()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Vec(global::GraphEngine.Jit.Native.Asmjit.X86Vec other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Vec(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Vec(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Vec(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Vec Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Vec.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Vec FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Vec.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Vec FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Vec.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Vec.__CreateInstance(__ret);
            }

            /// <summary>Cast this register to XMM (clone).</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                    __Internal.Xmm((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
                }
            }

            /// <summary>Cast this register to YMM.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                    __Internal.Ymm((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
                }
            }

            /// <summary>Cast this register to ZMM.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                    __Internal.Zmm((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
                }
            }
        }

        /// <summary>Segment register (X86/X64).</summary>
        public unsafe partial class X86Seg : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Seg@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Seg@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Seg@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Seg@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Seg@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Seg@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Seg@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Seg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Seg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 15,
                kThisKind = 8,
                kThisSize = 2,
                kSignature = 33556601
            }

            /// <summary>X86/X64 segment id.</summary>
            public enum Id : uint
            {
                /// <summary>No segment (default).</summary>
                kIdNone = 0,
                /// <summary>ES segment.</summary>
                kIdEs = 1,
                /// <summary>CS segment.</summary>
                kIdCs = 2,
                /// <summary>SS segment.</summary>
                kIdSs = 3,
                /// <summary>DS segment.</summary>
                kIdDs = 4,
                /// <summary>FS segment.</summary>
                kIdFs = 5,
                /// <summary>GS segment.</summary>
                kIdGs = 6,
                /// <summary>Count of X86 segment registers supported by AsmJit.</summary>
                /// <remarks>
                /// <para>NOTE: X86 architecture has 6 segment registers - ES, CS, SS, DS, FS, GS.</para>
                /// <para>X64 architecture lowers them down to just FS and GS. AsmJit supports 7</para>
                /// <para>segment registers - all addressable in both X86 and X64 modes and one</para>
                /// <para>extra called `X86Seg::kIdNone`, which is AsmJit specific and means that</para>
                /// <para>there is no segment register specified.</para>
                /// </remarks>
                kIdCount = 7
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Seg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Seg(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Seg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Seg(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Seg(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Seg(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Seg()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Seg(global::GraphEngine.Jit.Native.Asmjit.X86Seg other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Seg(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Seg(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Seg(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Seg(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Seg Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Seg FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Seg FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Seg.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(__ret);
            }
        }

        /// <summary>GPB (low or high) register (X86/X64).</summary>
        public unsafe partial class X86Gpb : global::GraphEngine.Jit.Native.Asmjit.X86Gp, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpb@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpb@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpb@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpb@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpb@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Gpb@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Gpb@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Gpb@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Gpb __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gpb(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Gpb __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gpb(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Gpb(global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Gpb(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Gpb()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Gpb(global::GraphEngine.Jit.Native.Asmjit.X86Gpb other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Gpb(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Gpb(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Gpb(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gpb Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gpb FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gpb FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpb.__CreateInstance(__ret);
            }
        }

        /// <summary>GPB low register (X86/X64).</summary>
        public unsafe partial class X86GpbLo : global::GraphEngine.Jit.Native.Asmjit.X86Gpb, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbLo@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbLo@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbLo@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbLo@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbLo@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbLo@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86GpbLo@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86GpbLo@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86GpbLo@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 2,
                kThisKind = 0,
                kThisSize = 1,
                kSignature = 16777233
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86GpbLo __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86GpbLo(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86GpbLo(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86GpbLo()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86GpbLo(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86GpbLo(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86GpbLo(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86GpbLo(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86GpbLo(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86GpbLo Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86GpbLo FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86GpbLo FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__CreateInstance(__ret);
            }
        }

        /// <summary>GPB high register (X86/X64).</summary>
        public unsafe partial class X86GpbHi : global::GraphEngine.Jit.Native.Asmjit.X86Gpb, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbHi@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbHi@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbHi@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbHi@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbHi@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86GpbHi@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86GpbHi@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86GpbHi@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86GpbHi@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 3,
                kThisKind = 0,
                kThisSize = 1,
                kSignature = 16777241
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86GpbHi __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86GpbHi(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86GpbHi __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86GpbHi(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86GpbHi(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86GpbHi(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86GpbHi()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86GpbHi(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86GpbHi(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86GpbHi(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86GpbHi(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86GpbHi(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86GpbHi Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86GpbHi FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86GpbHi FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__CreateInstance(__ret);
            }
        }

        /// <summary>GPW register (X86/X64).</summary>
        public unsafe partial class X86Gpw : global::GraphEngine.Jit.Native.Asmjit.X86Gp, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpw@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpw@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpw@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpw@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpw@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpw@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Gpw@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Gpw@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Gpw@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 4,
                kThisKind = 0,
                kThisSize = 2,
                kSignature = 33554465
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Gpw __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gpw(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Gpw __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gpw(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Gpw(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Gpw(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Gpw()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Gpw(global::GraphEngine.Jit.Native.Asmjit.X86Gpw other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Gpw(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Gpw(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Gpw(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Gpw(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gpw Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gpw FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gpw FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__CreateInstance(__ret);
            }
        }

        /// <summary>GPD register (X86/X64).</summary>
        public unsafe partial class X86Gpd : global::GraphEngine.Jit.Native.Asmjit.X86Gp, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpd@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpd@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpd@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpd@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpd@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpd@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Gpd@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Gpd@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Gpd@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 5,
                kThisKind = 0,
                kThisSize = 4,
                kSignature = 67108905
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Gpd __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gpd(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Gpd __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gpd(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Gpd(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Gpd(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Gpd()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Gpd(global::GraphEngine.Jit.Native.Asmjit.X86Gpd other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Gpd(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Gpd(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Gpd(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Gpd(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gpd Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gpd FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gpd FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__CreateInstance(__ret);
            }
        }

        /// <summary>GPQ register (X64).</summary>
        public unsafe partial class X86Gpq : global::GraphEngine.Jit.Native.Asmjit.X86Gp, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpq@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpq@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpq@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpq@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpq@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Gpq@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Gpq@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Gpq@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Gpq@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 6,
                kThisKind = 0,
                kThisSize = 8,
                kSignature = 134217777
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Gpq __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gpq(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Gpq __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Gpq(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Gpq(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Gpq(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Gpq()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Gpq(global::GraphEngine.Jit.Native.Asmjit.X86Gpq other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Gpq(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Gpq(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Gpq(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Gpq(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Gpq Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gpq FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Gpq FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__CreateInstance(__ret);
            }
        }

        /// <summary>RIP register (X86/X64).</summary>
        public unsafe partial class X86Rip : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Rip@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Rip@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Rip@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Rip@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Rip@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Rip@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Rip@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Rip@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Rip@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 14,
                kThisKind = 9,
                kThisSize = 0,
                kSignature = 2417
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Rip __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Rip(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Rip __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Rip(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Rip(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Rip(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Rip()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Rip(global::GraphEngine.Jit.Native.Asmjit.X86Rip other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Rip(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Rip(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Rip(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Rip(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Rip Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Rip.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Rip FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Rip.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Rip FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Rip.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Rip.__CreateInstance(__ret);
            }
        }

        /// <summary>80-bit FPU register (X86/X64).</summary>
        public unsafe partial class X86Fp : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Fp@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Fp@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Fp@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Fp@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Fp@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Fp@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Fp@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Fp@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Fp@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 16,
                kThisKind = 4,
                kThisSize = 10,
                kSignature = 167773313
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Fp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Fp(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Fp __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Fp(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Fp(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Fp(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Fp()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Fp(global::GraphEngine.Jit.Native.Asmjit.X86Fp other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Fp(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Fp(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Fp(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Fp(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Fp Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Fp FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Fp FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(__ret);
            }
        }

        /// <summary>64-bit MMX register (MMX+).</summary>
        public unsafe partial class X86Mm : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mm@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mm@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mm@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mm@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mm@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Mm@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Mm@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Mm@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Mm@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 17,
                kThisKind = 2,
                kThisSize = 8,
                kSignature = 134218377
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Mm __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Mm(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Mm __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Mm(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Mm(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Mm(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Mm()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Mm(global::GraphEngine.Jit.Native.Asmjit.X86Mm other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Mm(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Mm(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Mm(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Mm(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Mm Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Mm FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Mm FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(__ret);
            }
        }

        /// <summary>64-bit K register (AVX512+).</summary>
        public unsafe partial class X86KReg : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86KReg@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86KReg@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86KReg@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86KReg@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86KReg@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86KReg@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86KReg@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86KReg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86KReg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 18,
                kThisKind = 3,
                kThisSize = 0,
                kSignature = 913
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86KReg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86KReg(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86KReg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86KReg(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86KReg(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86KReg(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86KReg()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86KReg(global::GraphEngine.Jit.Native.Asmjit.X86KReg other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86KReg(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86KReg(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86KReg(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86KReg(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86KReg Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86KReg FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86KReg FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
            }
        }

        /// <summary>128-bit XMM register (SSE+).</summary>
        public unsafe partial class X86Xmm : global::GraphEngine.Jit.Native.Asmjit.X86Vec, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Xmm@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Xmm@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Xmm@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Xmm@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Xmm@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Xmm@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Xmm@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Xmm@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Xmm@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 9,
                kThisKind = 1,
                kThisSize = 16,
                kSignature = 268435785
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Xmm __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Xmm(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Xmm __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Xmm(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Xmm(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Xmm(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Xmm()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Xmm(global::GraphEngine.Jit.Native.Asmjit.X86Xmm other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Xmm(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Xmm(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Xmm(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Xmm(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Xmm Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
            }
        }

        /// <summary>256-bit YMM register (AVX+).</summary>
        public unsafe partial class X86Ymm : global::GraphEngine.Jit.Native.Asmjit.X86Vec, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Ymm@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Ymm@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Ymm@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Ymm@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Ymm@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Ymm@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Ymm@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Ymm@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Ymm@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 10,
                kThisKind = 1,
                kThisSize = 32,
                kSignature = 536871249
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Ymm __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Ymm(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Ymm __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Ymm(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Ymm(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Ymm(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Ymm()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Ymm(global::GraphEngine.Jit.Native.Asmjit.X86Ymm other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Ymm(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Ymm(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Ymm(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Ymm(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Ymm Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
            }
        }

        /// <summary>512-bit ZMM register (AVX512+).</summary>
        public unsafe partial class X86Zmm : global::GraphEngine.Jit.Native.Asmjit.X86Vec, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Zmm@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Zmm@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Zmm@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Zmm@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Zmm@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Zmm@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Zmm@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Zmm@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Zmm@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 11,
                kThisKind = 1,
                kThisSize = 64,
                kSignature = 1073742169
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Zmm __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Zmm(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Zmm __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Zmm(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Zmm(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Zmm(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Zmm()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Zmm(global::GraphEngine.Jit.Native.Asmjit.X86Zmm other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Zmm(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Zmm(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Zmm(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Zmm(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Zmm Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
            }
        }

        /// <summary>128-bit BND register (BND+).</summary>
        public unsafe partial class X86Bnd : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Bnd@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Bnd@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Bnd@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Bnd@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Bnd@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86Bnd@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86Bnd@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86Bnd@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86Bnd@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 19,
                kThisKind = 7,
                kThisSize = 16,
                kSignature = 268437401
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Bnd __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Bnd(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Bnd __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86Bnd(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86Bnd(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86Bnd(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86Bnd()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86Bnd(global::GraphEngine.Jit.Native.Asmjit.X86Bnd other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Bnd(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86Bnd(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86Bnd(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86Bnd(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86Bnd Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Bnd FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86Bnd FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__CreateInstance(__ret);
            }
        }

        /// <summary>32-bit or 64-bit control register (X86/X64).</summary>
        public unsafe partial class X86CReg : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86CReg@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86CReg@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86CReg@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86CReg@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86CReg@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86CReg@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86CReg@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86CReg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86CReg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 20,
                kThisKind = 5,
                kThisSize = 0,
                kSignature = 1441
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86CReg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86CReg(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86CReg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86CReg(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86CReg(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86CReg(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86CReg()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86CReg(global::GraphEngine.Jit.Native.Asmjit.X86CReg other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86CReg(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86CReg(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86CReg(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86CReg(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86CReg Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86CReg FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86CReg FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(__ret);
            }
        }

        /// <summary>32-bit or 64-bit debug register (X86/X64).</summary>
        public unsafe partial class X86DReg : global::GraphEngine.Jit.Native.Asmjit.X86Reg, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86DReg@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86DReg@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86DReg@asmjit@@QEAA@AEBVReg@1@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr other, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86DReg@asmjit@@QEAA@AEBU_Init@1@II@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr init, uint signature, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86DReg@asmjit@@QEAA@AEBU_NoInit@1@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86DReg@asmjit@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clone@X86DReg@asmjit@@QEBA?AV12@XZ")]
                internal static extern void Clone(global::System.IntPtr instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromTypeAndId@X86DReg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromTypeAndId(global::System.IntPtr @return, uint rType, uint rId);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?fromSignature@X86DReg@asmjit@@SA?AV12@II@Z")]
                internal static extern void FromSignature(global::System.IntPtr @return, uint signature, uint rId);
            }

            public enum _0
            {
                kThisType = 21,
                kThisKind = 6,
                kThisSize = 0,
                kSignature = 1705
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86DReg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86DReg(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86DReg __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86DReg(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86DReg(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86DReg(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86DReg()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public X86DReg(global::GraphEngine.Jit.Native.Asmjit.X86DReg other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86DReg(global::GraphEngine.Jit.Native.Asmjit.Reg other, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, rId);
            }

            public X86DReg(global::GraphEngine.Jit.Native.Asmjit._Init init, uint signature, uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(init, null))
                    throw new global::System.ArgumentNullException("init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = init.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, signature, rId);
            }

            public X86DReg(global::GraphEngine.Jit.Native.Asmjit._NoInit _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public X86DReg(uint rId)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), rId);
            }

            public global::GraphEngine.Jit.Native.Asmjit.X86DReg Clone()
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal();
                __Internal.Clone((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86DReg FromTypeAndId(uint rType, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal();
                __Internal.FromTypeAndId(new IntPtr(&__ret), rType, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(__ret);
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86DReg FromSignature(uint signature, uint rId)
            {
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal();
                __Internal.FromSignature(new IntPtr(&__ret), signature, rId);
                return global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(__ret);
            }
        }

        public unsafe partial class X86OpData : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 3904)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.ArchRegs.__Internal archRegs;

                [FieldOffset(192)]
                internal fixed byte rip[16];

                [FieldOffset(208)]
                internal fixed byte seg[112];

                [FieldOffset(320)]
                internal fixed byte gpbLo[256];

                [FieldOffset(576)]
                internal fixed byte gpbHi[64];

                [FieldOffset(640)]
                internal fixed byte gpw[256];

                [FieldOffset(896)]
                internal fixed byte gpd[256];

                [FieldOffset(1152)]
                internal fixed byte gpq[256];

                [FieldOffset(1408)]
                internal fixed byte fp[128];

                [FieldOffset(1536)]
                internal fixed byte mm[128];

                [FieldOffset(1664)]
                internal fixed byte k[128];

                [FieldOffset(1792)]
                internal fixed byte xmm[512];

                [FieldOffset(2304)]
                internal fixed byte ymm[512];

                [FieldOffset(2816)]
                internal fixed byte zmm[512];

                [FieldOffset(3328)]
                internal fixed byte bnd[64];

                [FieldOffset(3392)]
                internal fixed byte cr[256];

                [FieldOffset(3648)]
                internal fixed byte dr[256];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86OpData@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86OpData@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86OpData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86OpData>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.X86OpData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86OpData(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86OpData __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86OpData.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86OpData(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86OpData.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86OpData.__Internal));
                global::GraphEngine.Jit.Native.Asmjit.X86OpData.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private X86OpData(global::GraphEngine.Jit.Native.Asmjit.X86OpData.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86OpData(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86OpData(global::GraphEngine.Jit.Native.Asmjit.X86OpData _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86OpData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public X86OpData()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86OpData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.X86OpData __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class x86operand
        {
            public partial struct __Internal
            {
            }

            public static global::GraphEngine.Jit.Native.Asmjit.X86OpData x86OpData
            {
                get
                {
                    var __ptr = (global::GraphEngine.Jit.Native.Asmjit.X86OpData.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?x86OpData@asmjit@@3UX86OpData@1@B");
                    return global::GraphEngine.Jit.Native.Asmjit.X86OpData.__CreateInstance(*__ptr);
                }
            }
        }

        namespace X86
        {
            public unsafe partial class x86operand
            {
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?gpb@x86@asmjit@@YA?AVX86GpbLo@2@I@Z")]
                    internal static extern void Gpb(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?gpb_lo@x86@asmjit@@YA?AVX86GpbLo@2@I@Z")]
                    internal static extern void GpbLo(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?gpb_hi@x86@asmjit@@YA?AVX86GpbHi@2@I@Z")]
                    internal static extern void GpbHi(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?gpw@x86@asmjit@@YA?AVX86Gpw@2@I@Z")]
                    internal static extern void Gpw(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?gpd@x86@asmjit@@YA?AVX86Gpd@2@I@Z")]
                    internal static extern void Gpd(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?gpq@x86@asmjit@@YA?AVX86Gpq@2@I@Z")]
                    internal static extern void Gpq(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?fp@x86@asmjit@@YA?AVX86Fp@2@I@Z")]
                    internal static extern void Fp(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?mm@x86@asmjit@@YA?AVX86Mm@2@I@Z")]
                    internal static extern void Mm(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?k@x86@asmjit@@YA?AVX86KReg@2@I@Z")]
                    internal static extern void K(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?xmm@x86@asmjit@@YA?AVX86Xmm@2@I@Z")]
                    internal static extern void Xmm(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ymm@x86@asmjit@@YA?AVX86Ymm@2@I@Z")]
                    internal static extern void Ymm(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zmm@x86@asmjit@@YA?AVX86Zmm@2@I@Z")]
                    internal static extern void Zmm(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?bnd@x86@asmjit@@YA?AVX86Bnd@2@I@Z")]
                    internal static extern void Bnd(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?cr@x86@asmjit@@YA?AVX86CReg@2@I@Z")]
                    internal static extern void Cr(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dr@x86@asmjit@@YA?AVX86DReg@2@I@Z")]
                    internal static extern void Dr(global::System.IntPtr @return, uint rId);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@HI@Z")]
                    internal static extern void Ptr(global::System.IntPtr @return, global::System.IntPtr @base, int offset, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IHI@Z")]
                    internal static extern void Ptr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IHI@Z")]
                    internal static extern void Ptr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@HI@Z")]
                    internal static extern void Ptr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IHI@Z")]
                    internal static extern void Ptr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Vec@2@IHI@Z")]
                    internal static extern void Ptr_3(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@HI@Z")]
                    internal static extern void Ptr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@_KI@Z")]
                    internal static extern void Ptr(global::System.IntPtr @return, ulong @base, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Reg@2@II@Z")]
                    internal static extern void Ptr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@II@Z")]
                    internal static extern void Ptr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void Ptr8(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void Ptr8(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void Ptr8_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void Ptr8_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void Ptr8_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void Ptr8_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr8(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr8(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr8_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr8Abs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr8Abs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_8_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr8Abs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void Ptr16(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void Ptr16(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void Ptr16_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void Ptr16_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void Ptr16_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void Ptr16_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr16(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr16(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr16_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr16Abs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr16Abs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_16_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr16Abs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void Ptr32(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void Ptr32(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void Ptr32_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void Ptr32_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void Ptr32_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void Ptr32_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr32(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr32(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr32_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr32Abs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr32Abs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_32_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr32Abs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void Ptr48(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void Ptr48(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void Ptr48_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void Ptr48_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void Ptr48_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void Ptr48_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr48(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr48(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr48_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr48Abs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr48Abs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_48_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr48Abs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void Ptr64(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void Ptr64(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void Ptr64_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void Ptr64_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void Ptr64_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void Ptr64_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr64(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr64(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr64_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr64Abs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr64Abs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_64_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr64Abs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void Ptr80(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void Ptr80(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void Ptr80_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void Ptr80_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void Ptr80_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void Ptr80_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr80(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr80(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr80_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr80Abs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr80Abs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_80_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr80Abs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void Ptr128(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void Ptr128(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void Ptr128_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void Ptr128_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void Ptr128_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void Ptr128_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr128(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr128(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr128_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr128Abs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr128Abs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_128_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr128Abs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void Ptr256(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void Ptr256(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void Ptr256_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void Ptr256_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void Ptr256_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void Ptr256_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr256(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr256(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr256_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr256Abs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr256Abs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_256_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr256Abs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void Ptr512(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void Ptr512(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void Ptr512_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void Ptr512_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void Ptr512_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void Ptr512_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr512(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr512(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr512_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void Ptr512Abs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void Ptr512Abs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?ptr_512_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void Ptr512Abs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void BytePtr(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void BytePtr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void BytePtr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void BytePtr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void BytePtr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void BytePtr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void BytePtr(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void BytePtr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void BytePtr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void BytePtrAbs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void BytePtrAbs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?byte_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void BytePtrAbs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void WordPtr(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void WordPtr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void WordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void WordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void WordPtr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void WordPtr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void WordPtr(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void WordPtr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void WordPtr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void WordPtrAbs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void WordPtrAbs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?word_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void WordPtrAbs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void DwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void DwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void DwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void DwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void DwordPtr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void DwordPtr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void DwordPtr(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void DwordPtr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void DwordPtr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void DwordPtrAbs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void DwordPtrAbs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void DwordPtrAbs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void QwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void QwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void QwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void QwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void QwordPtr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void QwordPtr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void QwordPtr(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void QwordPtr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void QwordPtr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void QwordPtrAbs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void QwordPtrAbs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?qword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void QwordPtrAbs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void TwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void TwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void TwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void TwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void TwordPtr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void TwordPtr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void TwordPtr(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void TwordPtr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void TwordPtr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void TwordPtrAbs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void TwordPtrAbs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?tword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void TwordPtrAbs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void OwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void OwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void OwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void OwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void OwordPtr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void OwordPtr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void OwordPtr(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void OwordPtr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void OwordPtr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void OwordPtrAbs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void OwordPtrAbs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?oword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void OwordPtrAbs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void DqwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void DqwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void DqwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void DqwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void DqwordPtr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void DqwordPtr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void DqwordPtr(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void DqwordPtr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void DqwordPtr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void DqwordPtrAbs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void DqwordPtrAbs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?dqword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void DqwordPtrAbs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void YwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void YwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void YwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void YwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void YwordPtr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void YwordPtr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void YwordPtr(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void YwordPtr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void YwordPtr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void YwordPtrAbs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void YwordPtrAbs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?yword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void YwordPtrAbs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@H@Z")]
                    internal static extern void ZwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@0IH@Z")]
                    internal static extern void ZwordPtr(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Gp@2@AEBVX86Vec@2@IH@Z")]
                    internal static extern void ZwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@H@Z")]
                    internal static extern void ZwordPtr_1(global::System.IntPtr @return, global::System.IntPtr @base, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVLabel@2@AEBVX86Gp@2@IH@Z")]
                    internal static extern void ZwordPtr_2(global::System.IntPtr @return, global::System.IntPtr @base, global::System.IntPtr index, uint shift, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr@x86@asmjit@@YA?AVX86Mem@2@AEBVX86Rip@2@H@Z")]
                    internal static extern void ZwordPtr_2(global::System.IntPtr @return, global::System.IntPtr rip_, int offset);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void ZwordPtr(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void ZwordPtr(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void ZwordPtr_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_K@Z")]
                    internal static extern void ZwordPtrAbs(global::System.IntPtr @return, ulong @base);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Gp@2@I@Z")]
                    internal static extern void ZwordPtrAbs(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?zword_ptr_abs@x86@asmjit@@YA?AVX86Mem@2@_KAEBVX86Vec@2@I@Z")]
                    internal static extern void ZwordPtrAbs_1(global::System.IntPtr @return, ulong @base, global::System.IntPtr index, uint shift);
                }

                /// <summary>Create an 8-bit low GPB register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86GpbLo Gpb(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal();
                    __Internal.Gpb(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__CreateInstance(__ret);
                }

                /// <summary>Create an 8-bit low GPB register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86GpbLo GpbLo(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__Internal();
                    __Internal.GpbLo(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86GpbLo.__CreateInstance(__ret);
                }

                /// <summary>Create an 8-bit high GPB register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86GpbHi GpbHi(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__Internal();
                    __Internal.GpbHi(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86GpbHi.__CreateInstance(__ret);
                }

                /// <summary>Create a 16-bit GPW register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Gpw Gpw(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__Internal();
                    __Internal.Gpw(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Gpw.__CreateInstance(__ret);
                }

                /// <summary>Create a 32-bit GPD register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Gpd Gpd(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__Internal();
                    __Internal.Gpd(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Gpd.__CreateInstance(__ret);
                }

                /// <summary>Create a 64-bit GPQ register operand (X64).</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Gpq Gpq(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__Internal();
                    __Internal.Gpq(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Gpq.__CreateInstance(__ret);
                }

                /// <summary>Create an 80-bit Fp register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Fp Fp(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Fp.__Internal();
                    __Internal.Fp(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(__ret);
                }

                /// <summary>Create a 64-bit Mm register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mm Mm(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mm.__Internal();
                    __Internal.Mm(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(__ret);
                }

                /// <summary>Create a 64-bit K register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86KReg K(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86KReg.__Internal();
                    __Internal.K(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(__ret);
                }

                /// <summary>Create a 128-bit XMM register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__Internal();
                    __Internal.Xmm(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(__ret);
                }

                /// <summary>Create a 256-bit YMM register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__Internal();
                    __Internal.Ymm(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(__ret);
                }

                /// <summary>Create a 512-bit ZMM register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__Internal();
                    __Internal.Zmm(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(__ret);
                }

                /// <summary>Create a 128-bit bound register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Bnd Bnd(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__Internal();
                    __Internal.Bnd(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__CreateInstance(__ret);
                }

                /// <summary>Create a 32-bit or 64-bit control register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86CReg.__Internal();
                    __Internal.Cr(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(__ret);
                }

                /// <summary>Create a 32-bit or 64-bit debug register operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr(uint rId)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86DReg.__Internal();
                    __Internal.Dr(new IntPtr(&__ret), rId);
                    return global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(__ret);
                }

                /// <summary>Create a `[base.reg + offset]` memory operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset, uint size)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr(new IntPtr(&__ret), __arg0, offset, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                /// <summary>Create a `[base.reg + (index&lt;&gt;&lt;&gt;shift) + offset]` memory operand (scalar index).</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset, uint size)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr(new IntPtr(&__ret), __arg0, __arg1, shift, offset, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                /// <summary>Create a `[base.reg + (index&lt;&gt;&lt;&gt;shift) + offset]` memory operand (vector index).</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset, uint size)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                /// <summary>Create a `[base + offset]` memory operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset, uint size)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr_1(new IntPtr(&__ret), __arg0, offset, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                /// <summary>Create a `[base + (index&lt;&gt;&lt;&gt;shift) + offset]` memory operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset, uint size)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                /// <summary>Create a `[base + (index&lt;&gt;&lt;&gt;shift) + offset]` memory operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset, uint size)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr_3(new IntPtr(&__ret), __arg0, __arg1, shift, offset, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                /// <summary>Create `[rip + offset]` memory operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset, uint size)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr_2(new IntPtr(&__ret), __arg0, offset, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                /// <summary>Create an `[base]` absolute memory operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(ulong @base, uint size)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr(new IntPtr(&__ret), @base, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                /// <summary>Create an `[abs + (index.reg&lt;&gt;&lt;&gt;shift)]` absolute memory operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Reg index, uint shift, uint size)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr(new IntPtr(&__ret), @base, __arg1, shift, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                /// <summary>Create an `[abs + (index.reg&lt;&gt;&lt;&gt;shift)]` absolute memory operand.</summary>
                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, uint size)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr_1(new IntPtr(&__ret), @base, __arg1, shift, size);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8Abs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8Abs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8Abs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr8Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr8Abs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16Abs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16Abs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16Abs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr16Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr16Abs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32Abs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32Abs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32Abs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr32Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr32Abs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48Abs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48Abs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48Abs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr48Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr48Abs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64Abs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64Abs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64Abs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr64Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr64Abs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80Abs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80Abs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80Abs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr80Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr80Abs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128Abs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128Abs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128Abs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr128Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr128Abs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256Abs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256Abs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256Abs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr256Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr256Abs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512Abs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512Abs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512Abs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem Ptr512Abs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.Ptr512Abs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtr(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtr(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtr_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtr_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtr(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtr(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtr(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtr_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtrAbs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtrAbs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtrAbs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem BytePtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.BytePtrAbs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtr(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtr(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtr_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtr_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtr(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtr(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtr(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtr_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtrAbs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtrAbs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtrAbs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem WordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.WordPtrAbs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtr(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtr(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtr_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtr_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtr(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtr(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtr(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtr_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtrAbs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtrAbs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtrAbs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DwordPtrAbs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtr(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtr(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtr_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtr_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtr(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtr(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtr(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtr_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtrAbs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtrAbs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtrAbs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem QwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.QwordPtrAbs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtr(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtr(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtr_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtr_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtr(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtr(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtr(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtr_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtrAbs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtrAbs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtrAbs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem TwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.TwordPtrAbs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtr(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtr(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtr_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtr_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtr(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtr(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtr(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtr_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtrAbs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtrAbs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtrAbs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem OwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.OwordPtrAbs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtr(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtr(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtr_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtr_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtr(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtr(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtr(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtr_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtrAbs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtrAbs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtrAbs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem DqwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.DqwordPtrAbs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtr(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtr(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtr_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtr_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtr(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtr(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtr(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtr_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtrAbs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtrAbs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtrAbs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem YwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.YwordPtrAbs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtr(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtr(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Gp @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtr_1(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtr_1(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtr(global::GraphEngine.Jit.Native.Asmjit.Label @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift, int offset)
                {
                    if (ReferenceEquals(@base, null))
                        throw new global::System.ArgumentNullException("@base", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = @base.__Instance;
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtr_2(new IntPtr(&__ret), __arg0, __arg1, shift, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtr(global::GraphEngine.Jit.Native.Asmjit.X86Rip rip_, int offset)
                {
                    if (ReferenceEquals(rip_, null))
                        throw new global::System.ArgumentNullException("rip_", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = rip_.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtr_2(new IntPtr(&__ret), __arg0, offset);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtr(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtr(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtr(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtr(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtr_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtrAbs(ulong @base)
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtrAbs(new IntPtr(&__ret), @base);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Gp index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtrAbs(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mem ZwordPtrAbs(ulong @base, global::GraphEngine.Jit.Native.Asmjit.X86Vec index, uint shift)
                {
                    if (ReferenceEquals(index, null))
                        throw new global::System.ArgumentNullException("index", "Cannot be null because it is a C++ reference (&).");
                    var __arg1 = index.__Instance;
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.X86Mem.__Internal();
                    __Internal.ZwordPtrAbs_1(new IntPtr(&__ret), @base, __arg1, shift);
                    return global::GraphEngine.Jit.Native.Asmjit.X86Mem.__CreateInstance(__ret);
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Rip Rip
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rip@?A@x86@asmjit@@3AEBVX86Rip@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Rip __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Rip.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Rip) global::GraphEngine.Jit.Native.Asmjit.X86Rip.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Rip.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rip@?A@x86@asmjit@@3AEBVX86Rip@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Seg Es
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?es@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Seg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Seg) global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?es@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Seg Cs
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cs@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Seg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Seg) global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cs@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Seg Ss
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ss@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Seg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Seg) global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ss@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Seg Ds
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ds@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Seg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Seg) global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ds@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Seg Fs
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fs@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Seg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Seg) global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fs@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Seg Gs
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?gs@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Seg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Seg) global::GraphEngine.Jit.Native.Asmjit.X86Seg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Seg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?gs@?A@x86@asmjit@@3AEBVX86Seg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Al
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?al@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?al@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Cl
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Dl
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Bl
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Spl
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?spl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?spl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Bpl
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bpl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bpl@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Sil
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?sil@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?sil@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Dil
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dil@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dil@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R8b
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r8b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r8b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R9b
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r9b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r9b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R10b
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r10b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r10b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R11b
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r11b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r11b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R12b
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r12b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r12b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R13b
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r13b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r13b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R14b
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r14b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r14b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R15b
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r15b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r15b@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Ah
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ah@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ah@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Ch
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ch@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ch@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Dh
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dh@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dh@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Bh
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bh@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bh@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Ax
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ax@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ax@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Cx
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Dx
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Bx
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Sp
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?sp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?sp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Bp
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Si
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?si@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?si@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Di
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?di@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?di@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R8w
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r8w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r8w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R9w
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r9w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r9w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R10w
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r10w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r10w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R11w
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r11w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r11w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R12w
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r12w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r12w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R13w
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r13w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r13w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R14w
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r14w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r14w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R15w
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r15w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r15w@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Eax
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?eax@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?eax@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Ecx
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ecx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ecx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Edx
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?edx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?edx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Ebx
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ebx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ebx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Esp
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?esp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?esp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Ebp
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ebp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ebp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Esi
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?esi@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?esi@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Edi
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?edi@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?edi@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R8d
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r8d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r8d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R9d
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r9d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r9d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R10d
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r10d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r10d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R11d
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r11d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r11d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R12d
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r12d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r12d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R13d
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r13d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r13d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R14d
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r14d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r14d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R15d
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r15d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r15d@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Rax
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rax@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rax@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Rcx
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rcx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rcx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Rdx
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rdx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rdx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Rbx
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rbx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rbx@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Rsp
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rsp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rsp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Rbp
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rbp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rbp@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Rsi
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rsi@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rsi@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp Rdi
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rdi@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?rdi@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R8
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r8@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r8@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R9
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r9@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r9@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R10
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r10@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r10@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R11
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r11@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r11@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R12
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r12@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r12@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R13
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r13@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r13@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R14
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r14@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r14@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Gp R15
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r15@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Gp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Gp) global::GraphEngine.Jit.Native.Asmjit.X86Gp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Gp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?r15@?A@x86@asmjit@@3AEBVX86Gp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Fp Fp0
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp0@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Fp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Fp) global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp0@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Fp Fp1
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp1@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Fp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Fp) global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp1@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Fp Fp2
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp2@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Fp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Fp) global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp2@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Fp Fp3
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp3@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Fp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Fp) global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp3@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Fp Fp4
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp4@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Fp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Fp) global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp4@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Fp Fp5
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp5@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Fp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Fp) global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp5@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Fp Fp6
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp6@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Fp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Fp) global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp6@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Fp Fp7
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp7@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Fp __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Fp) global::GraphEngine.Jit.Native.Asmjit.X86Fp.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Fp.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?fp7@?A@x86@asmjit@@3AEBVX86Fp@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mm Mm0
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm0@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Mm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Mm) global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm0@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mm Mm1
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm1@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Mm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Mm) global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm1@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mm Mm2
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm2@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Mm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Mm) global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm2@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mm Mm3
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm3@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Mm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Mm) global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm3@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mm Mm4
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm4@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Mm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Mm) global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm4@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mm Mm5
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm5@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Mm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Mm) global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm5@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mm Mm6
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm6@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Mm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Mm) global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm6@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Mm Mm7
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm7@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Mm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Mm) global::GraphEngine.Jit.Native.Asmjit.X86Mm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Mm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?mm7@?A@x86@asmjit@@3AEBVX86Mm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86KReg K0
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k0@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86KReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86KReg) global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k0@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86KReg K1
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k1@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86KReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86KReg) global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k1@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86KReg K2
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k2@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86KReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86KReg) global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k2@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86KReg K3
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k3@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86KReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86KReg) global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k3@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86KReg K4
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k4@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86KReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86KReg) global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k4@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86KReg K5
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k5@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86KReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86KReg) global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k5@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86KReg K6
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k6@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86KReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86KReg) global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k6@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86KReg K7
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k7@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86KReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86KReg) global::GraphEngine.Jit.Native.Asmjit.X86KReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86KReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?k7@?A@x86@asmjit@@3AEBVX86KReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm0
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm0@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm0@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm1
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm1@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm1@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm2
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm2@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm2@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm3
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm3@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm3@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm4
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm4@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm4@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm5
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm5@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm5@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm6
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm6@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm6@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm7
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm7@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm7@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm8
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm8@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm8@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm9
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm9@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm9@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm10
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm10@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm10@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm11
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm11@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm11@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm12
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm12@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm12@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm13
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm13@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm13@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm14
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm14@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm14@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm15
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm15@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm15@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm16
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm16@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm16@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm17
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm17@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm17@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm18
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm18@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm18@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm19
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm19@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm19@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm20
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm20@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm20@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm21
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm21@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm21@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm22
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm22@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm22@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm23
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm23@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm23@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm24
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm24@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm24@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm25
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm25@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm25@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm26
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm26@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm26@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm27
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm27@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm27@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm28
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm28@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm28@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm29
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm29@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm29@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm30
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm30@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm30@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Xmm Xmm31
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm31@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Xmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Xmm) global::GraphEngine.Jit.Native.Asmjit.X86Xmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Xmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?xmm31@?A@x86@asmjit@@3AEBVX86Xmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm0
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm0@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm0@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm1
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm1@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm1@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm2
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm2@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm2@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm3
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm3@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm3@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm4
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm4@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm4@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm5
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm5@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm5@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm6
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm6@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm6@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm7
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm7@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm7@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm8
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm8@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm8@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm9
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm9@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm9@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm10
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm10@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm10@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm11
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm11@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm11@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm12
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm12@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm12@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm13
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm13@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm13@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm14
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm14@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm14@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm15
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm15@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm15@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm16
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm16@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm16@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm17
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm17@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm17@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm18
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm18@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm18@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm19
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm19@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm19@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm20
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm20@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm20@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm21
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm21@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm21@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm22
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm22@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm22@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm23
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm23@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm23@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm24
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm24@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm24@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm25
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm25@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm25@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm26
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm26@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm26@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm27
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm27@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm27@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm28
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm28@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm28@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm29
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm29@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm29@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm30
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm30@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm30@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Ymm Ymm31
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm31@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Ymm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Ymm) global::GraphEngine.Jit.Native.Asmjit.X86Ymm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Ymm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?ymm31@?A@x86@asmjit@@3AEBVX86Ymm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm0
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm0@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm0@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm1
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm1@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm1@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm2
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm2@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm2@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm3
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm3@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm3@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm4
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm4@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm4@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm5
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm5@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm5@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm6
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm6@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm6@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm7
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm7@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm7@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm8
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm8@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm8@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm9
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm9@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm9@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm10
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm10@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm10@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm11
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm11@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm11@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm12
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm12@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm12@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm13
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm13@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm13@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm14
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm14@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm14@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm15
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm15@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm15@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm16
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm16@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm16@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm17
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm17@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm17@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm18
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm18@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm18@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm19
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm19@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm19@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm20
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm20@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm20@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm21
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm21@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm21@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm22
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm22@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm22@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm23
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm23@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm23@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm24
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm24@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm24@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm25
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm25@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm25@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm26
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm26@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm26@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm27
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm27@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm27@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm28
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm28@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm28@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm29
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm29@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm29@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm30
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm30@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm30@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Zmm Zmm31
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm31@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Zmm __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Zmm) global::GraphEngine.Jit.Native.Asmjit.X86Zmm.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Zmm.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?zmm31@?A@x86@asmjit@@3AEBVX86Zmm@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Bnd Bnd0
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bnd0@?A@x86@asmjit@@3AEBVX86Bnd@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Bnd __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Bnd.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Bnd) global::GraphEngine.Jit.Native.Asmjit.X86Bnd.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bnd0@?A@x86@asmjit@@3AEBVX86Bnd@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Bnd Bnd1
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bnd1@?A@x86@asmjit@@3AEBVX86Bnd@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Bnd __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Bnd.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Bnd) global::GraphEngine.Jit.Native.Asmjit.X86Bnd.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bnd1@?A@x86@asmjit@@3AEBVX86Bnd@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Bnd Bnd2
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bnd2@?A@x86@asmjit@@3AEBVX86Bnd@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Bnd __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Bnd.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Bnd) global::GraphEngine.Jit.Native.Asmjit.X86Bnd.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bnd2@?A@x86@asmjit@@3AEBVX86Bnd@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86Bnd Bnd3
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bnd3@?A@x86@asmjit@@3AEBVX86Bnd@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86Bnd __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86Bnd.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86Bnd) global::GraphEngine.Jit.Native.Asmjit.X86Bnd.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86Bnd.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?bnd3@?A@x86@asmjit@@3AEBVX86Bnd@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr0
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr0@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr0@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr1
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr1@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr1@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr2
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr2@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr2@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr3
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr3@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr3@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr4
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr4@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr4@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr5
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr5@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr5@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr6
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr6@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr6@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr7
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr7@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr7@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr8
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr8@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr8@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr9
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr9@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr9@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr10
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr10@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr10@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr11
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr11@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr11@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr12
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr12@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr12@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr13
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr13@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr13@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr14
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr14@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr14@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86CReg Cr15
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr15@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86CReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86CReg) global::GraphEngine.Jit.Native.Asmjit.X86CReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86CReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?cr15@?A@x86@asmjit@@3AEBVX86CReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr0
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr0@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr0@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr1
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr1@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr1@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr2
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr2@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr2@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr3
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr3@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr3@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr4
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr4@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr4@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr5
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr5@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr5@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr6
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr6@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr6@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr7
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr7@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr7@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr8
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr8@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr8@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr9
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr9@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr9@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr10
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr10@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr10@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr11
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr11@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr11@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr12
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr12@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr12@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr13
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr13@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr13@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr14
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr14@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr14@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }

                public static global::GraphEngine.Jit.Native.Asmjit.X86DReg Dr15
                {
                    get
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr15@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        global::GraphEngine.Jit.Native.Asmjit.X86DReg __result0;
                        if (*__ptr == IntPtr.Zero) __result0 = null;
                        else if (global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap.ContainsKey(*__ptr))
                            __result0 = (global::GraphEngine.Jit.Native.Asmjit.X86DReg) global::GraphEngine.Jit.Native.Asmjit.X86DReg.NativeToManagedMap[*__ptr];
                        else __result0 = global::GraphEngine.Jit.Native.Asmjit.X86DReg.__CreateInstance(*__ptr);
                        return __result0;
                    }

                    set
                    {
                        var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("asmjit", "?dr15@?A@x86@asmjit@@3AEBVX86DReg@2@EB");
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        *__ptr = value.__Instance;
                    }
                }
            }
        }
    }

    namespace Asmjit
    {
        namespace X86EmitterExplicitT
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public unsafe partial struct __Internal
            {
            }
        }

        namespace X86EmitterImplicitT
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public unsafe partial struct __Internal
            {
            }
        }

        /// <summary>X86/X64 emitter.</summary>
        /// <remarks>
        /// <para>NOTE: This class cannot be created, you can only cast to it and use it as</para>
        /// <para>emitter that emits to either X86Assembler, X86Builder, or X86Compiler (use</para>
        /// <para>with caution with X86Compiler as it expects virtual registers to be used).</para>
        /// </remarks>
        public unsafe abstract partial class X86Emitter : global::GraphEngine.Jit.Native.Asmjit.CodeEmitter, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 120)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_CodeEmitter;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(24)]
                internal global::System.IntPtr _code;

                [FieldOffset(32)]
                internal global::System.IntPtr _nextEmitter;

                [FieldOffset(40)]
                internal byte _type;

                [FieldOffset(41)]
                internal byte _destroyed;

                [FieldOffset(42)]
                internal byte _finalized;

                [FieldOffset(43)]
                internal byte _reserved;

                [FieldOffset(44)]
                internal uint _lastError;

                [FieldOffset(48)]
                internal uint _privateData;

                [FieldOffset(52)]
                internal uint _globalHints;

                [FieldOffset(56)]
                internal uint _globalOptions;

                [FieldOffset(60)]
                internal uint _options;

                [FieldOffset(64)]
                internal global::GraphEngine.Jit.Native.Asmjit.RegOnly.__Internal _extraReg;

                [FieldOffset(72)]
                internal global::System.IntPtr _inlineComment;

                [FieldOffset(80)]
                internal global::GraphEngine.Jit.Native.Asmjit.Operand_.__Internal _none;

                [FieldOffset(96)]
                internal global::GraphEngine.Jit.Native.Asmjit.Reg.__Internal _nativeGpReg;

                [FieldOffset(112)]
                internal global::System.IntPtr _nativeGpArray;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1X86Emitter@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.X86Emitter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86EmitterInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86Emitter __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86Emitter.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86EmitterInternal(native, skipVTables);
            }

            protected X86Emitter(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.CodeEmitter __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.X86Emitter.__Internal*) __Instance)->vfptr_CodeEmitter = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // X86Emitter
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error onAttach(CodeHolder* code) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnAttachDelegateInstance;

            private static uint _OnAttachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnAttach(__result0);
                return __ret;
            }

            // Error onDetach(CodeHolder* code) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _OnDetachDelegateInstance;

            private static uint _OnDetachDelegateHook(global::System.IntPtr instance, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result0;
                if (code == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.OnDetach(__result0);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3, const Operand_& o4, const Operand_& o5) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _EmitDelegateInstance;

            private static uint _EmitDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3, global::System.IntPtr o4, global::System.IntPtr o5)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result5;
                if (o4 == IntPtr.Zero) __result5 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o4))
                    __result5 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o4];
                else __result5 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o4);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result6;
                if (o5 == IntPtr.Zero) __result6 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o5))
                    __result6 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o5];
                else __result6 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o5);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4, __result5, __result6);
                return __ret;
            }

            // Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr _Emit_1DelegateInstance;

            private static uint _Emit_1DelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr o0, global::System.IntPtr o1, global::System.IntPtr o2, global::System.IntPtr o3)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (o0 == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o0))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o0];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o0);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result2;
                if (o1 == IntPtr.Zero) __result2 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o1))
                    __result2 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o1];
                else __result2 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o1);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result3;
                if (o2 == IntPtr.Zero) __result3 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o2))
                    __result3 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o2];
                else __result3 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o2);
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result4;
                if (o3 == IntPtr.Zero) __result4 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(o3))
                    __result4 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[o3];
                else __result4 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(o3);
                var __ret = __target.Emit(instId, __result1, __result2, __result3, __result4);
                return __ret;
            }

            // Error _emitOpArray(uint32_t instId, const Operand_* opArray, size_t opCount)
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_ulong _EmitOpArrayDelegateInstance;

            private static uint _EmitOpArrayDelegateHook(global::System.IntPtr instance, uint instId, global::System.IntPtr opArray, ulong opCount)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Operand_ __result1;
                if (opArray == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap.ContainsKey(opArray))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.Operand_) global::GraphEngine.Jit.Native.Asmjit.Operand_.NativeToManagedMap[opArray];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.Operand_.__CreateInstance(opArray);
                var __ret = __target.EmitOpArray(instId, __result1, opCount);
                return __ret;
            }

            // Label newLabel() = 0
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr _NewLabelDelegateInstance;

            private static void _NewLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewLabel();
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Label newNamedLabel( const char* name, size_t nameLength = Globals::kInvalidIndex, uint32_t type = Label::kTypeGlobal, uint32_t parentId = 0) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint _NewNamedLabelDelegateInstance;

            private static void _NewNamedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string name, ulong nameLength, uint type, uint parentId)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.NewNamedLabel(name, nameLength, type, parentId);
                *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal() : *(global::GraphEngine.Jit.Native.Asmjit.Label.__Internal*) __ret.__Instance;
            }

            // Error bind(const Label& label) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _BindDelegateInstance;

            private static uint _BindDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.Bind(__result0);
                return __ret;
            }

            // Error align(uint32_t mode, uint32_t alignment) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint _AlignDelegateInstance;

            private static uint _AlignDelegateHook(global::System.IntPtr instance, uint mode, uint alignment)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Align(mode, alignment);
                return __ret;
            }

            // Error embed(const void* data, uint32_t size) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint _EmbedDelegateInstance;

            private static uint _EmbedDelegateHook(global::System.IntPtr instance, global::System.IntPtr data, uint size)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Embed(data, size);
                return __ret;
            }

            // Error embedLabel(const Label& label) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _EmbedLabelDelegateInstance;

            private static uint _EmbedLabelDelegateHook(global::System.IntPtr instance, global::System.IntPtr label)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                var __ret = __target.EmbedLabel(__result0);
                return __ret;
            }

            // Error embedConstPool(const Label& label, const ConstPool& pool) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr _EmbedConstPoolDelegateInstance;

            private static uint _EmbedConstPoolDelegateHook(global::System.IntPtr instance, global::System.IntPtr label, global::System.IntPtr pool)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.Label __result0;
                if (label == IntPtr.Zero) __result0 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap.ContainsKey(label))
                    __result0 = (global::GraphEngine.Jit.Native.Asmjit.Label) global::GraphEngine.Jit.Native.Asmjit.Label.NativeToManagedMap[label];
                else __result0 = global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(label);
                global::GraphEngine.Jit.Native.Asmjit.ConstPool __result1;
                if (pool == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap.ContainsKey(pool))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.ConstPool) global::GraphEngine.Jit.Native.Asmjit.ConstPool.NativeToManagedMap[pool];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.ConstPool.__CreateInstance(pool);
                var __ret = __target.EmbedConstPool(__result0, __result1);
                return __ret;
            }

            // Error comment(const char* s, size_t len = Globals::kInvalidIndex) = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong _CommentDelegateInstance;

            private static uint _CommentDelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s, ulong len)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Comment(s, len);
                return __ret;
            }

            // Error finalize()
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr _FinalizeDelegateInstance;

            private static uint _FinalizeDelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.X86Emitter) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Finalize();
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[15];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _OnAttachDelegateInstance += _OnAttachDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnAttachDelegateInstance).ToPointer();
                    _OnDetachDelegateInstance += _OnDetachDelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnDetachDelegateInstance).ToPointer();
                    _EmitDelegateInstance += _EmitDelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EmitDelegateInstance).ToPointer();
                    _Emit_1DelegateInstance += _Emit_1DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Emit_1DelegateInstance).ToPointer();
                    _EmitOpArrayDelegateInstance += _EmitOpArrayDelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_EmitOpArrayDelegateInstance).ToPointer();
                    _NewLabelDelegateInstance += _NewLabelDelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_NewLabelDelegateInstance).ToPointer();
                    _NewNamedLabelDelegateInstance += _NewNamedLabelDelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_NewNamedLabelDelegateInstance).ToPointer();
                    _BindDelegateInstance += _BindDelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_BindDelegateInstance).ToPointer();
                    _AlignDelegateInstance += _AlignDelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_AlignDelegateInstance).ToPointer();
                    _EmbedDelegateInstance += _EmbedDelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_EmbedDelegateInstance).ToPointer();
                    _EmbedLabelDelegateInstance += _EmbedLabelDelegateHook;
                    _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_EmbedLabelDelegateInstance).ToPointer();
                    _EmbedConstPoolDelegateInstance += _EmbedConstPoolDelegateHook;
                    _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_EmbedConstPoolDelegateInstance).ToPointer();
                    _CommentDelegateInstance += _CommentDelegateHook;
                    _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_CommentDelegateInstance).ToPointer();
                    _FinalizeDelegateInstance += _FinalizeDelegateHook;
                    _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_FinalizeDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(15 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                        *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                        *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                        *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                        *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                        *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                        *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                        *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                        *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                        *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                        *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                        *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                        *(void**) (vfptr0 + 104) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 104);
                        *(void**) (vfptr0 + 112) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 112);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(15 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                        *(void**) (vfptr0 + 16) = _Thunks[2];
                        *(void**) (vfptr0 + 24) = _Thunks[3];
                        *(void**) (vfptr0 + 32) = _Thunks[4];
                        *(void**) (vfptr0 + 40) = _Thunks[5];
                        *(void**) (vfptr0 + 48) = _Thunks[6];
                        *(void**) (vfptr0 + 56) = _Thunks[7];
                        *(void**) (vfptr0 + 64) = _Thunks[8];
                        *(void**) (vfptr0 + 72) = _Thunks[9];
                        *(void**) (vfptr0 + 80) = _Thunks[10];
                        *(void**) (vfptr0 + 88) = _Thunks[11];
                        *(void**) (vfptr0 + 96) = _Thunks[12];
                        *(void**) (vfptr0 + 104) = _Thunks[13];
                        *(void**) (vfptr0 + 112) = _Thunks[14];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        public unsafe partial class X86EmitterInternal : global::GraphEngine.Jit.Native.Asmjit.X86Emitter, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86Emitter.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86Emitter.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.X86Emitter.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal X86EmitterInternal(global::GraphEngine.Jit.Native.Asmjit.X86Emitter.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal X86EmitterInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Called after the</summary>
            public override uint OnAttach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___OnAttachDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___OnAttachDelegate((__Instance), __arg0);
                return __ret;
            }

            /// <summary>Called after the</summary>
            public override uint OnDetach(global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___OnDetachDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___OnDetachDelegate((__Instance), __arg0);
                return __ret;
            }

            /// <summary>Emit instruction having max 6 operands.</summary>
            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3, global::GraphEngine.Jit.Native.Asmjit.Operand_ o4, global::GraphEngine.Jit.Native.Asmjit.Operand_ o5)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___EmitDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                if (ReferenceEquals(o4, null))
                    throw new global::System.ArgumentNullException("o4", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = o4.__Instance;
                if (ReferenceEquals(o5, null))
                    throw new global::System.ArgumentNullException("o5", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = o5.__Instance;
                var __ret = ___EmitDelegate((__Instance), instId, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                return __ret;
            }

            /// <summary>Create a new label.</summary>
            public override global::GraphEngine.Jit.Native.Asmjit.Label NewLabel()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___NewLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                ___NewLabelDelegate((__Instance), new IntPtr(&__ret));
                return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
            }

            /// <summary>Create a new named label.</summary>
            public override global::GraphEngine.Jit.Native.Asmjit.Label NewNamedLabel(string name, ulong nameLength, uint type, uint parentId)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___NewNamedLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_string_ulong_uint_uint));
                var __ret = new global::GraphEngine.Jit.Native.Asmjit.Label.__Internal();
                ___NewNamedLabelDelegate((__Instance), new IntPtr(&__ret), name, nameLength, type, parentId);
                return global::GraphEngine.Jit.Native.Asmjit.Label.__CreateInstance(__ret);
            }

            /// <summary>Bind the `label` to the current position of the current section.</summary>
            /// <remarks>NOTE: Attempt to bind the same label multiple times will return an error.</remarks>
            public override uint Bind(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___BindDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = ___BindDelegate((__Instance), __arg0);
                return __ret;
            }

            /// <summary>Embed raw data into the code-buffer.</summary>
            public override uint Embed(global::System.IntPtr data, uint size)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
                var ___EmbedDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_uint));
                var __ret = ___EmbedDelegate((__Instance), data, size);
                return __ret;
            }

            /// <summary>Embed absolute label address as data (4 or 8 bytes).</summary>
            public override uint EmbedLabel(global::GraphEngine.Jit.Native.Asmjit.Label label)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
                var ___EmbedLabelDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                var __ret = ___EmbedLabelDelegate((__Instance), __arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Embed a constant pool into the code-buffer in the following steps:</para>
            /// <para>1. Align by using kAlignData to the minimum `pool` alignment.</para>
            /// <para>2. Bind `label` so it's bound to an aligned location.</para>
            /// <para>3. Emit constant pool data.</para>
            /// </summary>
            public override uint EmbedConstPool(global::GraphEngine.Jit.Native.Asmjit.Label label, global::GraphEngine.Jit.Native.Asmjit.ConstPool pool)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
                var ___EmbedConstPoolDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(label, null))
                    throw new global::System.ArgumentNullException("label", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = label.__Instance;
                if (ReferenceEquals(pool, null))
                    throw new global::System.ArgumentNullException("pool", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = pool.__Instance;
                var __ret = ___EmbedConstPoolDelegate((__Instance), __arg0, __arg1);
                return __ret;
            }

            /// <summary>Emit a comment string `s` with an optional `len` parameter.</summary>
            public override uint Comment(string s, ulong len)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 13 * 8);
                var ___CommentDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_string_ulong));
                var __ret = ___CommentDelegate((__Instance), s, len);
                return __ret;
            }

            /// <summary>Emit instruction having max 4 operands.</summary>
            public override uint Emit(uint instId, global::GraphEngine.Jit.Native.Asmjit.Operand_ o0, global::GraphEngine.Jit.Native.Asmjit.Operand_ o1, global::GraphEngine.Jit.Native.Asmjit.Operand_ o2, global::GraphEngine.Jit.Native.Asmjit.Operand_ o3)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___Emit_1Delegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr));
                if (ReferenceEquals(o0, null))
                    throw new global::System.ArgumentNullException("o0", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = o0.__Instance;
                if (ReferenceEquals(o1, null))
                    throw new global::System.ArgumentNullException("o1", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = o1.__Instance;
                if (ReferenceEquals(o2, null))
                    throw new global::System.ArgumentNullException("o2", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = o2.__Instance;
                if (ReferenceEquals(o3, null))
                    throw new global::System.ArgumentNullException("o3", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = o3.__Instance;
                var __ret = ___Emit_1Delegate((__Instance), instId, __arg1, __arg2, __arg3, __arg4);
                return __ret;
            }

            /// <summary>Align to the `alignment` specified.</summary>
            /// <remarks>
            /// <para>The sequence that is used to fill the gap between the aligned location</para>
            /// <para>and the current location depends on the align `mode`, see</para>
            /// </remarks>
            public override uint Align(uint mode, uint alignment)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
                var ___AlignDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_uint_uint));
                var __ret = ___AlignDelegate((__Instance), mode, alignment);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>X86/X64 registers count.</summary>
        /// <remarks>
        /// <para>Since the number of registers changed across CPU generations `X86RegCount`</para>
        /// <para>class is used by `X86Assembler` and `X86Compiler` to provide a way to get</para>
        /// <para>number of available registers dynamically. 32-bit mode offers always only</para>
        /// <para>8 registers of all classes, however, 64-bit mode offers 16 GP registers and</para>
        /// <para>16 XMM/YMM/ZMM registers. AVX512 instruction set doubles the number of SIMD</para>
        /// <para>registers (XMM/YMM/ZMM) to 32, this mode has to be explicitly enabled to</para>
        /// <para>take effect as it changes some assumptions.</para>
        /// <para>`X86RegCount` is also used extensively by X86Compiler's register allocator</para>
        /// <para>and data structures. FP registers were omitted as they are never mapped to</para>
        /// <para>variables, thus, not needed to be managed.</para>
        /// <para>NOTE: At the moment `X86RegCount` can fit into 32-bits, having 8-bits for</para>
        /// <para>each register kind except FP. This can change in the future after a new</para>
        /// <para>instruction set, which adds more registers, is introduced.</para>
        /// </remarks>
        public unsafe partial class X86RegCount : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.X86RegCount._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86RegCount@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@X86RegCount@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get@X86RegCount@asmjit@@QEBAII@Z")]
                internal static extern uint Get(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set@X86RegCount@asmjit@@QEAAXII@Z")]
                internal static extern void Set(global::System.IntPtr instance, uint kind, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?add@X86RegCount@asmjit@@QEAAXII@Z")]
                internal static extern void Add(global::System.IntPtr instance, uint kind, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addGp@X86RegCount@asmjit@@QEAAXI@Z")]
                internal static extern void AddGp(global::System.IntPtr instance, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addMm@X86RegCount@asmjit@@QEAAXI@Z")]
                internal static extern void AddMm(global::System.IntPtr instance, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addK@X86RegCount@asmjit@@QEAAXI@Z")]
                internal static extern void AddK(global::System.IntPtr instance, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addVec@X86RegCount@asmjit@@QEAAXI@Z")]
                internal static extern void AddVec(global::System.IntPtr instance, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?indexFromRegCount@X86RegCount@asmjit@@QEAAXAEBU12@@Z")]
                internal static extern void IndexFromRegCount(global::System.IntPtr instance, global::System.IntPtr count);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGp@X86RegCount@asmjit@@QEBAIXZ")]
                internal static extern uint GetGp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setGp@X86RegCount@asmjit@@QEAAXI@Z")]
                internal static extern void SetGp(global::System.IntPtr instance, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getMm@X86RegCount@asmjit@@QEBAIXZ")]
                internal static extern uint GetMm(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setMm@X86RegCount@asmjit@@QEAAXI@Z")]
                internal static extern void SetMm(global::System.IntPtr instance, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getK@X86RegCount@asmjit@@QEBAIXZ")]
                internal static extern uint GetK(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setK@X86RegCount@asmjit@@QEAAXI@Z")]
                internal static extern void SetK(global::System.IntPtr instance, uint n);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVec@X86RegCount@asmjit@@QEBAIXZ")]
                internal static extern uint GetVec(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setVec@X86RegCount@asmjit@@QEAAXI@Z")]
                internal static extern void SetVec(global::System.IntPtr instance, uint n);
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.X86RegCount._.__.__Internal __;

                    [FieldOffset(0)]
                    internal fixed byte _regs[4];

                    [FieldOffset(0)]
                    internal uint _packed;
                }

                public unsafe partial class __
                {
                    [StructLayout(LayoutKind.Explicit, Size = 4)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal byte _gp;

                        [FieldOffset(1)]
                        internal byte _vec;

                        [FieldOffset(2)]
                        internal byte _mm;

                        [FieldOffset(3)]
                        internal byte _k;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86RegCount> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86RegCount>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.X86RegCount __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86RegCount(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86RegCount __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86RegCount.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86RegCount(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86RegCount.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86RegCount.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.X86RegCount.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private X86RegCount(global::GraphEngine.Jit.Native.Asmjit.X86RegCount.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86RegCount(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86RegCount()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86RegCount.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public X86RegCount(global::GraphEngine.Jit.Native.Asmjit.X86RegCount _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86RegCount.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.X86RegCount.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.X86RegCount.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.X86RegCount __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Reset all counters to zero.</summary>
            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Get register count by a register `kind`.</summary>
            public uint Get(uint kind)
            {
                var __ret = __Internal.Get((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            /// <summary>Set register count by a register `kind`.</summary>
            public void Set(uint kind, uint n)
            {
                __Internal.Set((__Instance + __PointerAdjustment), kind, n);
            }

            /// <summary>Add register count by a register `kind`.</summary>
            public void Add(uint kind, uint n)
            {
                __Internal.Add((__Instance + __PointerAdjustment), kind, n);
            }

            /// <summary>Add GP count.</summary>
            public void AddGp(uint n)
            {
                __Internal.AddGp((__Instance + __PointerAdjustment), n);
            }

            /// <summary>Add MMX count.</summary>
            public void AddMm(uint n)
            {
                __Internal.AddMm((__Instance + __PointerAdjustment), n);
            }

            /// <summary>Add K count.</summary>
            public void AddK(uint n)
            {
                __Internal.AddK((__Instance + __PointerAdjustment), n);
            }

            /// <summary>Add XMM/YMM/ZMM count.</summary>
            public void AddVec(uint n)
            {
                __Internal.AddVec((__Instance + __PointerAdjustment), n);
            }

            /// <summary>Build register indexes based on the given `count` of registers.</summary>
            public void IndexFromRegCount(global::GraphEngine.Jit.Native.Asmjit.X86RegCount count)
            {
                if (ReferenceEquals(count, null))
                    throw new global::System.ArgumentNullException("count", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = count.__Instance;
                __Internal.IndexFromRegCount((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Get Gp count.</summary>
            /// <remarks>Set Gp count.</remarks>
            public uint Gp
            {
                get
                {
                    var __ret = __Internal.GetGp((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetGp((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get Mm count.</summary>
            /// <remarks>Set Mm count.</remarks>
            public uint Mm
            {
                get
                {
                    var __ret = __Internal.GetMm((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetMm((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get K count.</summary>
            /// <remarks>Set K count.</remarks>
            public uint K
            {
                get
                {
                    var __ret = __Internal.GetK((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetK((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get XMM/YMM/ZMM count.</summary>
            /// <remarks>Set XMM/YMM/ZMM count.</remarks>
            public uint Vec
            {
                get
                {
                    var __ret = __Internal.GetVec((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetVec((__Instance + __PointerAdjustment), value);
                }
            }
        }

        /// <summary>X86/X64 registers mask.</summary>
        public unsafe partial class X86RegMask : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::GraphEngine.Jit.Native.Asmjit.X86RegMask._.__Internal _;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0X86RegMask@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@X86RegMask@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?has@X86RegMask@asmjit@@QEBA_NII@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Has(global::System.IntPtr instance, uint kind, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasGp@X86RegMask@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasGp(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasVec@X86RegMask@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasVec(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasMm@X86RegMask@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasMm(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?hasK@X86RegMask@asmjit@@QEBA_NI@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasK(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get@X86RegMask@asmjit@@QEBAII@Z")]
                internal static extern uint Get(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?zero@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void Zero(global::System.IntPtr instance, uint kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?zeroGp@X86RegMask@asmjit@@QEAAXXZ")]
                internal static extern void ZeroGp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?zeroVec@X86RegMask@asmjit@@QEAAXXZ")]
                internal static extern void ZeroVec(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?zeroMm@X86RegMask@asmjit@@QEAAXXZ")]
                internal static extern void ZeroMm(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?zeroK@X86RegMask@asmjit@@QEAAXXZ")]
                internal static extern void ZeroK(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set@X86RegMask@asmjit@@QEAAXAEBU12@@Z")]
                internal static extern void Set(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set@X86RegMask@asmjit@@QEAAXII@Z")]
                internal static extern void Set(global::System.IntPtr instance, uint kind, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?and_@X86RegMask@asmjit@@QEAAXAEBU12@@Z")]
                internal static extern void And(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?and_@X86RegMask@asmjit@@QEAAXII@Z")]
                internal static extern void And(global::System.IntPtr instance, uint kind, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andGp@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void AndGp(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andVec@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void AndVec(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andMm@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void AndMm(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andK@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void AndK(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNot@X86RegMask@asmjit@@QEAAXAEBU12@@Z")]
                internal static extern void AndNot(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNot@X86RegMask@asmjit@@QEAAXII@Z")]
                internal static extern void AndNot(global::System.IntPtr instance, uint kind, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNotGp@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void AndNotGp(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNotVec@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void AndNotVec(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNotMm@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void AndNotMm(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?andNotK@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void AndNotK(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?or_@X86RegMask@asmjit@@QEAAXAEBU12@@Z")]
                internal static extern void Or(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?or_@X86RegMask@asmjit@@QEAAXII@Z")]
                internal static extern void Or(global::System.IntPtr instance, uint kind, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?orGp@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void OrGp(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?orVec@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void OrVec(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?orMm@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void OrMm(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?orK@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void OrK(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?xor_@X86RegMask@asmjit@@QEAAXAEBU12@@Z")]
                internal static extern void Xor(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?xor_@X86RegMask@asmjit@@QEAAXII@Z")]
                internal static extern void Xor(global::System.IntPtr instance, uint kind, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?xorGp@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void XorGp(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?xorVec@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void XorVec(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?xorMm@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void XorMm(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?xorK@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void XorK(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getGp@X86RegMask@asmjit@@QEBAIXZ")]
                internal static extern uint GetGp(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setGp@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void SetGp(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVec@X86RegMask@asmjit@@QEBAIXZ")]
                internal static extern uint GetVec(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setVec@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void SetVec(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getMm@X86RegMask@asmjit@@QEBAIXZ")]
                internal static extern uint GetMm(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setMm@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void SetMm(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getK@X86RegMask@asmjit@@QEBAIXZ")]
                internal static extern uint GetK(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setK@X86RegMask@asmjit@@QEAAXI@Z")]
                internal static extern void SetK(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?isEmpty@X86RegMask@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsEmpty(global::System.IntPtr instance);
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.X86RegMask._.__.__Internal __;

                    [FieldOffset(0)]
                    internal global::GraphEngine.Jit.Native.Asmjit.UInt64T.__Internal _packed;
                }

                public unsafe partial class __
                {
                    [StructLayout(LayoutKind.Explicit, Size = 8)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal ushort _gp;

                        [FieldOffset(2)]
                        internal byte _mm;

                        [FieldOffset(3)]
                        internal byte _k;

                        [FieldOffset(4)]
                        internal uint _vec;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86RegMask> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.X86RegMask>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.X86RegMask __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86RegMask(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.X86RegMask __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.X86RegMask.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.X86RegMask(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.X86RegMask.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86RegMask.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.X86RegMask.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private X86RegMask(global::GraphEngine.Jit.Native.Asmjit.X86RegMask.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected X86RegMask(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public X86RegMask()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86RegMask.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public X86RegMask(global::GraphEngine.Jit.Native.Asmjit.X86RegMask _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.X86RegMask.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.X86RegMask.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.X86RegMask.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.X86RegMask __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Reset all register masks to zero.</summary>
            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            public bool Has(uint kind, uint mask)
            {
                var __ret = __Internal.Has((__Instance + __PointerAdjustment), kind, mask);
                return __ret;
            }

            public bool HasGp(uint mask)
            {
                var __ret = __Internal.HasGp((__Instance + __PointerAdjustment), mask);
                return __ret;
            }

            public bool HasVec(uint mask)
            {
                var __ret = __Internal.HasVec((__Instance + __PointerAdjustment), mask);
                return __ret;
            }

            public bool HasMm(uint mask)
            {
                var __ret = __Internal.HasMm((__Instance + __PointerAdjustment), mask);
                return __ret;
            }

            public bool HasK(uint mask)
            {
                var __ret = __Internal.HasK((__Instance + __PointerAdjustment), mask);
                return __ret;
            }

            public uint Get(uint kind)
            {
                var __ret = __Internal.Get((__Instance + __PointerAdjustment), kind);
                return __ret;
            }

            public void Zero(uint kind)
            {
                __Internal.Zero((__Instance + __PointerAdjustment), kind);
            }

            public void ZeroGp()
            {
                __Internal.ZeroGp((__Instance + __PointerAdjustment));
            }

            public void ZeroVec()
            {
                __Internal.ZeroVec((__Instance + __PointerAdjustment));
            }

            public void ZeroMm()
            {
                __Internal.ZeroMm((__Instance + __PointerAdjustment));
            }

            public void ZeroK()
            {
                __Internal.ZeroK((__Instance + __PointerAdjustment));
            }

            public void Set(global::GraphEngine.Jit.Native.Asmjit.X86RegMask other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Set((__Instance + __PointerAdjustment), __arg0);
            }

            public void Set(uint kind, uint mask)
            {
                __Internal.Set((__Instance + __PointerAdjustment), kind, mask);
            }

            public void And(global::GraphEngine.Jit.Native.Asmjit.X86RegMask other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.And((__Instance + __PointerAdjustment), __arg0);
            }

            public void And(uint kind, uint mask)
            {
                __Internal.And((__Instance + __PointerAdjustment), kind, mask);
            }

            public void AndGp(uint mask)
            {
                __Internal.AndGp((__Instance + __PointerAdjustment), mask);
            }

            public void AndVec(uint mask)
            {
                __Internal.AndVec((__Instance + __PointerAdjustment), mask);
            }

            public void AndMm(uint mask)
            {
                __Internal.AndMm((__Instance + __PointerAdjustment), mask);
            }

            public void AndK(uint mask)
            {
                __Internal.AndK((__Instance + __PointerAdjustment), mask);
            }

            public void AndNot(global::GraphEngine.Jit.Native.Asmjit.X86RegMask other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.AndNot((__Instance + __PointerAdjustment), __arg0);
            }

            public void AndNot(uint kind, uint mask)
            {
                __Internal.AndNot((__Instance + __PointerAdjustment), kind, mask);
            }

            public void AndNotGp(uint mask)
            {
                __Internal.AndNotGp((__Instance + __PointerAdjustment), mask);
            }

            public void AndNotVec(uint mask)
            {
                __Internal.AndNotVec((__Instance + __PointerAdjustment), mask);
            }

            public void AndNotMm(uint mask)
            {
                __Internal.AndNotMm((__Instance + __PointerAdjustment), mask);
            }

            public void AndNotK(uint mask)
            {
                __Internal.AndNotK((__Instance + __PointerAdjustment), mask);
            }

            public void Or(global::GraphEngine.Jit.Native.Asmjit.X86RegMask other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Or((__Instance + __PointerAdjustment), __arg0);
            }

            public void Or(uint kind, uint mask)
            {
                __Internal.Or((__Instance + __PointerAdjustment), kind, mask);
            }

            public void OrGp(uint mask)
            {
                __Internal.OrGp((__Instance + __PointerAdjustment), mask);
            }

            public void OrVec(uint mask)
            {
                __Internal.OrVec((__Instance + __PointerAdjustment), mask);
            }

            public void OrMm(uint mask)
            {
                __Internal.OrMm((__Instance + __PointerAdjustment), mask);
            }

            public void OrK(uint mask)
            {
                __Internal.OrK((__Instance + __PointerAdjustment), mask);
            }

            public void Xor(global::GraphEngine.Jit.Native.Asmjit.X86RegMask other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.Xor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Xor(uint kind, uint mask)
            {
                __Internal.Xor((__Instance + __PointerAdjustment), kind, mask);
            }

            public void XorGp(uint mask)
            {
                __Internal.XorGp((__Instance + __PointerAdjustment), mask);
            }

            public void XorVec(uint mask)
            {
                __Internal.XorVec((__Instance + __PointerAdjustment), mask);
            }

            public void XorMm(uint mask)
            {
                __Internal.XorMm((__Instance + __PointerAdjustment), mask);
            }

            public void XorK(uint mask)
            {
                __Internal.XorK((__Instance + __PointerAdjustment), mask);
            }

            public uint Gp
            {
                get
                {
                    var __ret = __Internal.GetGp((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetGp((__Instance + __PointerAdjustment), value);
                }
            }

            public uint Vec
            {
                get
                {
                    var __ret = __Internal.GetVec((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetVec((__Instance + __PointerAdjustment), value);
                }
            }

            public uint Mm
            {
                get
                {
                    var __ret = __Internal.GetMm((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetMm((__Instance + __PointerAdjustment), value);
                }
            }

            public uint K
            {
                get
                {
                    var __ret = __Internal.GetK((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetK((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get whether all register masks are zero (empty).</summary>
            public bool IsEmpty
            {
                get
                {
                    var __ret = __Internal.IsEmpty((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Base runtime.</summary>
        public unsafe abstract partial class Runtime : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_Runtime;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(24)]
                internal byte _runtimeType;

                [FieldOffset(25)]
                internal byte _allocType;

                [FieldOffset(26)]
                internal fixed byte _reserved[6];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Runtime@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1Runtime@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getCodeInfo@Runtime@asmjit@@QEBAAEBVCodeInfo@2@XZ")]
                internal static extern global::System.IntPtr GetCodeInfo(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchType@Runtime@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArchSubType@Runtime@asmjit@@QEBAIXZ")]
                internal static extern uint GetArchSubType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getRuntimeType@Runtime@asmjit@@QEBAIXZ")]
                internal static extern uint GetRuntimeType(global::System.IntPtr instance);
            }

            public enum RuntimeType : uint
            {
                kRuntimeNone = 0,
                kRuntimeJit = 1,
                kRuntimeRemote = 2
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Runtime> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Runtime>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.Runtime __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RuntimeInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Runtime __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Runtime.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.RuntimeInternal(native, skipVTables);
            }

            protected Runtime(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a `Runtime` instance.</summary>
            protected Runtime()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Runtime.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.Runtime");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.Runtime __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.Runtime.__Internal*) __Instance)->vfptr_Runtime = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Allocate a memory needed for a code stored in the</summary>
            /// <remarks>
            /// <para>relocate it to the target location.</para>
            /// <para>The beginning of the memory allocated for the function is returned in</para>
            /// <para>`dst`. If failed the</para>
            /// <para>(this means that you don't have to set it to null before calling `add()`).</para>
            /// </remarks>
            public abstract uint Add(void** dst, global::GraphEngine.Jit.Native.Asmjit.CodeHolder code);

            /// <summary>Release `p` allocated by `add()`.</summary>
            public abstract uint Release(global::System.IntPtr p);

            /// <summary>Get CodeInfo of this runtime.</summary>
            /// <remarks>
            /// <para>CodeInfo can be used to setup a CodeHolder in case you plan to generate a</para>
            /// <para>code compatible and executable by this Runtime.</para>
            /// </remarks>
            public global::GraphEngine.Jit.Native.Asmjit.CodeInfo CodeInfo
            {
                get
                {
                    var __ret = __Internal.GetCodeInfo((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.CodeInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.CodeInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.CodeInfo) global::GraphEngine.Jit.Native.Asmjit.CodeInfo.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get the Runtime's architecture type, see</summary>
            public uint ArchType
            {
                get
                {
                    var __ret = __Internal.GetArchType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the Runtime's architecture sub-type, see</summary>
            public uint ArchSubType
            {
                get
                {
                    var __ret = __Internal.GetArchSubType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the runtime type, see</summary>
            public uint runtimeType
            {
                get
                {
                    var __ret = __Internal.GetRuntimeType((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~Runtime() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Runtime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error _add(void** dst, CodeHolder* code) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_voidPtrPtr_IntPtr _AddDelegateInstance;

            private static uint _AddDelegateHook(global::System.IntPtr instance, void** dst, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Runtime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result1;
                if (code == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.Add(dst, __result1);
                return __ret;
            }

            // Error _release(void* p) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _ReleaseDelegateInstance;

            private static uint _ReleaseDelegateHook(global::System.IntPtr instance, global::System.IntPtr p)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.Runtime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Release(p);
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[3];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _AddDelegateInstance += _AddDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AddDelegateInstance).ToPointer();
                    _ReleaseDelegateInstance += _ReleaseDelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ReleaseDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                        *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                        *(void**) (vfptr0 + 16) = _Thunks[2];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        /// <summary>Runtime designed to be used in the same process the code is generated in.</summary>
        public unsafe abstract partial class HostRuntime : global::GraphEngine.Jit.Native.Asmjit.Runtime, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_Runtime;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(24)]
                internal byte _runtimeType;

                [FieldOffset(25)]
                internal byte _allocType;

                [FieldOffset(26)]
                internal fixed byte _reserved[6];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0HostRuntime@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1HostRuntime@asmjit@@UEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.HostRuntime __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.HostRuntimeInternal(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.HostRuntime __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.HostRuntime.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.HostRuntimeInternal(native, skipVTables);
            }

            protected HostRuntime(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a `HostRuntime` instance.</summary>
            protected HostRuntime()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.HostRuntime.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.HostRuntime");
            }

            public override void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.Runtime __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::GraphEngine.Jit.Native.Asmjit.HostRuntime.__Internal*) __Instance)->vfptr_Runtime = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    if (__slot != null)
                    {
                        var ___dtorDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int));
                        ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                    }
                    else
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Flush an instruction cache.</summary>
            /// <remarks>
            /// <para>This member function is called after the code has been copied to the</para>
            /// <para>destination buffer. It is only useful for JIT code generation as it</para>
            /// <para>causes a flush of the processor's cache.</para>
            /// <para>Flushing is basically a NOP under X86/X64, but is needed by architectures</para>
            /// <para>that do not have a transparent instruction cache like ARM.</para>
            /// <para>This function can also be overridden to improve compatibility with tools</para>
            /// <para>such as Valgrind, however, it's not an official part of AsmJit.</para>
            /// </remarks>
            public virtual void Flush(global::System.IntPtr p, ulong size)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___FlushDelegate = (global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_ulong));
                ___FlushDelegate((__Instance + __PointerAdjustment), p, size);
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~HostRuntime() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.HostRuntime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error _add(void** dst, CodeHolder* code) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_voidPtrPtr_IntPtr _AddDelegateInstance;

            private static uint _AddDelegateHook(global::System.IntPtr instance, void** dst, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.HostRuntime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result1;
                if (code == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.Add(dst, __result1);
                return __ret;
            }

            // Error _release(void* p) noexcept = 0
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _ReleaseDelegateInstance;

            private static uint _ReleaseDelegateHook(global::System.IntPtr instance, global::System.IntPtr p)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.HostRuntime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Release(p);
                return __ret;
            }

            // void flush(const void* p, size_t size) noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_ulong _FlushDelegateInstance;

            private static void _FlushDelegateHook(global::System.IntPtr instance, global::System.IntPtr p, ulong size)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.HostRuntime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Flush(p, size);
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[4];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _AddDelegateInstance += _AddDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AddDelegateInstance).ToPointer();
                    _ReleaseDelegateInstance += _ReleaseDelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ReleaseDelegateInstance).ToPointer();
                    _FlushDelegateInstance += _FlushDelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_FlushDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                        *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                        *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                        *(void**) (vfptr0 + 16) = _Thunks[2];
                        *(void**) (vfptr0 + 24) = _Thunks[3];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        /// <summary>Runtime designed to store and execute code generated at runtime (JIT).</summary>
        public unsafe partial class JitRuntime : global::GraphEngine.Jit.Native.Asmjit.HostRuntime, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 160)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_Runtime;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.CodeInfo.__Internal _codeInfo;

                [FieldOffset(24)]
                internal byte _runtimeType;

                [FieldOffset(25)]
                internal byte _allocType;

                [FieldOffset(26)]
                internal fixed byte _reserved[6];

                [FieldOffset(32)]
                internal global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal _memMgr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0JitRuntime@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAllocType@JitRuntime@asmjit@@QEBAIXZ")]
                internal static extern uint GetAllocType(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setAllocType@JitRuntime@asmjit@@QEAAXI@Z")]
                internal static extern void SetAllocType(global::System.IntPtr instance, uint allocType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getMemMgr@JitRuntime@asmjit@@QEBAPEAVVMemMgr@2@XZ")]
                internal static extern global::System.IntPtr GetMemMgr(global::System.IntPtr instance);
            }

            internal static new global::GraphEngine.Jit.Native.Asmjit.JitRuntime __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.JitRuntime(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.JitRuntime __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.JitRuntime.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.JitRuntime(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.JitRuntime.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.JitRuntime.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.JitRuntime.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private JitRuntime(global::GraphEngine.Jit.Native.Asmjit.JitRuntime.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected JitRuntime(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            /// <summary>Create a `JitRuntime` instance.</summary>
            public JitRuntime()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.JitRuntime.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "GraphEngine.Jit.Native.Asmjit.JitRuntime");
            }

            public override uint Add(void** dst, global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___AddDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_voidPtrPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_voidPtrPtr_IntPtr));
                var __arg1 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___AddDelegate((__Instance + __PointerAdjustment), dst, __arg1);
                return __ret;
            }

            public override uint Release(global::System.IntPtr p)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___ReleaseDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __ret = ___ReleaseDelegate((__Instance + __PointerAdjustment), p);
                return __ret;
            }

            /// <summary>Get the type of allocation.</summary>
            /// <remarks>Set the type of allocation.</remarks>
            public uint AllocType
            {
                get
                {
                    var __ret = __Internal.GetAllocType((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetAllocType((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get the virtual memory manager.</summary>
            public global::GraphEngine.Jit.Native.Asmjit.VMemMgr MemMgr
            {
                get
                {
                    var __ret = __Internal.GetMemMgr((__Instance + __PointerAdjustment));
                    global::GraphEngine.Jit.Native.Asmjit.VMemMgr __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::GraphEngine.Jit.Native.Asmjit.VMemMgr.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::GraphEngine.Jit.Native.Asmjit.VMemMgr) global::GraphEngine.Jit.Native.Asmjit.VMemMgr.NativeToManagedMap[__ret];
                    else __result0 = global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__CreateInstance(__ret);
                    return __result0;
                }
            }

            #region Virtual table interop

            // ASMJIT_API virtual ~JitRuntime() noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.JitRuntime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            // Error _add(void** dst, CodeHolder* code) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_voidPtrPtr_IntPtr _AddDelegateInstance;

            private static uint _AddDelegateHook(global::System.IntPtr instance, void** dst, global::System.IntPtr code)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.JitRuntime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                global::GraphEngine.Jit.Native.Asmjit.CodeHolder __result1;
                if (code == IntPtr.Zero) __result1 = null;
                else if (global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap.ContainsKey(code))
                    __result1 = (global::GraphEngine.Jit.Native.Asmjit.CodeHolder) global::GraphEngine.Jit.Native.Asmjit.CodeHolder.NativeToManagedMap[code];
                else __result1 = global::GraphEngine.Jit.Native.Asmjit.CodeHolder.__CreateInstance(code);
                var __ret = __target.Add(dst, __result1);
                return __ret;
            }

            // Error _release(void* p) noexcept override
            private static global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr _ReleaseDelegateInstance;

            private static uint _ReleaseDelegateHook(global::System.IntPtr instance, global::System.IntPtr p)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.JitRuntime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.Release(p);
                return __ret;
            }

            // void flush(const void* p, size_t size) noexcept
            private static global::GraphEngine.Jit.Native.Delegates.Action_IntPtr_IntPtr_ulong _FlushDelegateInstance;

            private static void _FlushDelegateHook(global::System.IntPtr instance, global::System.IntPtr p, ulong size)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::GraphEngine.Jit.Native.Asmjit.JitRuntime) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Flush(p, size);
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[4];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                    _AddDelegateInstance += _AddDelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AddDelegateInstance).ToPointer();
                    _ReleaseDelegateInstance += _ReleaseDelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ReleaseDelegateInstance).ToPointer();
                    _FlushDelegateInstance += _FlushDelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_FlushDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                        *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                        *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = _Thunks[1];
                        *(void**) (vfptr0 + 16) = _Thunks[2];
                        *(void**) (vfptr0 + 24) = _Thunks[3];
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        public unsafe partial class RuntimeInternal : global::GraphEngine.Jit.Native.Asmjit.Runtime, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Runtime.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Runtime.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.Runtime.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal RuntimeInternal(global::GraphEngine.Jit.Native.Asmjit.Runtime.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal RuntimeInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Allocate a memory needed for a code stored in the</summary>
            /// <remarks>
            /// <para>relocate it to the target location.</para>
            /// <para>The beginning of the memory allocated for the function is returned in</para>
            /// <para>`dst`. If failed the</para>
            /// <para>(this means that you don't have to set it to null before calling `add()`).</para>
            /// </remarks>
            public override uint Add(void** dst, global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___AddDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_voidPtrPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_voidPtrPtr_IntPtr));
                var __arg1 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___AddDelegate((__Instance + __PointerAdjustment), dst, __arg1);
                return __ret;
            }

            /// <summary>Release `p` allocated by `add()`.</summary>
            public override uint Release(global::System.IntPtr p)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___ReleaseDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __ret = ___ReleaseDelegate((__Instance + __PointerAdjustment), p);
                return __ret;
            }
        }

        public unsafe partial class HostRuntimeInternal : global::GraphEngine.Jit.Native.Asmjit.HostRuntime, IDisposable
        {
            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.HostRuntime.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.HostRuntime.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.HostRuntime.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal HostRuntimeInternal(global::GraphEngine.Jit.Native.Asmjit.HostRuntime.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal HostRuntimeInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            /// <summary>Allocate a memory needed for a code stored in the</summary>
            /// <remarks>
            /// <para>relocate it to the target location.</para>
            /// <para>The beginning of the memory allocated for the function is returned in</para>
            /// <para>`dst`. If failed the</para>
            /// <para>(this means that you don't have to set it to null before calling `add()`).</para>
            /// </remarks>
            public override uint Add(void** dst, global::GraphEngine.Jit.Native.Asmjit.CodeHolder code)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___AddDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_voidPtrPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_voidPtrPtr_IntPtr));
                var __arg1 = ReferenceEquals(code, null) ? global::System.IntPtr.Zero : code.__Instance;
                var __ret = ___AddDelegate((__Instance), dst, __arg1);
                return __ret;
            }

            /// <summary>Release `p` allocated by `add()`.</summary>
            public override uint Release(global::System.IntPtr p)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___ReleaseDelegate = (global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::GraphEngine.Jit.Native.Delegates.Func_uint_IntPtr_IntPtr));
                var __ret = ___ReleaseDelegate((__Instance), p);
                return __ret;
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>Information about OS virtual memory.</summary>
        public unsafe partial class VMemInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr hCurrentProcess;

                [FieldOffset(8)]
                internal ulong pageSize;

                [FieldOffset(16)]
                internal ulong pageGranularity;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0VMemInfo@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemInfo>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.VMemInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.VMemInfo(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.VMemInfo __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.VMemInfo(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VMemInfo(global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VMemInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public VMemInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public VMemInfo(global::GraphEngine.Jit.Native.Asmjit.VMemInfo _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.VMemInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>OS utilities.</summary>
        /// <remarks>
        /// <para>Virtual Memory</para>
        /// <para>--------------</para>
        /// <para>Provides functions to allocate and release virtual memory that is required</para>
        /// <para>to execute dynamically generated code. If both processor and host OS support</para>
        /// <para>data-execution-prevention (DEP) then the only way to run machine code is to</para>
        /// <para>allocate virtual memory that has `OSUtils::kVMExecutable` flag enabled. All</para>
        /// <para>functions provides by OSUtils use internally platform specific API.</para>
        /// <para>Benchmarking</para>
        /// <para>------------</para>
        /// <para>OSUtils also provide a function `getTickCount()` that can be used for</para>
        /// <para>benchmarking purposes. It's similar to Windows-only `GetTickCount()`, but</para>
        /// <para>it's cross-platform and tries to be the most reliable platform specific</para>
        /// <para>calls to make the result usable.</para>
        /// </remarks>
        public unsafe partial class OSUtils : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0OSUtils@asmjit@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?allocVirtualMemory@OSUtils@asmjit@@SAPEAX_KPEA_KI@Z")]
                internal static extern global::System.IntPtr AllocVirtualMemory(ulong size, ulong* allocated, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?releaseVirtualMemory@OSUtils@asmjit@@SAIPEAX_K@Z")]
                internal static extern uint ReleaseVirtualMemory(global::System.IntPtr p, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?allocProcessMemory@OSUtils@asmjit@@SAPEAXPEAX_KPEA_KI@Z")]
                internal static extern global::System.IntPtr AllocProcessMemory(global::System.IntPtr hProcess, ulong size, ulong* allocated, uint flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?releaseProcessMemory@OSUtils@asmjit@@SAIPEAX0_K@Z")]
                internal static extern uint ReleaseProcessMemory(global::System.IntPtr hProcess, global::System.IntPtr p, ulong size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getVirtualMemoryInfo@OSUtils@asmjit@@SA?AUVMemInfo@2@XZ")]
                internal static extern void GetVirtualMemoryInfo(global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getTickCount@OSUtils@asmjit@@SAIXZ")]
                internal static extern uint GetTickCount();
            }

            /// <summary>Virtual memory flags.</summary>
            public enum VMFlags : uint
            {
                /// <summary>Virtual memory is writable.</summary>
                kVMWritable = 0x1,
                /// <summary>Virtual memory is executable.</summary>
                kVMExecutable = 0x2
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.OSUtils> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.OSUtils>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.OSUtils __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.OSUtils(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.OSUtils __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.OSUtils.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.OSUtils(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.OSUtils.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.OSUtils.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.OSUtils.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private OSUtils(global::GraphEngine.Jit.Native.Asmjit.OSUtils.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected OSUtils(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public OSUtils()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.OSUtils.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public OSUtils(global::GraphEngine.Jit.Native.Asmjit.OSUtils _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.OSUtils.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.OSUtils.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.OSUtils.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.OSUtils __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Allocate virtual memory.</summary>
            public static global::System.IntPtr AllocVirtualMemory(ulong size, ref ulong allocated, uint flags)
            {
                fixed (ulong* __refParamPtr1 = &allocated)
                {
                    var __arg1 = __refParamPtr1;
                    var __ret = __Internal.AllocVirtualMemory(size, __arg1, flags);
                    return __ret;
                }
            }

            /// <summary>Release virtual memory previously allocated by</summary>
            public static uint ReleaseVirtualMemory(global::System.IntPtr p, ulong size)
            {
                var __ret = __Internal.ReleaseVirtualMemory(p, size);
                return __ret;
            }

            /// <summary>Allocate virtual memory of `hProcess` (Windows).</summary>
            public static global::System.IntPtr AllocProcessMemory(global::System.IntPtr hProcess, ulong size, ref ulong allocated, uint flags)
            {
                fixed (ulong* __refParamPtr2 = &allocated)
                {
                    var __arg2 = __refParamPtr2;
                    var __ret = __Internal.AllocProcessMemory(hProcess, size, __arg2, flags);
                    return __ret;
                }
            }

            /// <summary>Release virtual memory of `hProcess` (Windows).</summary>
            public static uint ReleaseProcessMemory(global::System.IntPtr hProcess, global::System.IntPtr p, ulong size)
            {
                var __ret = __Internal.ReleaseProcessMemory(hProcess, p, size);
                return __ret;
            }

            public static global::GraphEngine.Jit.Native.Asmjit.VMemInfo VirtualMemoryInfo
            {
                get
                {
                    var __ret = new global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__Internal();
                    __Internal.GetVirtualMemoryInfo(new IntPtr(&__ret));
                    return global::GraphEngine.Jit.Native.Asmjit.VMemInfo.__CreateInstance(__ret);
                }
            }

            /// <summary>Get the current CPU tick count, used for benchmarking (1ms resolution).</summary>
            public static uint TickCount
            {
                get
                {
                    var __ret = __Internal.GetTickCount();
                    return __ret;
                }
            }
        }

        /// <summary>Lock.</summary>
        public unsafe partial class Lock : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::RTL_CRITICAL_SECTION.__Internal _handle;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0Lock@asmjit@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1Lock@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?lock@Lock@asmjit@@QEAAXXZ")]
                internal static extern void @lock(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?unlock@Lock@asmjit@@QEAAXXZ")]
                internal static extern void Unlock(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Lock> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.Lock>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.Lock __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Lock(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.Lock __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.Lock.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.Lock(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.Lock.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Lock.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.Lock.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Lock(global::GraphEngine.Jit.Native.Asmjit.Lock.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Lock(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a new `Lock` instance.</summary>
            public Lock()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.Lock.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.Lock __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Lock.</summary>
            public void @lock()
            {
                __Internal.@lock((__Instance + __PointerAdjustment));
            }

            /// <summary>Unlock.</summary>
            public void Unlock()
            {
                __Internal.Unlock((__Instance + __PointerAdjustment));
            }
        }

        /// <summary>Scoped lock.</summary>
        public unsafe partial class AutoLock : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _target;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0AutoLock@asmjit@@QEAA@AEAULock@1@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr target);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1AutoLock@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.AutoLock> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.AutoLock>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.AutoLock __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.AutoLock(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.AutoLock __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.AutoLock.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.AutoLock(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.AutoLock.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.AutoLock.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.AutoLock.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private AutoLock(global::GraphEngine.Jit.Native.Asmjit.AutoLock.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AutoLock(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public AutoLock(global::GraphEngine.Jit.Native.Asmjit.Lock target)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.AutoLock.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(target, null))
                    throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = target.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.AutoLock __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }
    }

    namespace Asmjit
    {
        /// <summary>
        /// <para>Reference implementation of memory manager that uses `VMemUtil` to allocate</para>
        /// <para>chunks of virtual memory and bit arrays to manage it.</para>
        /// </summary>
        public unsafe partial class VMemMgr : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 128)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr _hProcess;

                [FieldOffset(8)]
                internal global::GraphEngine.Jit.Native.Asmjit.Lock.__Internal _lock;

                [FieldOffset(48)]
                internal ulong _blockSize;

                [FieldOffset(56)]
                internal ulong _blockDensity;

                [FieldOffset(64)]
                internal byte _keepVirtualMemory;

                [FieldOffset(72)]
                internal ulong _allocatedBytes;

                [FieldOffset(80)]
                internal ulong _usedBytes;

                [FieldOffset(88)]
                internal global::System.IntPtr _root;

                [FieldOffset(96)]
                internal global::System.IntPtr _first;

                [FieldOffset(104)]
                internal global::System.IntPtr _last;

                [FieldOffset(112)]
                internal global::System.IntPtr _optimal;

                [FieldOffset(120)]
                internal global::System.IntPtr _permanent;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0VMemMgr@asmjit@@QEAA@PEAX@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr hProcess);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0VMemMgr@asmjit@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1VMemMgr@asmjit@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@VMemMgr@asmjit@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?alloc@VMemMgr@asmjit@@QEAAPEAX_KI@Z")]
                internal static extern global::System.IntPtr Alloc(global::System.IntPtr instance, ulong size, uint type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?release@VMemMgr@asmjit@@QEAAIPEAX@Z")]
                internal static extern uint Release(global::System.IntPtr instance, global::System.IntPtr p);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?shrink@VMemMgr@asmjit@@QEAAIPEAX_K@Z")]
                internal static extern uint Shrink(global::System.IntPtr instance, global::System.IntPtr p, ulong used);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getKeepVirtualMemory@VMemMgr@asmjit@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetKeepVirtualMemory(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?setKeepVirtualMemory@VMemMgr@asmjit@@QEAAX_N@Z")]
                internal static extern void SetKeepVirtualMemory(global::System.IntPtr instance, bool val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getProcessHandle@VMemMgr@asmjit@@QEBAPEAXXZ")]
                internal static extern global::System.IntPtr GetProcessHandle(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getAllocatedBytes@VMemMgr@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetAllocatedBytes(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUsedBytes@VMemMgr@asmjit@@QEBA_KXZ")]
                internal static extern ulong GetUsedBytes(global::System.IntPtr instance);
            }

            /// <summary>Type of virtual memory allocation, see `VMemMgr::alloc()`.</summary>
            public enum AllocType : uint
            {
                /// <summary>Normal memory allocation, has to be freed by `VMemMgr::release()`.</summary>
                kAllocFreeable = 0,
                /// <summary>Allocate permanent memory, can't be freed.</summary>
                kAllocPermanent = 1
            }

            public unsafe partial class MemNode
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private MemNode(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.MemNode.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MemNode(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }
            }

            public unsafe partial class PermanentNode
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private PermanentNode(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.PermanentNode.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PermanentNode(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }
            }

            /// <summary>\{</summary>
            public unsafe partial class RbNode
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode(native.ToPointer(), skipVTables);
                }

                internal static global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode.__Internal native, bool skipVTables = false)
                {
                    return new global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode(native, skipVTables);
                }

                private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode.__Internal));
                    *(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private RbNode(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.RbNode.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected RbNode(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemMgr> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.Asmjit.VMemMgr>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::GraphEngine.Jit.Native.Asmjit.VMemMgr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.VMemMgr(native.ToPointer(), skipVTables);
            }

            internal static global::GraphEngine.Jit.Native.Asmjit.VMemMgr __CreateInstance(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal native, bool skipVTables = false)
            {
                return new global::GraphEngine.Jit.Native.Asmjit.VMemMgr(native, skipVTables);
            }

            private static void* __CopyValue(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal));
                *(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VMemMgr(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VMemMgr(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Create a `VMemMgr` instance.</summary>
            /// <remarks>
            /// <para>NOTE: When running on Windows it's possible to specify a `hProcess` to</para>
            /// <para>be used for memory allocation. Using `hProcess` allows to allocate memory</para>
            /// <para>of a remote process.</para>
            /// </remarks>
            public VMemMgr(global::System.IntPtr hProcess)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), hProcess);
            }

            public VMemMgr(global::GraphEngine.Jit.Native.Asmjit.VMemMgr _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.Asmjit.VMemMgr.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::GraphEngine.Jit.Native.Asmjit.VMemMgr __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Free all allocated memory.</summary>
            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Allocate a `size` bytes of virtual memory.</summary>
            /// <remarks>
            /// <para>Note that if you are implementing your own virtual memory manager then you</para>
            /// <para>can quitly ignore type of allocation. This is mainly for AsmJit to memory</para>
            /// <para>manager that allocated memory will be never freed.</para>
            /// </remarks>
            public global::System.IntPtr Alloc(ulong size, uint type)
            {
                var __ret = __Internal.Alloc((__Instance + __PointerAdjustment), size, type);
                return __ret;
            }

            /// <summary>Free previously allocated memory at a given `address`.</summary>
            public uint Release(global::System.IntPtr p)
            {
                var __ret = __Internal.Release((__Instance + __PointerAdjustment), p);
                return __ret;
            }

            /// <summary>Free extra memory allocated with `p`.</summary>
            public uint Shrink(global::System.IntPtr p, ulong used)
            {
                var __ret = __Internal.Shrink((__Instance + __PointerAdjustment), p, used);
                return __ret;
            }

            /// <summary>Get whether to keep allocated memory after the `VMemMgr` is destroyed.</summary>
            /// <remarks>
            /// <para>Set whether to keep allocated memory after the memory manager is destroyed.</para>
            /// <para>This method is usable when patching code of remote process. You need to</para>
            /// <para>allocate process memory, store generated assembler into it and patch the</para>
            /// <para>method you want to redirect (into your code). This method affects only</para>
            /// <para>VMemMgr destructor. After destruction all internal</para>
            /// <para>structures are freed, only the process virtual memory remains.</para>
            /// <para>NOTE: Memory allocated with kAllocPermanent is always kept.</para>
            /// </remarks>
            public bool KeepVirtualMemory
            {
                get
                {
                    var __ret = __Internal.GetKeepVirtualMemory((__Instance + __PointerAdjustment));
                    return __ret;
                }

                set
                {
                    __Internal.SetKeepVirtualMemory((__Instance + __PointerAdjustment), value);
                }
            }

            /// <summary>Get the handle of the process memory manager is bound to.</summary>
            public global::System.IntPtr ProcessHandle
            {
                get
                {
                    var __ret = __Internal.GetProcessHandle((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get how many bytes are currently allocated.</summary>
            public ulong AllocatedBytes
            {
                get
                {
                    var __ret = __Internal.GetAllocatedBytes((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get how many bytes are currently used.</summary>
            public ulong UsedBytes
            {
                get
                {
                    var __ret = __Internal.GetUsedBytes((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }
    }

    public unsafe partial class TypeIdSpecializer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TypeIdSpecializer@@QEAA@AEBV0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("asmjit", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LPVOID@TypeIdSpecializer@@SAHXZ")]
            internal static extern int LPVOID();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.TypeIdSpecializer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GraphEngine.Jit.Native.TypeIdSpecializer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::GraphEngine.Jit.Native.TypeIdSpecializer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::GraphEngine.Jit.Native.TypeIdSpecializer(native.ToPointer(), skipVTables);
        }

        internal static global::GraphEngine.Jit.Native.TypeIdSpecializer __CreateInstance(global::GraphEngine.Jit.Native.TypeIdSpecializer.__Internal native, bool skipVTables = false)
        {
            return new global::GraphEngine.Jit.Native.TypeIdSpecializer(native, skipVTables);
        }

        private static void* __CopyValue(global::GraphEngine.Jit.Native.TypeIdSpecializer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.TypeIdSpecializer.__Internal));
            *(global::GraphEngine.Jit.Native.TypeIdSpecializer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TypeIdSpecializer(global::GraphEngine.Jit.Native.TypeIdSpecializer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TypeIdSpecializer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TypeIdSpecializer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.TypeIdSpecializer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TypeIdSpecializer(global::GraphEngine.Jit.Native.TypeIdSpecializer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::GraphEngine.Jit.Native.TypeIdSpecializer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::GraphEngine.Jit.Native.TypeIdSpecializer.__Internal*) __Instance) = *((global::GraphEngine.Jit.Native.TypeIdSpecializer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::GraphEngine.Jit.Native.TypeIdSpecializer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static int LPVOID
        {
            get
            {
                var __ret = __Internal.LPVOID();
                return __ret;
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr _0, int _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr(global::System.IntPtr _0, uint _1, global::System.IntPtr _2, global::System.IntPtr _3, global::System.IntPtr _4, global::System.IntPtr _5, global::System.IntPtr _6, global::System.IntPtr _7);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr_uint_IntPtr_ulong(global::System.IntPtr _0, uint _1, global::System.IntPtr _2, ulong _3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr_string_ulong_uint_uint(global::System.IntPtr _0, global::System.IntPtr _1, [MarshalAs(UnmanagedType.LPStr)] string _2, ulong _3, uint _4, uint _5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr_IntPtr_uint(global::System.IntPtr _0, global::System.IntPtr _1, uint _2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1, global::System.IntPtr _2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr_string_ulong(global::System.IntPtr _0, [MarshalAs(UnmanagedType.LPStr)] string _1, ulong _2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool_IntPtr_uint_string_IntPtr(global::System.IntPtr _0, uint _1, [MarshalAs(UnmanagedType.LPStr)] string _2, global::System.IntPtr _3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr_uint_IntPtr_IntPtr_IntPtr_IntPtr(global::System.IntPtr _0, uint _1, global::System.IntPtr _2, global::System.IntPtr _3, global::System.IntPtr _4, global::System.IntPtr _5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr_uint_uint(global::System.IntPtr _0, uint _1, uint _2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr_voidPtrPtr_IntPtr(global::System.IntPtr _0, void** _1, global::System.IntPtr _2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr_ulong(global::System.IntPtr _0, global::System.IntPtr _1, ulong _2);
    }
}
